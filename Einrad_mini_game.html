<!DOCTYPE html>
<html>
<head>
    <title>Pixel Runner Adventure</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta charset="UTF-8">
    <!-- Preload the loading image first -->
    <link rel="preload" href="https://raw.githubusercontent.com/ErSieCode/1Rad/main/load.png" as="image">
    <style>
        /* Reset and Base Styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100vh; overflow: hidden; background-color: #e0e0e0; font-family: 'Courier New', monospace; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; }
        #gameContainer { position: relative; width: 95vw; max-width: 800px; aspect-ratio: 16 / 9; max-height: 85vh; overflow: hidden; border: 2px solid #333; box-shadow: 0 5px 15px rgba(0,0,0,0.2); background-color: #87CEEB; /* Himmelsblau als Fallback */ }
        #gameCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        /* Loading Spinner Styles */
        #loadingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #loadingSpinner {
            width: 100px;
            height: 100px;
            animation: spin 2s linear infinite;
            display: block;
            object-fit: contain;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* UI Styles */
        #gameControls, #gameInfo, #livesDisplay, #quitButton, #pauseOverlay, #gameOver, #duckButton { position: absolute; z-index: 10; font-size: max(1.7vmin, 14px); }
        #gameControls {
            top: 2%;
            left: 2%;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #gameInfo { top: 2%; right: 10%; text-align: right; color: #eee; background-color: rgba(0, 0, 0, 0.5); padding: max(0.5vmin, 3px) max(1vmin, 6px); border-radius: 5px; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); }
        #gameInfo div { margin-bottom: 2px; }
        #livesDisplay { top: calc(2% + 60px); right: 10%; background-color: rgba(0, 0, 0, 0.5); padding: max(0.5vmin, 3px) max(1vmin, 6px); border-radius: 5px; display: flex; gap: 5px; }
        .heart { color: #ff4d4d; font-size: max(3vmin, 18px); font-weight: bold; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); transition: transform 0.2s ease-out, opacity 0.2s ease-out; }
        .heart.hidden { visibility: hidden; transform: scale(0.5); opacity: 0; }
        #quitButton { top: 2%; right: 2%; width: max(4vmin, 24px); height: max(4vmin, 24px); background-color: #ff3333; color: white; font-weight: bold; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; z-index: 30; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); border: none; font-size: max(2vmin, 12px); line-height: 1; }
        #quitButton:hover { background-color: #cc0000; }
        /* Back Button Styling - Moved to far left and changed to green */
        #backButton {
            top: 2%;
            left: 2%;
            width: max(4vmin, 24px);
            height: max(4vmin, 24px);
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 30;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: none;
            font-size: max(2vmin, 12px);
            line-height: 1;
            position: absolute;
        }
        #backButton:hover {
            background-color: #45a049;
        }
        #pauseOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 20; }
        #pauseOverlay h2 { color: #ffffff; font-size: max(4.5vmin, 26px); text-align: center; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); margin-bottom: 10px; }
        #pauseOverlay p { color: #f0f0f0; font-size: max(2.2vmin, 16px); text-align: center; margin-top: 15px; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); }
        /* Game Over mit Banner */
        #gameOver { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 20; background-image: url('https://raw.githubusercontent.com/ErSieCode/1Rad/main/Banner.png'); background-size: contain; background-repeat: no-repeat; background-position: center center; background-color: rgba(0, 0, 0, 0.6); text-align: center; }
        #gameOver h2 { color: #ffffff; font-size: max(4.5vmin, 26px); text-align: center; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); margin-bottom: 10px; margin-top: -10%; }
        #gameOver div { color: #f0f0f0; margin-bottom: 15px; font-size: max(2.5vmin, 17px); background-color: rgba(0,0,0,0.6); padding: 5px 10px; border-radius: 4px; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); }
        /* Buttons */
        #startButton, #restartButton, #settingsButton, #settingsCloseButton, #settingsResetButton {
            padding: max(1.4vmin, 10px) max(2.8vmin, 20px);
            font-size: max(2.3vmin, 16px);
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: 15px;
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
            text-shadow: 1px 1px 1px rgba(0,0,0,0.4);
            transition: background-color 0.2s;
        }
        #startButton:hover, #restartButton:hover, #settingsButton:hover, #settingsCloseButton:hover, #settingsResetButton:hover {
            background-color: #45a049;
        }
        #startButton, #settingsButton { margin-right: 5px; }
        #characterSelect { display: flex; gap: 10px; align-items: center; }
        #characterSelect img { width: max(6vmin, 35px); height: max(6vmin, 35px); cursor: pointer; border: 3px solid transparent; border-radius: 5px; background-color: rgba(255, 255, 255, 0.7); padding: 1px; transition: border-color 0.2s, transform 0.2s; }
        #characterSelect img:hover { transform: scale(1.1); }
        #characterSelect img.selected { border-color: #ff9800; transform: scale(1.05); }
        #instructions { width: 90%; max-width: 600px; text-align: center; color: #444; font-size: max(1.7vmin, 14px); z-index: 5; background-color: rgba(210, 210, 210, 0.8); padding: max(0.7vmin, 5px) max(1.2vmin, 9px); border-radius: 5px; margin-top: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        /* Duck Button CSS - Modified to be on the right side */
        #duckButton {
            bottom: 3%;
            right: 0.5%; /* Changed from left to right to move to right side */
            width: max(5vmin, 40px);
            height: max(5vmin, 40px);
            background-color: rgba(80, 80, 80, 0.6);
            border: none;
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: max(3.5vmin, 18px);
            z-index: 10;
            cursor: pointer;
            display: none;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            touch-action: manipulation;
            padding: 0;
            overflow: hidden;
            transition: background-color 0.1s, transform 0.1s, box-shadow 0.1s;
        }
        #duckButton img { width: 65%; height: 65%; object-fit: contain; pointer-events: none; }
        #duckButton:active { background-color: rgba(60, 60, 60, 0.8); transform: translateY(1px); box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3); }
        @keyframes doubleJumpEffect { 0% { transform: scale(1); opacity: 0.7; } 100% { transform: scale(2.5); opacity: 0; } }
        .doubleJumpEffect { position: absolute; border-radius: 50%; background-color: rgba(255, 215, 0, 0.6); pointer-events: none; z-index: 15; animation: doubleJumpEffect 0.4s ease-out forwards; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

        /* Settings Panel Styles - UPDATED FOR DIFFICULTY LEVELS */
        #settingsPanel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 25;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
            overflow-y: auto;
        }

        /* Added settings header container to hold title and back button */
        .settings-header {
            display: flex;
            width: 100%;
            justify-content: center;
            align-items: center;
            position: relative;
            margin-bottom: 20px;
            padding-top: 10px;
        }

        /* Settings back button styling */
        #settingsBackButton {
            position: absolute;
            left: 0;
            width: max(4.5vmin, 30px);
            height: max(4.5vmin, 30px);
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: none;
            font-size: max(2.2vmin, 16px);
            line-height: 1;
            -webkit-tap-highlight-color: transparent;
        }

        #settingsBackButton:hover,
        #settingsBackButton:active {
            background-color: #45a049;
        }

        #settingsPanel h2 {
            font-size: max(3vmin, 20px);
            color: #4CAF50;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            text-align: center;
        }

        /* NEW DIFFICULTY SELECTION STYLES */
        .difficulty-selection {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 500px;
        }

        .difficulty-title {
            font-size: max(2.2vmin, 16px);
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            color: #4CAF50;
        }

        .difficulty-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        .difficulty-option {
            position: relative;
            width: calc(50% - 10px);
            min-width: 100px;
        }

        @media (max-width: 500px) {
            .difficulty-option {
                width: 100%;
            }
        }

        .difficulty-option input[type="radio"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }

        .difficulty-option label {
            display: block;
            padding: 10px 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            font-weight: bold;
            transition: all 0.2s;
        }

        .difficulty-option input[type="radio"]:checked + label {
            border-color: #4CAF50;
            background-color: rgba(76, 175, 80, 0.3);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .difficulty-option:nth-child(1) label {
            color: #90EE90; /* Light green for easy */
        }

        .difficulty-option:nth-child(2) label {
            color: #FFFFFF; /* White for normal */
        }

        .difficulty-option:nth-child(3) label {
            color: #FFA500; /* Orange for hard */
        }

        .difficulty-option:nth-child(4) label {
            color: #FF6347; /* Tomato for very hard */
        }

        /* Setting sections */
        .settings-section {
            display: flex;
            flex-direction: column;
            width: 90%;
            max-width: 500px;
            margin-bottom: 15px;
        }

        .settings-section-title {
            font-size: max(1.8vmin, 15px);
            margin-bottom: 5px;
            color: #DDD;
            text-align: center;
        }

        /* Checkbox styling for hitbox toggle */
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
        }

        .checkbox-container input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-container label {
            font-size: max(1.8vmin, 14px);
            cursor: pointer;
            font-weight: bold;
        }

        .settings-buttons {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Make buttons bigger on mobile for better touch targets */
        @media (max-width: 500px) {
            #settingsResetButton, #settingsCloseButton {
                padding: 12px 20px;
                font-size: 18px;
                margin: 5px;
            }
        }

        /* Debug overlay for hitboxes */
        #debugOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
        }
    </style>
</head>
<body>
    <!-- HTML Struktur -->
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="debugOverlay"></div>
        <div id="loadingOverlay">
            <img id="loadingSpinner" src="https://raw.githubusercontent.com/ErSieCode/1Rad/main/load.png" alt="Loading..."
                 onerror="this.onerror=null; console.error('Loading image failed to load'); this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iNDAiIGN5PSI0MCIgcj0iMzYiIHN0cm9rZT0iIzRDQUY1MCIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSJub25lIiBzdHJva2UtZGFzaGFycmF5PSIxNTAgMTgwIiAvPjwvc3ZnPg==';"
                 onload="console.log('Loading spinner image loaded successfully!');">
        </div>
        <div id="gameControls">
            <button id="startButton">START</button>
            <button id="settingsButton">SETTINGS</button>
            <div id="characterSelect">
                <img id="fuchs" src="https://raw.githubusercontent.com/ErSieCode/1Rad/main/Fuchs_einrad.png" alt="Fuchs">
                <img id="waschbaer" src="https://raw.githubusercontent.com/ErSieCode/1Rad/main/waschbaer_einrad.png" alt="Waschbär">
            </div>
        </div>
        <div id="gameInfo">
            <div>SCORE: <span id="score">0</span></div>
            <div>HI: <span id="highScore">0</span></div>
        </div>
        <div id="livesDisplay"></div>
        <button id="quitButton">✕</button>
        <button id="backButton">⬅</button>
        <div id="pauseOverlay">
            <div><h2>GAME PAUSED</h2><p>Press 'P' or ESC or Tap to resume</p></div>
        </div>
        <button id="duckButton">↓</button>
        <div id="gameOver">
            <h2>GAME OVER</h2>
            <div>Final Score: <span id="finalScore">0</span></div>
            <button id="restartButton">RESTART</button>
        </div>

        <!-- Settings Panel - UPDATED WITH DIFFICULTY LEVELS -->
        <div id="settingsPanel">
            <div class="settings-header">
                <button id="settingsBackButton">⬅</button>
                <h2>Game Settings</h2>
            </div>

            <!-- Game Speed Setting -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Game Speed</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="speedEasy" name="speedSetting" value="easy">
                        <label for="speedEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="speedNormal" name="speedSetting" value="normal" checked>
                        <label for="speedNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="speedHard" name="speedSetting" value="hard">
                        <label for="speedHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="speedVeryHard" name="speedSetting" value="veryHard">
                        <label for="speedVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Jump Height Setting -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Jump Height</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="jumpEasy" name="jumpSetting" value="easy">
                        <label for="jumpEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="jumpNormal" name="jumpSetting" value="normal" checked>
                        <label for="jumpNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="jumpHard" name="jumpSetting" value="hard">
                        <label for="jumpHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="jumpVeryHard" name="jumpSetting" value="veryHard">
                        <label for="jumpVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Spawn Rate Setting -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Spawn Rate</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="spawnEasy" name="spawnSetting" value="easy">
                        <label for="spawnEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="spawnNormal" name="spawnSetting" value="normal" checked>
                        <label for="spawnNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="spawnHard" name="spawnSetting" value="hard">
                        <label for="spawnHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="spawnVeryHard" name="spawnSetting" value="veryHard">
                        <label for="spawnVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Flying Objects Height Setting -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Flying Objects Height</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="flyingHeightEasy" name="flyingHeightSetting" value="easy">
                        <label for="flyingHeightEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="flyingHeightNormal" name="flyingHeightSetting" value="normal" checked>
                        <label for="flyingHeightNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="flyingHeightHard" name="flyingHeightSetting" value="hard">
                        <label for="flyingHeightHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="flyingHeightVeryHard" name="flyingHeightSetting" value="veryHard">
                        <label for="flyingHeightVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Hitbox Size Setting -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Hitbox Size</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="hitboxSizeEasy" name="hitboxSizeSetting" value="easy">
                        <label for="hitboxSizeEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="hitboxSizeNormal" name="hitboxSizeSetting" value="normal" checked>
                        <label for="hitboxSizeNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="hitboxSizeHard" name="hitboxSizeSetting" value="hard">
                        <label for="hitboxSizeHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="hitboxSizeVeryHard" name="hitboxSizeSetting" value="veryHard">
                        <label for="hitboxSizeVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Hitbox visualization toggle -->
            <div class="checkbox-container">
                <input type="checkbox" id="showHitboxSetting">
                <label for="showHitboxSetting">Show Hitboxes</label>
            </div>

            <div class="settings-buttons">
                <button id="settingsResetButton">Reset Defaults</button>
                <button id="settingsCloseButton">Close</button>
            </div>
        </div>
    </div>
    <div id="instructions">Press SPACE/UP/Tap to jump/double jump | DOWN/Button to duck | P/ESC to pause</div>

    <script>
        'use strict';
        console.log("--- Script Start ---");

        // --- Debug Utility ---
        function logImageStatus(name, img) {
            img.onload = () => console.log(`✓ ${name} loaded.`);
            img.onerror = (e) => console.error(`✗ ${name} FAILED loading from ${img.src}`, e);
        }

        // Initialize loading spinner first
        document.addEventListener('DOMContentLoaded', function() {
            const loadingSpinner = document.getElementById('loadingSpinner');
            const loadingOverlay = document.getElementById('loadingOverlay');

            // Make sure the loading overlay is visible
            if (loadingOverlay) {
                loadingOverlay.style.display = 'flex';
            }

            // Check if the image is loading correctly
            if (loadingSpinner) {
                if (!loadingSpinner.complete) {
                    console.log("Loading spinner image is still loading...");
                    loadingSpinner.onload = function() {
                        console.log("Loading spinner image has loaded successfully!");
                    };
                } else {
                    console.log("Loading spinner image was already loaded!");
                }
            }
        });

        // --- Asset Loading with progress tracking ---
        console.log("Assets: Defining...");
        // Track loading progress
        let totalAssets = 12; // Total number of images to load
        let loadedAssets = 0;
        const loadingOverlay = document.getElementById('loadingOverlay');

        function checkAllAssetsLoaded() {
            loadedAssets++;
            console.log(`Loaded ${loadedAssets}/${totalAssets} assets`);
            if (loadedAssets >= totalAssets) {
                // Hide loading overlay when all assets are loaded
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'none';
                }
                console.log("All assets loaded successfully!");
            }
        }

        function enhancedLogImageStatus(name, img) {
            img.onload = () => {
                console.log(`✓ ${name} loaded.`);
                checkAllAssetsLoaded();
            };
            img.onerror = (e) => {
                console.error(`✗ ${name} FAILED loading from ${img.src}`, e);
                checkAllAssetsLoaded(); // Count errors too, to avoid spinner getting stuck
            };
        }

        const fuchsImg = new Image(); enhancedLogImageStatus('Fuchs', fuchsImg);
        const waschbaerImg = new Image(); enhancedLogImageStatus('Waschbär', waschbaerImg);
        const duckButtonImg = new Image(); enhancedLogImageStatus('Duck Icon', duckButtonImg);
        // Backgrounds
        const dayBgImg = new Image(); enhancedLogImageStatus('BG Day', dayBgImg);
        const nightBgImg = new Image(); enhancedLogImageStatus('BG Night', nightBgImg);
        const gameOverBannerImg = new Image(); enhancedLogImageStatus('Game Over Banner', gameOverBannerImg);
        // Obstacles - Ground
        const pallet4Img = new Image(); enhancedLogImageStatus('Obstacle Pallet 4', pallet4Img);
        const pallet6Img = new Image(); enhancedLogImageStatus('Obstacle Pallet 6', pallet6Img);
        const logImg = new Image(); enhancedLogImageStatus('Obstacle Log', logImg);
        const stumpImg = new Image(); enhancedLogImageStatus('Obstacle Stump', stumpImg);
        // Obstacles - Sky
        const owlImg = new Image(); enhancedLogImageStatus('Obstacle Owl', owlImg);
        const flyingUniImg = new Image(); enhancedLogImageStatus('Obstacle Flying Uni', flyingUniImg);

        // Set sources after setting up handlers
        fuchsImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Fuchs_einrad.png';
        waschbaerImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/waschbaer_einrad.png';
        duckButtonImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Muni_logo.png';
        dayBgImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Tag_BG.png';
        nightBgImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Nacht_BG.png';
        gameOverBannerImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Banner.png';
        pallet4Img.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Paletten_4_IMG.png';
        pallet6Img.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Paletten_6_IMG.png';
        logImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/baum_liegend.png';
        stumpImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/baumstumpf.png';
        owlImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Eule_v1_L.png';
        flyingUniImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Flug_Einrad_grun.png';

        console.log("Assets: Defined.");

        // --- DOM Elements ---
        console.log("DOM: Getting elements...");
        let canvas, ctx, scoreElement, highScoreElement, finalScoreElement, gameOverElement, restartButton, startButton,
            fuchsSelect, waschbaerSelect, characterSelectContainer, pauseOverlay, quitButton, livesDisplay, gameContainer,
            duckButton, backButton, settingsButton, settingsPanel, settingsCloseButton, settingsResetButton, debugOverlay,
            showHitboxSetting, settingsBackButton;

        // Frühe Initialisierung der Variablen
        canvas = document.getElementById('gameCanvas');
        ctx = canvas ? canvas.getContext('2d') : null;
        scoreElement = document.getElementById('score');
        highScoreElement = document.getElementById('highScore');
        finalScoreElement = document.getElementById('finalScore');
        gameOverElement = document.getElementById('gameOver');
        restartButton = document.getElementById('restartButton');
        startButton = document.getElementById('startButton');
        fuchsSelect = document.getElementById('fuchs');
        waschbaerSelect = document.getElementById('waschbaer');
        characterSelectContainer = document.getElementById('characterSelect');
        pauseOverlay = document.getElementById('pauseOverlay');
        quitButton = document.getElementById('quitButton');
        livesDisplay = document.getElementById('livesDisplay');
        gameContainer = document.getElementById('gameContainer');
        duckButton = document.getElementById('duckButton');
        backButton = document.getElementById('backButton');
        settingsButton = document.getElementById('settingsButton');
        settingsPanel = document.getElementById('settingsPanel');
        settingsCloseButton = document.getElementById('settingsCloseButton');
        settingsResetButton = document.getElementById('settingsResetButton');
        debugOverlay = document.getElementById('debugOverlay');
        showHitboxSetting = document.getElementById('showHitboxSetting');
        settingsBackButton = document.getElementById('settingsBackButton');

        if (!canvas || !ctx) {
             console.error("CRITICAL: Canvas or Context not available immediately!");
             document.addEventListener('DOMContentLoaded', () => { alert("Fehler: Spiel-Canvas konnte nicht initialisiert werden!"); });
        } else {
             console.log("DOM: Elements retrieved.");
             window.addEventListener('load', init); // Add listener only if canvas is okay
        }


        // --- Game State ---
        const GameState = {
            INIT: 'INIT',
            READY: 'READY',
            PLAYING: 'PLAYING',
            PAUSED: 'PAUSED',
            GAMEOVER: 'GAMEOVER',
            SETTINGS: 'SETTINGS'
        };

        let currentState = GameState.INIT;
        let character = 'fuchs';
        let score = 0;
        let highScore = 0;
        let lives = 3;
        const maxLives = 3;
        let speed = 0;
        let speedIncrement = 0.0005;
        let backgroundX = 0;
        let isDucking = false;
        let isNight = false;
        let isInvulnerable = false;
        let invulnerabilityTimer = null;
        const invulnerabilityDuration = 2000;

        // --- Physics & Scaling ---
        let scaleFactor = 1;
        const baseWidth = 800;
        let baseSpeed = 250;
        let baseGravity = 1200;
        let baseJumpStrength = -550;
        let groundHeight = 0;
        let player = {};
        let obstacles = [];
        let clouds = [];
        let obstacleTimer = 0;
        let cloudTimer = 0;
        let minObstacleTime = 1.4;
        let maxObstacleTime = 2.8;
        const initialObstacleCooldown = 3.0;
        const highStumpMinTime = 45;

        // Variable to track separate spawn timers for ground and sky obstacles
        let groundObstacleTimer = 0;
        let skyObstacleTimer = 0;

        // Additional offset timers for more randomized spawning
        let groundObstacleTimerOffset = 0;
        let skyObstacleTimerOffset = 0;

        // Skalierungsfaktor für alle Spielelemente - Charakter etwas schmaler machen
        const globalSizeFactor = 1.25; // 25% größer
        const playerWidthRatio = 0.9; // Character width is 90% of normal to make it slightly slimmer

        // Difficulty level constants for ground and air obstacles
        const GroundObstacleMode = {
            EASY: { timer: 3.5, independent: false },
            NORMAL: { timer: 2.5, independent: false },
            HARD: { timer: 1.8, independent: true },
            VERY_HARD: { timer: 1.0, independent: true }
        };

        const SkyObstacleMode = {
            EASY: { timer: 3.5, independent: false },
            NORMAL: { timer: 2.5, independent: false },
            HARD: { timer: 1.8, independent: true },
            VERY_HARD: { timer: 1.0, independent: true }
        };

        // --- Game Settings with difficulty levels ---
        let gameSettings = {
            // Changed from multipliers to difficulty levels
            speedLevel: 'normal',           // easy, normal, hard, veryHard
            jumpHeightLevel: 'normal',      // easy, normal, hard, veryHard
            spawnRateLevel: 'normal',       // easy, normal, hard, veryHard
            flyingHeightLevel: 'normal',    // easy, normal, hard, veryHard
            hitboxSizeLevel: 'normal',      // easy, normal, hard, veryHard
            showHitboxes: false             // Toggle for hitbox visualization
        };

        // Difficulty level values
        const difficultyValues = {
            speed: {
                easy: 0.7,      // Very slow
                normal: 1.0,    // Normal speed
                hard: 1.3,      // Fast
                veryHard: 1.6   // Very fast
            },
            jumpHeight: {
                easy: 1.3,      // Very high jump
                normal: 1.0,    // Normal jump
                hard: 0.8,      // Low jump
                veryHard: 0.7   // Very low jump (just enough to clear objects)
            },
            gravity: {
                easy: 0.8,      // Less gravity for easier control
                normal: 1.0,    // Normal gravity
                hard: 1.2,      // More gravity
                veryHard: 1.3   // Very strong gravity
            },
            flyingHeight: {
                easy: 0.3,      // Flying objects very high (easier)
                normal: 0.5,    // Flying objects normal height
                hard: 0.7,      // Flying objects low (harder)
                veryHard: 0.95  // Flying objects extremely low (ducking required)
            },
            hitboxSize: {
                easy: 0.7,      // Smaller hitbox (more forgiving)
                normal: 0.75,   // Normal hitbox
                hard: 0.8,      // Larger hitbox
                veryHard: 0.85  // Very large hitbox
            }
        };

        // --- Settings Control Functions ---
        function initializeSettings() {
            // Find all radio buttons for each setting type
            const speedRadios = document.querySelectorAll('input[name="speedSetting"]');
            const jumpRadios = document.querySelectorAll('input[name="jumpSetting"]');
            const spawnRadios = document.querySelectorAll('input[name="spawnSetting"]');
            const flyingHeightRadios = document.querySelectorAll('input[name="flyingHeightSetting"]');
            const hitboxSizeRadios = document.querySelectorAll('input[name="hitboxSizeSetting"]');

            // Set initial selections based on gameSettings
            setRadioByValue(speedRadios, gameSettings.speedLevel);
            setRadioByValue(jumpRadios, gameSettings.jumpHeightLevel);
            setRadioByValue(spawnRadios, gameSettings.spawnRateLevel);
            setRadioByValue(flyingHeightRadios, gameSettings.flyingHeightLevel);
            setRadioByValue(hitboxSizeRadios, gameSettings.hitboxSizeLevel);

            // Initialize hitbox visibility toggle
            if (showHitboxSetting) {
                showHitboxSetting.checked = gameSettings.showHitboxes;
                showHitboxSetting.addEventListener('change', (e) => {
                    gameSettings.showHitboxes = e.target.checked;

                    // Clear debug overlay if hitboxes are disabled
                    if (!gameSettings.showHitboxes && debugOverlay) {
                        debugOverlay.innerHTML = '';
                    }
                });
            }

            // Add event listeners to all radio buttons
            addRadioListeners(speedRadios, 'speedLevel');
            addRadioListeners(jumpRadios, 'jumpHeightLevel');
            addRadioListeners(spawnRadios, 'spawnRateLevel');
            addRadioListeners(flyingHeightRadios, 'flyingHeightLevel');
            addRadioListeners(hitboxSizeRadios, 'hitboxSizeLevel');
        }

        // Helper function to set a radio button by value
        function setRadioByValue(radios, value) {
            for (const radio of radios) {
                if (radio.value === value) {
                    radio.checked = true;
                    break;
                }
            }
        }

        // Helper function to add listeners to radio buttons
        function addRadioListeners(radios, settingName) {
            for (const radio of radios) {
                radio.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        gameSettings[settingName] = e.target.value;

                        // Apply settings if they changed during setup
                        if (currentState === GameState.READY) {
                            applyGameSettings();
                        }
                    }
                });
            }
        }

        function resetGameSettings() {
            gameSettings = {
                speedLevel: 'normal',
                jumpHeightLevel: 'normal',
                spawnRateLevel: 'normal',
                flyingHeightLevel: 'normal',
                hitboxSizeLevel: 'normal',
                showHitboxes: false
            };

            // Update UI controls
            const speedRadios = document.querySelectorAll('input[name="speedSetting"]');
            const jumpRadios = document.querySelectorAll('input[name="jumpSetting"]');
            const spawnRadios = document.querySelectorAll('input[name="spawnSetting"]');
            const flyingHeightRadios = document.querySelectorAll('input[name="flyingHeightSetting"]');
            const hitboxSizeRadios = document.querySelectorAll('input[name="hitboxSizeSetting"]');

            setRadioByValue(speedRadios, 'normal');
            setRadioByValue(jumpRadios, 'normal');
            setRadioByValue(spawnRadios, 'normal');
            setRadioByValue(flyingHeightRadios, 'normal');
            setRadioByValue(hitboxSizeRadios, 'normal');

            // Update hitbox checkbox
            if (showHitboxSetting) {
                showHitboxSetting.checked = false;
            }

            // Clear debug overlay
            if (debugOverlay) {
                debugOverlay.innerHTML = '';
            }

            // Apply settings
            if (currentState === GameState.READY) {
                applyGameSettings();
            }
        }

        function applyGameSettings() {
            // Get the appropriate multipliers based on difficulty levels
            const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];

            // Apply speed setting
            speed = baseSpeed * scaleFactor * speedMultiplier;

            // Other settings will be applied in their respective functions when needed
            // For example, jump height and gravity are applied in resetGame or when jumping
        }

        function toggleSettingsPanel() {
            if (currentState === GameState.SETTINGS) {
                // Close settings panel
                if (settingsPanel) settingsPanel.style.display = 'none';
                currentState = GameState.READY;
                updateUI();
            } else if (currentState === GameState.READY || currentState === GameState.GAMEOVER) {
                // Open settings panel
                if (settingsPanel) settingsPanel.style.display = 'flex';
                currentState = GameState.SETTINGS;
                updateUI();
            }
        }

        // --- Obstacle Definitions ---
        console.log("Defining obstacle data...");
        const ObstacleType = { PALLET_4: 'PALLET_4', PALLET_6: 'PALLET_6', LOG: 'LOG', STUMP: 'STUMP', STUMP_HIGH: 'STUMP_HIGH', OWL: 'OWL', FLYING_UNI: 'FLYING_UNI' };
        const obstacleData = { // Sorgfältig geprüft, korrekte Variablennamen verwendet
            [ObstacleType.PALLET_4]:   { img: pallet4Img,   baseWidth: 90 * globalSizeFactor,  baseHeight: 40 * globalSizeFactor, category: 'ground', level: 'LOW', hitboxOffsetX: 35 * globalSizeFactor },
            [ObstacleType.PALLET_6]:   { img: pallet6Img,   baseWidth: 90 * globalSizeFactor,  baseHeight: 60 * globalSizeFactor, category: 'ground', level: 'MED', hitboxOffsetX: 35 * globalSizeFactor },
            [ObstacleType.LOG]:        { img: logImg,       baseWidth: 100 * globalSizeFactor, baseHeight: 35 * globalSizeFactor, category: 'ground', level: 'LOW', hitboxOffsetX: 45 * globalSizeFactor },
            [ObstacleType.STUMP]:      { img: stumpImg,     baseWidth: 45 * globalSizeFactor,  baseHeight: 55 * globalSizeFactor, category: 'ground', level: 'MED', hitboxOffsetX: 10 * globalSizeFactor },
            [ObstacleType.STUMP_HIGH]: { img: stumpImg,     baseWidth: 45 * globalSizeFactor,  baseHeight: 55 * globalSizeFactor, category: 'ground', level: 'HIGH', isHigh: true, hitboxOffsetX: 10 * globalSizeFactor },
            [ObstacleType.OWL]:        { img: owlImg,       baseWidth: 60 * globalSizeFactor,  baseHeight: 50 * globalSizeFactor, category: 'sky', hitboxOffsetX: 10 * globalSizeFactor, hitboxOffsetY: 10 * globalSizeFactor },
            [ObstacleType.FLYING_UNI]: { img: flyingUniImg, baseWidth: 70 * globalSizeFactor,  baseHeight: 65 * globalSizeFactor, category: 'sky', hitboxOffsetX: 15 * globalSizeFactor, hitboxOffsetY: 15 * globalSizeFactor }
        }; // Syntax OK.
        const groundObstacleTypes = [ObstacleType.PALLET_4, ObstacleType.PALLET_6, ObstacleType.LOG, ObstacleType.STUMP];
        const skyObstacleTypes = [ObstacleType.OWL, ObstacleType.FLYING_UNI];
        console.log("Obstacle data defined.");

        // --- Game Loop ---
        let lastTime = 0; let animationFrameId = null; let gameTime = 0;

        // --- Initialization ---
        function init() {
            console.log(">>> init() started");
            if (!canvas || !ctx) { console.error("Init aborted: Canvas/Context missing."); return; }
            try {
                loadHighScore();
                initializeSettings();
                setupDOM();
                resizeCanvas();
                createHearts();
                resetGame();
                addEventListeners();
                currentState = GameState.READY;
                updateUI();
                lastTime = performance.now();
                if (!animationFrameId) animationFrameId = requestAnimationFrame(gameLoop);
                console.log("init: Animation loop started");
            } catch (error) {
                console.error("##### CRITICAL ERROR IN INIT #####", error);
                alert("Game Initialization Failed!");
            }
            console.log(">>> init() finished");
        }

        // --- Setup DOM ---
        function setupDOM() {
            if(highScoreElement) highScoreElement.textContent = highScore;
            if (duckButton) {
                 if (duckButtonImg.complete && duckButtonImg.naturalWidth > 0) { duckButton.innerHTML = ''; duckButton.appendChild(duckButtonImg.cloneNode()); }
                 else { duckButton.textContent = '↓'; if (!duckButtonImg.hasAttribute('data-onload-set')) { duckButtonImg.onload = () => { const btn = document.getElementById('duckButton'); if (btn) { btn.innerHTML = ''; btn.appendChild(duckButtonImg.cloneNode()); }}; duckButtonImg.setAttribute('data-onload-set', 'true'); } }
            }
            if(fuchsSelect) fuchsSelect.classList.toggle('selected', character === 'fuchs');
            if(waschbaerSelect) waschbaerSelect.classList.toggle('selected', character === 'waschbaer');
        }

        // --- Resize Canvas ---
        function resizeCanvas() {
            if (!gameContainer || !canvas) { return; }
            const cw = gameContainer.clientWidth; const ch = gameContainer.clientHeight; if (cw === 0 || ch === 0) return;
            canvas.width = cw; canvas.height = ch; scaleFactor = (cw / baseWidth) * globalSizeFactor; groundHeight = 30 * scaleFactor;

            if (player && player.width) {
                const ps = 70; // Base player size
                const ss = ps * scaleFactor; // Scaled size

                // Make player width slimmer while keeping the height the same
                player.width = ss * playerWidthRatio;  // Slimmer width (90% of normal)
                player.baseHeight = ss;  // Normal height
                player.duckHeight = (ps/2) * scaleFactor;
                player.height = isDucking ? player.duckHeight : player.baseHeight;

                player.x = 50 * scaleFactor;
                player.y = ch - groundHeight - player.height;

                // Apply gravity settings based on difficulty
                const gravityMultiplier = difficultyValues.gravity[gameSettings.jumpHeightLevel];
                player.gravity = baseGravity * scaleFactor * gravityMultiplier;

                // Apply jump height settings based on difficulty
                const jumpMultiplier = difficultyValues.jumpHeight[gameSettings.jumpHeightLevel];
                player.jumpStrength = baseJumpStrength * scaleFactor * jumpMultiplier;
            }
        }

        // --- High Score, Hearts ---
        function loadHighScore() { try{const s=localStorage.getItem('pixelRunnerHighScore');highScore=s?parseInt(s):0;}catch(e){highScore=0;} }
        function saveHighScore() { const fs=Math.floor(score/10);if(fs>highScore){highScore=fs;try{localStorage.setItem('pixelRunnerHighScore',highScore);if(highScoreElement)highScoreElement.textContent=highScore;}catch(e){}} }
        function createHearts() { if(!livesDisplay) return; livesDisplay.innerHTML=''; for (let i = 0; i < maxLives; i++) { const h = document.createElement('span'); h.classList.add('heart'); h.innerHTML = '♥'; livesDisplay.appendChild(h); } }
        function updateLivesDisplay() { if(!livesDisplay) return; livesDisplay.querySelectorAll('.heart').forEach((h, i) => h.classList.toggle('hidden', i >= lives)); }

        // --- resetGame - Updated for settings and slimmer character
        function resetGame() {
            console.log("resetGame: Running...");
            if (!canvas || !ctx) { console.error("resetGame: Canvas/Context missing."); return; }
            score=0;
            gameTime=0;

            // Apply speed setting based on difficulty level
            const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];
            speed = baseSpeed * scaleFactor * speedMultiplier;

            backgroundX=0;
            lives=maxLives;
            isDucking=false;
            isNight=false;
            isInvulnerable=false;
            clearTimeout(invulnerabilityTimer);
            invulnerabilityTimer=null;
            obstacles=[];
            clouds=[];

            // Initialize spawn timers based on difficulty with randomly staggered starts
            obstacleTimer = initialObstacleCooldown;

            // Primary timers with random starting values
            groundObstacleTimer = initialObstacleCooldown * (0.8 + Math.random() * 0.4); // 80-120% of base time
            skyObstacleTimer = initialObstacleCooldown * (0.7 + Math.random() * 0.5);   // 70-120% of base time

            // Secondary offset timers - completely random offsets
            groundObstacleTimerOffset = initialObstacleCooldown * (0.3 + Math.random() * 0.5); // 30-80% of base time
            skyObstacleTimerOffset = initialObstacleCooldown * (0.2 + Math.random() * 0.6);    // 20-80% of base time

            cloudTimer = (2 + Math.random() * 3);

            const ps = 70 * globalSizeFactor; // Base player size
            const ss = ps * scaleFactor; // Scaled size
            const ch = canvas.height || 0;
            if (ch <= 0) return;

            // Apply gravity and jump settings based on difficulty
            const gravityMultiplier = difficultyValues.gravity[gameSettings.jumpHeightLevel];
            const jumpMultiplier = difficultyValues.jumpHeight[gameSettings.jumpHeightLevel];

            player = {
                x: 50 * scaleFactor,
                y: ch - groundHeight - ss,
                width: ss * playerWidthRatio, // Slimmer width (90% of normal)
                height: ss,
                baseHeight: ss,
                duckHeight: (ps/2) * scaleFactor,
                vy: 0,
                // Apply gravity and jump settings
                gravity: baseGravity * scaleFactor * gravityMultiplier,
                jumpStrength: baseJumpStrength * scaleFactor * jumpMultiplier,
                jumping: false,
                canDoubleJump: false,
                hasDoubleJumped: false,
                image: (character === 'fuchs' ? fuchsImg : waschbaerImg)
            };

            if(!(player.image && player.image.complete && player.image.naturalWidth>0)) { /* Warnung möglich */ }
            if(document.body) document.body.style.backgroundColor = '#e0e0e0'; // Start mit hellem Body-BG

            // Clear hitbox debug overlay
            if (debugOverlay) {
                debugOverlay.innerHTML = '';
            }

            console.log("resetGame: Finished.");
        }

        // --- Game Logic ---
        function startGame() {
            if(currentState===GameState.PLAYING) return;
            console.log("Starting Game...");
            resetGame();
            currentState=GameState.PLAYING;
            updateUI();
            lastTime=performance.now();
            if(!animationFrameId) animationFrameId=requestAnimationFrame(gameLoop);
        }

        // --- FIXED loseLife Function ---
        function loseLife() {
            // Debug log to troubleshoot
            console.log("loseLife called! Current lives:", lives, "Invulnerable:", isInvulnerable, "State:", currentState);

            if(isInvulnerable || currentState !== GameState.PLAYING) {
                console.log("No life lost - player is invulnerable or not playing");
                return;
            }

            lives--;
            console.log("Life lost! Remaining lives:", lives);

            updateLivesDisplay();
            makePlayerInvulnerable();

            if(gameContainer) {
                gameContainer.style.borderColor='#ff0000';
                // Flash the screen red for better feedback
                const flashEffect = document.createElement('div');
                flashEffect.style.position = 'absolute';
                flashEffect.style.top = '0';
                flashEffect.style.left = '0';
                flashEffect.style.width = '100%';
                flashEffect.style.height = '100%';
                flashEffect.style.backgroundColor = 'rgba(255,0,0,0.3)';
                flashEffect.style.pointerEvents = 'none';
                flashEffect.style.zIndex = '20';
                flashEffect.style.animation = 'fadeOut 0.5s forwards';

                // Add fadeOut animation if it doesn't exist
                if (!document.getElementById('flashAnimation')) {
                    const style = document.createElement('style');
                    style.id = 'flashAnimation';
                    style.textContent = '@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }';
                    document.head.appendChild(style);
                }

                gameContainer.appendChild(flashEffect);

                setTimeout(() => {
                    if(gameContainer) {
                        gameContainer.style.borderColor = '#333';
                        if (flashEffect.parentNode) {
                            flashEffect.parentNode.removeChild(flashEffect);
                        }
                    }
                }, 200);
            }

            if(lives <= 0) {
                console.log("Game over triggered!");
                gameOver();
            }
        }

        function gameOver() {
            currentState=GameState.GAMEOVER;
            saveHighScore();
            if(finalScoreElement) finalScoreElement.textContent=Math.floor(score/10);
            updateUI();
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId=null;
        }

        // --- Improved makePlayerInvulnerable function ---
        function makePlayerInvulnerable() {
            console.log("Making player invulnerable");
            isInvulnerable = true;
            clearTimeout(invulnerabilityTimer);

            // Visual indicator for invulnerability (player will blink)
            if (player) {
                console.log("Invulnerability visual effects applied");
            }

            invulnerabilityTimer = setTimeout(() => {
                isInvulnerable = false;
                invulnerabilityTimer = null;
                console.log("Invulnerability ended");
            }, invulnerabilityDuration);
        }

        function togglePause() {
            if(currentState===GameState.PLAYING){
                currentState=GameState.PAUSED;
                if(animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId=null;
            } else if(currentState===GameState.PAUSED){
                currentState=GameState.PLAYING;
                lastTime=performance.now();
                animationFrameId=requestAnimationFrame(gameLoop);
            }
            updateUI();
        }

        function quitGame() {
            if(currentState===GameState.PLAYING||currentState===GameState.PAUSED) saveHighScore();
            alert("Game ended.");
            try{window.close();}catch(e){}
            currentState=GameState.GAMEOVER;
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId=null;
            updateUI();
        }

        // Back to Menu Function
        function backToMenu() {
            if (currentState === GameState.PLAYING || currentState === GameState.PAUSED) {
                saveHighScore();
                currentState = GameState.READY;
                resetGame();
                updateUI();
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        function jump() {
            if(currentState!==GameState.PLAYING||isDucking||!player||typeof player.vy==='undefined') return;
            if(!player.jumping){
                player.vy = player.jumpStrength;
                player.jumping=true;
                player.canDoubleJump=true;
                player.hasDoubleJumped=false;
            } else if(player.canDoubleJump&&!player.hasDoubleJumped){
                player.vy = player.jumpStrength * 0.8;
                player.canDoubleJump=false;
                player.hasDoubleJumped=true;
                createDoubleJumpEffect();
            }
        }

        function setDucking(sd) {
            if(currentState!==GameState.PLAYING||player.jumping||!player||typeof player.height==='undefined') return;
            if(sd&&!isDucking){
                isDucking=true;
                player.height=player.duckHeight;
                player.y=canvas.height-groundHeight-player.height;
            } else if(!sd&&isDucking){
                isDucking=false;
                player.height=player.baseHeight;
                player.y=canvas.height-groundHeight-player.height;
                checkCollision();
            }
        }

        function createDoubleJumpEffect() {
            try{
                if(!player||!player.width) return;
                const s=player.width*1.2;
                const e=document.createElement('div');
                e.className='doubleJumpEffect';
                const cr=gameContainer.getBoundingClientRect();
                const cvr=canvas.getBoundingClientRect();
                const ox=cvr.left-cr.left;
                const oy=cvr.top-cr.top;
                e.style.width=`${s}px`;
                e.style.height=`${s}px`;
                e.style.left=`${ox+player.x+player.width/2-s/2}px`;
                e.style.top=`${oy+player.y+player.height/2-s/2}px`;
                if(gameContainer) gameContainer.appendChild(e);
                setTimeout(()=>{if(e.parentNode)e.remove();},400);
            }catch(err){}
        }

        // --- createObstacle - Updated for difficulty settings
        function createObstacle(category = null) {
            try {
                let chosenType = null;
                let availableGroundTypes = [...groundObstacleTypes]; // Kopie der Basis-Bodentypen

                // Hohen Baumstumpf hinzufügen, wenn Zeit abgelaufen
                if (gameTime > highStumpMinTime) {
                    availableGroundTypes.push(ObstacleType.STUMP_HIGH);
                }

                // If category is not specified, decide randomly (this is for backward compatibility)
                if (category === null) {
                    category = Math.random() < 0.70 ? 'ground' : 'sky';
                }

                if (category === 'ground') {
                    const randIdx = Math.floor(Math.random() * availableGroundTypes.length);
                    chosenType = availableGroundTypes[randIdx];
                } else {
                    const randIdx = Math.floor(Math.random() * skyObstacleTypes.length);
                    chosenType = skyObstacleTypes[randIdx];
                }

                const data = obstacleData[chosenType];
                if (!data) { console.error("Obstacle data missing for type:", chosenType); return; } // Sicherheitscheck

                const scaledWidth = data.baseWidth * scaleFactor;
                const scaledHeight = data.baseHeight * scaleFactor;
                let yPos;

                if (data.category === 'ground') {
                    yPos = canvas.height - groundHeight - scaledHeight;
                    // Optional: Leichte Höhenanpassung für spezielle Typen hier möglich
                    if (data.isHigh) { yPos -= 20 * scaleFactor; } // Höhenjustierung für STUMP_HIGH
                } else { // Sky obstacle positioning
                    // Base values
                    const minTopMargin = 120 * scaleFactor; // Minimum distance from top
                    const playerClearance = player.baseHeight ? player.baseHeight * 1.3 : 100 * scaleFactor; // Minimum clearance above player
                    const safeSkyBottom = canvas.height - groundHeight - playerClearance; // Bottom limit for sky objects
                    const duckHeight = player.duckHeight || (player.baseHeight * 0.5);
                    const duckClearance = duckHeight * 1.3; // Space needed for ducking

                    // Calculate the total available height space
                    const totalHeight = safeSkyBottom - minTopMargin;

                    // Apply the difficulty setting for flying objects from the flying height setting
                    // Harder = lower flying objects that are harder to jump over
                    const flyingHeightValue = difficultyValues.flyingHeight[gameSettings.flyingHeightLevel];

                    // If very hard level, spawn at ducking height
                    if (gameSettings.flyingHeightLevel === 'veryHard') {
                        // For the hardest level, spawn objects at a height where ducking is necessary
                        // Calculate a position that requires ducking (near player head height when standing)
                        const duckRequiredY = canvas.height - groundHeight - player.baseHeight + (player.baseHeight - duckHeight) / 2;
                        yPos = duckRequiredY - (scaledHeight / 2); // Center the object at duck-required height
                    } else {
                        // Normal height calculation for other difficulties
                        yPos = minTopMargin + (totalHeight * flyingHeightValue);
                    }

                    // Add some randomness to prevent predictable patterns
                    // Less randomness for very hard mode to ensure ducking is required
                    const randomRange = gameSettings.flyingHeightLevel === 'veryHard'
                        ? totalHeight * 0.1  // 10% randomness for very hard
                        : totalHeight * 0.3; // 30% randomness for other levels

                    yPos += (Math.random() - 0.5) * randomRange;

                    // Ensure we stay within safe bounds
                    yPos = Math.max(minTopMargin, Math.min(safeSkyBottom - scaledHeight, yPos));
                }

                // Create the obstacle with all necessary information
                console.log(`Creating ${chosenType} obstacle at position ${yPos}`);
                obstacles.push({
                    x: canvas.width, // Start rechts außerhalb
                    y: yPos,
                    width: scaledWidth,
                    height: scaledHeight,
                    type: chosenType,
                    image: data.img, // Referenz auf das Image-Objekt speichern
                    category: data.category // Kategorie speichern für evtl. spätere Logik
                });
            } catch(err) {
                 console.error("Error in createObstacle:", err);
            }
        }

        // --- createCloud - Mit angepasster Y-Position
        function createCloud() {
            const bw = 60 * globalSizeFactor;
            const bh = 30 * globalSizeFactor;
            const sw = bw * scaleFactor;
            const sh = bh * scaleFactor;
            clouds.push({
                x: canvas.width,
                // --- HIER DIE ÄNDERUNG FÜR WOLKEN ---
                y: (100 + Math.random() * 100) * scaleFactor, // << GEÄNDERT: Startet tiefer und hat größeren Bereich nach unten
                // --- ENDE ÄNDERUNG ---
                width: sw,
                height: sh,
                speed: (baseSpeed * (0.2 + Math.random() * 0.3)) * scaleFactor * difficultyValues.speed[gameSettings.speedLevel]
            });
        }

        // --- Update ---
        function update(dt) {
            if(currentState!==GameState.PLAYING) return;
            gameTime+=dt;
            updatePlayer(dt);
            updateObstacles(dt);
            updateClouds(dt);
            updateScore(dt);
            updateBackground(dt);
            updateDifficulty(dt);

            // We now call checkCollision in the updateObstacles function
            // instead of here, to ensure it's called after obstacle positions update
        }

        function updatePlayer(dt) {
            if(!player||typeof player.vy==='undefined') return;
            player.vy += player.gravity * dt;
            player.y += player.vy * dt;
            const gl = canvas.height - groundHeight - player.height;
            if(player.y >= gl){
                player.y = gl;
                player.vy = 0;
                if(player.jumping){
                    player.jumping = false;
                    player.canDoubleJump = false;
                    player.hasDoubleJumped = false;
                    setDucking(isDucking);
                }
            }
        }

        // --- updateObstacles - Super randomized version with properly placed collision detection
        function updateObstacles(dt) {
            // First update existing obstacles position and remove any that are off-screen
            for(let i=obstacles.length-1; i>=0; i--){
                // Apply speed based on difficulty
                obstacles[i].x -= speed * dt;
                if(obstacles[i].x + obstacles[i].width < 0) obstacles.splice(i, 1);
            }

            // Get difficulty settings for obstacle spawning
            const spawnSetting = gameSettings.spawnRateLevel;
            const spawnMode = getSpawnMode(spawnSetting);

            // Run collision checks after updating positions
            checkCollision();

            // Super random spawning for hard and very hard difficulties
            if (spawnMode.independent) {
                // Process all timers but with random chance of skipping updates
                // This makes the timer pattern itself unpredictable
                if (Math.random() < 0.9) groundObstacleTimer -= dt;
                if (Math.random() < 0.85) groundObstacleTimerOffset -= dt;
                if (Math.random() < 0.87) skyObstacleTimer -= dt;
                if (Math.random() < 0.83) skyObstacleTimerOffset -= dt;

                // Random chance to spawn even if timer isn't exactly 0
                // This creates completely unpredictable timing
                const randomTriggerChance = spawnSetting === 'veryHard' ? 0.005 : 0.003;

                // When any ground timer reaches 0 or random trigger, spawn a ground obstacle
                if (groundObstacleTimer <= 0 || groundObstacleTimerOffset <= 0 || Math.random() < randomTriggerChance) {
                    // Random chance to NOT spawn even when timer hits 0 (makes patterns less predictable)
                    if (Math.random() < 0.9) {
                        createObstacle('ground');
                    }

                    // Calculate random new times with wider ranges for more chaos
                    let minTime, maxTime;
                    switch (spawnSetting) {
                        case 'hard':
                            minTime = 1.5 + Math.random() * 0.6; // 1.5-2.1s
                            maxTime = 2.0 + Math.random() * 0.5; // 2.0-2.5s
                            break;
                        case 'veryHard':
                            minTime = 0.8 + Math.random() * 0.4; // 0.8-1.2s
                            maxTime = 1.3 + Math.random() * 0.6; // 1.3-1.9s
                            break;
                        default:
                            minTime = 1.8;
                            maxTime = 2.0;
                    }

                    // Reset the timer that triggered the spawn with complete randomness
                    if (groundObstacleTimer <= 0) {
                        groundObstacleTimer = minTime + Math.random() * (maxTime - minTime);
                    }
                    if (groundObstacleTimerOffset <= 0) {
                        groundObstacleTimerOffset = minTime + Math.random() * (maxTime - minTime);
                    }
                }

                // When any sky timer reaches 0 or random trigger, spawn a sky obstacle
                if (skyObstacleTimer <= 0 || skyObstacleTimerOffset <= 0 || Math.random() < randomTriggerChance) {
                    // Random chance to NOT spawn even when timer hits 0
                    if (Math.random() < 0.9) {
                        createObstacle('sky');
                    }

                    // Calculate random new times
                    let minTime, maxTime;
                    switch (spawnSetting) {
                        case 'hard':
                            minTime = 1.6 + Math.random() * 0.5; // 1.6-2.1s
                            maxTime = 2.1 + Math.random() * 0.4; // 2.1-2.5s
                            break;
                        case 'veryHard':
                            minTime = 0.9 + Math.random() * 0.3; // 0.9-1.2s
                            maxTime = 1.4 + Math.random() * 0.5; // 1.4-1.9s
                            break;
                        default:
                            minTime = 1.8;
                            maxTime = 2.0;
                    }

                    // Reset the timer that triggered the spawn
                    if (skyObstacleTimer <= 0) {
                        skyObstacleTimer = minTime + Math.random() * (maxTime - minTime);
                    }
                    if (skyObstacleTimerOffset <= 0) {
                        skyObstacleTimerOffset = minTime + Math.random() * (maxTime - minTime);
                    }
                }

            } else {
                // Even easier difficulty modes get more randomness
                obstacleTimer -= dt;

                // Random chance to spawn regardless of timer (small chance)
                if (obstacleTimer <= 0 || Math.random() < 0.002) {
                    // 70% chance of pure randomness, 30% chance of alternating pattern
                    let nextType;

                    if (Math.random() < 0.7) {
                        // Pure random selection with variable probability
                        // Make ground obstacles slightly more common to avoid too many flying obstacles
                        nextType = Math.random() < 0.6 ? 'ground' : 'sky';
                    } else {
                        // Alternating pattern for some predictability
                        if (obstacles.length > 0) {
                            const lastObstacle = obstacles[obstacles.length-1];
                            nextType = lastObstacle.category === 'ground' ? 'sky' : 'ground';
                        } else {
                            nextType = 'ground';
                        }
                    }

                    createObstacle(nextType);

                    // Set spawn rate based on difficulty with much more randomness
                    let baseInterval;
                    switch (spawnSetting) {
                        case 'easy':
                            baseInterval = 3.5;
                            break;
                        case 'normal':
                            baseInterval = 2.5;
                            break;
                        default:
                            baseInterval = 2.5;
                    }

                    // Much wider random range (±40% of base interval)
                    obstacleTimer = baseInterval * (0.8 + Math.random() * 0.8); // 80-160% of base interval
                }
            }
        }

        // Helper function to get spawn mode based on difficulty setting
        function getSpawnMode(difficulty) {
            switch (difficulty) {
                case 'easy':
                    return { timer: 3.5, independent: false };
                case 'normal':
                    return { timer: 2.5, independent: false };
                case 'hard':
                    return { timer: 1.8, independent: true };
                case 'veryHard':
                    return { timer: 1.0, independent: true };
                default:
                    return { timer: 2.5, independent: false };
            }
        }

        function updateClouds(dt) {
            for(let i=clouds.length-1; i>=0; i--){
                clouds[i].x -= clouds[i].speed * dt;
                if(clouds[i].x + clouds[i].width < 0) clouds.splice(i, 1);
            }
            cloudTimer -= dt;
            if(cloudTimer <= 0 && clouds.length < 5){
                createCloud();
                // Cloud spawn rate is simpler and less affected by difficulty
                cloudTimer = 3 + Math.random() * 5;
            }
        }

        function updateScore(dt) {
            if(!scoreElement) return;
            // Apply speed setting to score calculation
            const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];
            score += (speed / scaleFactor) * dt * 0.1;
            scoreElement.textContent = Math.floor(score/10);
        }

        // --- updateDifficulty - Mit konsistenter Hitbox
        function updateDifficulty(dt) {
            // Get the speed multiplier from settings
            const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];

            // Apply speed increment based on speed setting and game progress
            speed += (speedIncrement * baseSpeed) * scaleFactor * speedMultiplier * dt;

            const tier = Math.floor(Math.floor(score/10)/100);
            const night = tier % 2 !== 0;
            if(night !== isNight) {
                isNight = night;
                if(document.body) document.body.style.backgroundColor = isNight ? '#3a3a4a' : '#e0e0e0';
            }
        }

        // --- updateBackground - Nutzt neue BG Logik ---
        function updateBackground(dt) {
            const img = isNight ? nightBgImg : dayBgImg;
            if (!img || !img.complete || img.naturalWidth === 0) return;
            const h = canvas.height;
            const r = img.naturalWidth / img.naturalHeight;
            let sw = h * r;
            if(sw < canvas.width) sw = canvas.width;

            // Apply speed setting to parallax
            const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];
            backgroundX -= (speed * 0.3) * dt;
            if(backgroundX <= -sw) backgroundX += sw;
        }

        // --- FIXED checkCollision - Simpler and more reliable
        function checkCollision() {
            // Debug indicator - remove in production
            // console.log("Checking collisions...");

            // Skip collision check entirely if invulnerable or not in gameplay
            if (isInvulnerable || currentState !== GameState.PLAYING || !player) {
                return;
            }

            // Use a simplified, reliable collision detection with pixel margins
            // Apply a consistent hitbox size for the player based on difficulty
            const hitboxReduction = 0.25; // 25% smaller hitbox than visual size

            // Calculate player hitbox with some margin for better gameplay
            const pLeft = player.x + player.width * hitboxReduction / 2;
            const pTop = player.y + player.height * hitboxReduction / 2;
            const pWidth = player.width * (1 - hitboxReduction);
            const pHeight = player.height * (1 - hitboxReduction);

            // Visualize hitboxes if enabled
            if (gameSettings.showHitboxes && debugOverlay) {
                debugOverlay.innerHTML = ''; // Clear previous hitboxes

                // Draw player hitbox
                const playerBox = document.createElement('div');
                playerBox.style.position = 'absolute';
                playerBox.style.left = pLeft + 'px';
                playerBox.style.top = pTop + 'px';
                playerBox.style.width = pWidth + 'px';
                playerBox.style.height = pHeight + 'px';
                playerBox.style.backgroundColor = 'rgba(0, 255, 0, 0.3)';
                playerBox.style.border = '2px solid lime';
                playerBox.style.zIndex = '100';
                debugOverlay.appendChild(playerBox);
            }

            // Check each obstacle
            for (const obstacle of obstacles) {
                // Apply obstacle hitbox reduction for better gameplay
                const obstacleHitboxReduction = 0.2; // 20% smaller than visual

                // Calculate obstacle hitbox
                const oLeft = obstacle.x + obstacle.width * obstacleHitboxReduction / 2;
                const oTop = obstacle.y + obstacle.height * obstacleHitboxReduction / 2;
                const oWidth = obstacle.width * (1 - obstacleHitboxReduction);
                const oHeight = obstacle.height * (1 - obstacleHitboxReduction);

                // Visualize obstacle hitboxes if enabled
                if (gameSettings.showHitboxes && debugOverlay) {
                    const obstacleBox = document.createElement('div');
                    obstacleBox.style.position = 'absolute';
                    obstacleBox.style.left = oLeft + 'px';
                    obstacleBox.style.top = oTop + 'px';
                    obstacleBox.style.width = oWidth + 'px';
                    obstacleBox.style.height = oHeight + 'px';
                    obstacleBox.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                    obstacleBox.style.border = '2px solid red';
                    obstacleBox.style.zIndex = '100';
                    debugOverlay.appendChild(obstacleBox);
                }

                // AABB collision detection (Axis-Aligned Bounding Box)
                // This is the most reliable method for rectangle collision
                if (
                    pLeft < oLeft + oWidth &&
                    pLeft + pWidth > oLeft &&
                    pTop < oTop + oHeight &&
                    pTop + pHeight > oTop
                ) {
                    // Collision detected!
                    console.log("COLLISION DETECTED with:", obstacle.type);
                    loseLife();
                    return; // Exit after processing collision
                }
            }
        }

        // --- Draw ---
        function draw() {
            if(!ctx) return;
            drawBackground();
            drawClouds();
            drawGround();
            drawObstacles();
            drawPlayer();
        }

        // --- drawBackground - Nutzt neue BG Logik ---
        function drawBackground() {
            const img = isNight ? nightBgImg : dayBgImg;
            if (img && img.complete && img.naturalWidth > 0){
                const h = canvas.height;
                const r = img.naturalWidth / img.naturalHeight;
                let sw = h * r;
                let sh = h;
                let y = 0;
                if(sw < canvas.width){
                    sw = canvas.width;
                    sh = sw / r;
                    y = h - sh;
                }
                const copies = Math.ceil(canvas.width / sw) + 1;
                for(let i = 0; i < copies; i++) {
                    try {
                        ctx.drawImage(img, backgroundX + (sw * i), y, sw, sh);
                    } catch(e){
                        console.error("BG Draw Err:", e);
                        ctx.fillStyle = isNight ? '#2d2d3a' : '#87CEEB';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        break;
                    }
                }
            } else {
                ctx.fillStyle = isNight ? '#2d2d3a' : '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function drawGround() {
            if(!ctx) return;
            ctx.fillStyle = isNight ? 'rgba(40,40,50,0.8)' : 'rgba(100,140,80,0.7)';
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
            ctx.fillStyle = isNight ? 'rgba(50,50,60,0.8)' : 'rgba(120,160,100,0.7)';
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, 2 * scaleFactor);
        }

        function drawPlayer() {
            if(!ctx || !player || !player.image) return;
            ctx.globalAlpha = (isInvulnerable && currentState === GameState.PLAYING) ? (0.6 + Math.sin(Date.now() / 100) * 0.4) : 1;
            if(player.image.complete && player.image.naturalWidth > 0){
                ctx.drawImage(player.image, player.x, player.y, player.width, player.height);
            } else {
                ctx.fillStyle = (character === 'fuchs' ? '#ff6f00' : '#8d6e63');
                ctx.fillRect(player.x, player.y, player.width, player.height);
                /*Face*/
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(player.x + player.width * 0.35, player.y + player.height * 0.3, player.width * 0.08, 0, Math.PI * 2);
                ctx.arc(player.x + player.width * 0.65, player.y + player.height * 0.3, player.width * 0.08, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1 * scaleFactor;
                ctx.beginPath();
                ctx.arc(player.x + player.width * 0.5, player.y + player.height * 0.6, player.width * 0.15, 0.2 * Math.PI, 0.8 * Math.PI);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        function drawObstacles() {
            if (!ctx) return;
            for (const obstacle of obstacles) {
                try {
                    if (obstacle.image && obstacle.image.complete && obstacle.image.naturalWidth > 0) {
                        ctx.drawImage(obstacle.image, obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    } else {
                        ctx.fillStyle = obstacle.category === 'sky' ? '#ADD8E6' : '#A0522D';
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        ctx.fillStyle = '#000';
                        ctx.font = `${Math.max(10, obstacle.height * 0.2)}px Courier New`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(obstacle.type.substring(0, 3), obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                    }
                } catch (drawErr) {
                    console.error("Error drawing obstacle:", obstacle.type, drawErr);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                } finally {
                     ctx.textAlign = 'start';
                     ctx.textBaseline = 'alphabetic';
                }
            }
        }

        function drawClouds() {
            if(!ctx) return;
            ctx.fillStyle = isNight ? 'rgba(100,100,100,0.6)' : 'rgba(255,255,255,0.7)';
            ctx.strokeStyle = isNight ? 'rgba(80,80,80,0.6)' : 'rgba(220,220,220,0.7)';
            ctx.lineWidth = 1 * scaleFactor;
            for(const c of clouds){
                ctx.beginPath();
                ctx.ellipse(c.x + c.width / 2, c.y + c.height / 2, c.width / 2, c.height / 2, 0, 0, Math.PI * 2);
                ctx.ellipse(c.x + c.width * 0.3, c.y + c.height * 0.3, c.width * 0.3, c.height * 0.4, 0, 0, Math.PI * 2);
                ctx.ellipse(c.x + c.width * 0.7, c.y + c.height * 0.4, c.width * 0.4, c.height * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }

        // --- UI Update --- Updated for settings panel and back button
        function updateUI() {
            try {
                const pl = currentState === GameState.PLAYING;
                const pa = currentState === GameState.PAUSED;
                const go = currentState === GameState.GAMEOVER;
                const re = currentState === GameState.READY;
                const se = currentState === GameState.SETTINGS;

                if(startButton) startButton.style.display = (re || go) ? 'inline-block' : 'none';
                if(settingsButton) settingsButton.style.display = (re || go) ? 'inline-block' : 'none';
                if(characterSelectContainer) characterSelectContainer.style.display = (re || go) ? 'flex' : 'none';
                if(restartButton) restartButton.style.display = go ? 'inline-block' : 'none';
                if(gameOverElement) gameOverElement.style.display = go ? 'flex' : 'none';
                if(pauseOverlay) pauseOverlay.style.display = pa ? 'flex' : 'none';
                if(settingsPanel) settingsPanel.style.display = se ? 'flex' : 'none';
                if(duckButton) duckButton.style.display = pl ? 'flex' : 'none';
                if(backButton) backButton.style.display = (pl || pa) ? 'flex' : 'none';

                const instructionsElement = document.getElementById('instructions');
                if(instructionsElement) {
                    instructionsElement.style.display = (re || go) ? 'block' : 'none';
                }

                if(fuchsSelect) fuchsSelect.style.pointerEvents = (re || go) ? 'auto' : 'none';
                if(waschbaerSelect) waschbaerSelect.style.pointerEvents = (re || go) ? 'auto' : 'none';
            } catch(err) {
                console.error("Error in updateUI:", err);
            }
        }

        // --- Game Loop ---
        function gameLoop(timestamp) {
            if(typeof lastTime === 'undefined' || isNaN(timestamp)){
                console.error("Loop Error TS/LT");
                lastTime = performance.now();
                if(animationFrameId) cancelAnimationFrame(animationFrameId);
                return;
            }
            const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
            lastTime = timestamp;
            try {
                if (currentState === GameState.PLAYING) update(dt);
                draw();
            } catch (error) {
                console.error("!!! Runtime Error in Loop:", error);
                if(animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                currentState = GameState.GAMEOVER;
                updateUI();
                return;
            }
            if (currentState === GameState.PLAYING || currentState === GameState.READY || currentState === GameState.INIT)
                animationFrameId = requestAnimationFrame(gameLoop);
            else
                animationFrameId = null;
        }

        // --- Event Handlers ---
        function handleKeyDown(e) {
            try{
                let a = false;
                if(e.key === 'p' || e.key === 'P' || e.key === 'Escape'){
                    if(currentState === GameState.PLAYING || currentState === GameState.PAUSED)
                        togglePause();
                    a = true;
                } else if(e.key === ' ' || e.key === 'ArrowUp'){
                    if(currentState === GameState.READY || currentState === GameState.GAMEOVER)
                        startGame();
                    else if(currentState === GameState.PLAYING)
                        jump();
                    a = true;
                } else if(e.key === 'ArrowDown'){
                    if(currentState === GameState.PLAYING)
                        setDucking(true);
                    a = true;
                }
                if(a) e.preventDefault();
            } catch(err){}
        }

        function handleKeyUp(e) {
            try{
                let a = false;
                if(e.key === 'ArrowDown'){
                    if(currentState === GameState.PLAYING)
                        setDucking(false);
                    a = true;
                }
                if(a) e.preventDefault();
            } catch(err){}
        }

        function handleCanvasPointerDown(e) {
            try{
                if(currentState === GameState.PAUSED)
                    togglePause();
                else if(currentState === GameState.READY || currentState === GameState.GAMEOVER)
                    startGame();
                else if(currentState === GameState.PLAYING)
                    jump();
                e.preventDefault();
            } catch(err){}
        }

        function handleDuckButtonPointerDown(e) {
            try{
                if(currentState === GameState.PLAYING && e.target){
                    setDucking(true);
                    e.target.setPointerCapture(e.pointerId);
                }
                e.preventDefault();
            } catch(err){}
        }

        function handleDuckButtonPointerUp(e) {
            try{
                if(currentState === GameState.PLAYING && e.target){
                    setDucking(false);
                    if(e.target.hasPointerCapture(e.pointerId))
                        e.target.releasePointerCapture(e.pointerId);
                }
                e.preventDefault();
            } catch(err){}
        }

        function handleDuckButtonPointerCancel(e) {
            try{
                if(currentState === GameState.PLAYING && e.target){
                    setDucking(false);
                    if(e.target.hasPointerCapture(e.pointerId))
                        e.target.releasePointerCapture(e.pointerId);
                }
                e.preventDefault();
            } catch(err){}
        }

        function handleCharacterSelect(e) {
            try{
                if((currentState !== GameState.READY && currentState !== GameState.GAMEOVER) || !e.target || e.target.tagName !== 'IMG')
                    return;
                const nc = (e.target.id === 'fuchs') ? 'fuchs' : 'waschbaer';
                if(nc !== character){
                    character = nc;
                    if(fuchsSelect) fuchsSelect.classList.toggle('selected', character === 'fuchs');
                    if(waschbaerSelect) waschbaerSelect.classList.toggle('selected', character === 'waschbaer');
                    if(player) player.image = (character === 'fuchs' ? fuchsImg : waschbaerImg);
                    if(currentState === GameState.READY){
                        resetGame();
                        draw();
                    }
                }
            } catch(err){}
        }

        function handleResize() {
            try{
                resizeCanvas();
                if(currentState !== GameState.PLAYING) draw();
            } catch(err){}
        }

        function addEventListeners() {
            console.log("Listeners: Adding...");
            try {
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('keyup', handleKeyUp);
                if(canvas) canvas.addEventListener('pointerdown', handleCanvasPointerDown);
                if(startButton) startButton.addEventListener('click', startGame);
                if(restartButton) restartButton.addEventListener('click', startGame);
                if(quitButton) quitButton.addEventListener('click', quitGame);
                if(backButton) backButton.addEventListener('click', backToMenu);
                if(settingsButton) settingsButton.addEventListener('click', toggleSettingsPanel);
                if(settingsCloseButton) settingsCloseButton.addEventListener('click', toggleSettingsPanel);
                if(settingsResetButton) settingsResetButton.addEventListener('click', resetGameSettings);

                // Add event listener for the new settings back button
                if(settingsBackButton) settingsBackButton.addEventListener('click', toggleSettingsPanel);

                if(duckButton) {
                    duckButton.addEventListener('pointerdown', handleDuckButtonPointerDown);
                    duckButton.addEventListener('pointerup', handleDuckButtonPointerUp);
                    duckButton.addEventListener('pointercancel', handleDuckButtonPointerCancel);
                    duckButton.addEventListener('contextmenu', (e) => e.preventDefault());
                }
                if(characterSelectContainer) characterSelectContainer.addEventListener('click', handleCharacterSelect);
                window.addEventListener('resize', handleResize);
                console.log("Listeners: Added.");
            } catch(e) {
                console.error("Listener Add Error", e);
            }
        }

        // --- Start ---
        console.log("--- Script End ---");
    </script>
</body>
</html>