<!DOCTYPE html>
<html>
<head>
    <title>Pixel Runner Adventure</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#333333">
    <meta charset="UTF-8">
    <!-- Preload the loading image first -->
    <link rel="preload" href="https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/load.webp" as="image">
    <style>
        /* Reset and Base Styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100vh; overflow: hidden; background-color: #e0e0e0; font-family: 'Courier New', monospace; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; }
        #gameContainer { position: relative; width: 95vw; max-width: 800px; aspect-ratio: 16 / 9; max-height: 85vh; overflow: hidden; border: 2px solid #333; box-shadow: 0 5px 15px rgba(0,0,0,0.2); background-color: #87CEEB; /* Himmelsblau als Fallback */ }
        #gameCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        /* Loading Spinner Styles */
        #loadingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #loadingSpinner {
            width: 100px;
            height: 100px;
            animation: spin 2s linear infinite;
            display: block;
            object-fit: contain;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* UI Styles - VERBESSERT FÜR SMARTPHONES */
        #gameControls, #gameInfo, #livesDisplay, #quitButton, #pauseOverlay, #gameOver, #duckButton { position: absolute; z-index: 10; font-size: max(2.2vmin, 16px); } /* Größere Schrift */
        #gameControls {
            top: 2%;
            left: 2%;
            display: flex;
            gap: 12px; /* Größerer Abstand für Touch */
            align-items: center;
        }
        #gameInfo {
            top: 2%;
            right: 10%;
            text-align: right;
            color: #fff; /* Besserer Kontrast */
            background-color: rgba(0, 0, 0, 0.7); /* Dunklerer Hintergrund für bessere Lesbarkeit */
            padding: max(0.8vmin, 5px) max(1.4vmin, 8px); /* Größerer Padding */
            border-radius: 8px; /* Abgerundete Ecken */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3); /* Schatten für bessere Sichtbarkeit */
        }
        #gameInfo div { margin-bottom: 3px; font-weight: bold; } /* Fetter Text */

        /* Stark verbesserte Herz-Anzeige für bessere Sichtbarkeit */
        #livesDisplay {
            top: calc(2% + 60px);
            right: 10%;
            background-color: rgba(0, 0, 0, 0.7);
            padding: max(0.8vmin, 5px) max(1.4vmin, 8px);
            border-radius: 8px;
            display: flex;
            gap: 8px; /* Größerer Abstand zwischen Herzen */
            box-shadow: 0 2px 4px rgba(0,0,0,0.3); /* Schatten für bessere Sichtbarkeit */
            border: 1px solid rgba(255,255,255,0.3); /* Subtiler Rand */
        }

        /* Deutlich verbesserte, größere und auffälligere Herz-Anzeige */
        .heart {
            color: #ff3333; /* Kräftigeres Rot */
            font-size: max(4vmin, 22px); /* Deutlich größer */
            font-weight: bold;
            text-shadow:
                0 0 5px rgba(255,0,0,0.7), /* Rotes Leuchten */
                1px 1px 2px rgba(0,0,0,0.9); /* Dunkler Schatten */
            transition: transform 0.3s ease-out, opacity 0.3s ease-out, visibility 0s; /* Längere Animation */
            display: inline-block;
            visibility: visible;
            opacity: 1;
            transform: scale(1);
            line-height: 1; /* Besseres Zentrieren */
            -webkit-text-stroke: 1px rgba(0,0,0,0.5); /* Schwarzer Umriss für besseren Kontrast */
        }

        /* Animierte Herz-Ausblendung */
        .heart.hidden {
            visibility: hidden;
            opacity: 0;
            transform: scale(0.2) rotate(180deg); /* Dreht sich und schrumpft */
            transition: transform 0.5s ease-out, opacity 0.5s ease-out, visibility 0s 0.5s;
        }
        #quitButton { top: 2%; right: 2%; width: max(4vmin, 24px); height: max(4vmin, 24px); background-color: #ff3333; color: white; font-weight: bold; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; z-index: 30; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); border: none; font-size: max(2vmin, 12px); line-height: 1; }
        #quitButton:hover { background-color: #cc0000; }
        /* Back Button Styling - Moved to far left and changed to green */
        #backButton {
            top: 2%;
            left: 2%;
            width: max(4vmin, 24px);
            height: max(4vmin, 24px);
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 30;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: none;
            font-size: max(2vmin, 12px);
            line-height: 1;
            position: absolute;
        }
        #backButton:hover {
            background-color: #45a049;
        }
        #pauseOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 20; }
        #pauseOverlay h2 { color: #ffffff; font-size: max(4.5vmin, 26px); text-align: center; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); margin-bottom: 10px; }
        #pauseOverlay p { color: #f0f0f0; font-size: max(2.2vmin, 16px); text-align: center; margin-top: 15px; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); }
        /* Game Over mit Banner */
        #gameOver { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 20; background-image: url('https://raw.githubusercontent.com/ErSieCode/1Rad/main/Banner.png'); background-size: contain; background-repeat: no-repeat; background-position: center center; background-color: rgba(0, 0, 0, 0.6); text-align: center; }
        #gameOver h2 { color: #ffffff; font-size: max(4.5vmin, 26px); text-align: center; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); margin-bottom: 10px; margin-top: -10%; }
        #gameOver div { color: #f0f0f0; margin-bottom: 15px; font-size: max(2.5vmin, 17px); background-color: rgba(0,0,0,0.6); padding: 5px 10px; border-radius: 4px; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); }
        /* Buttons */
        #startButton, #restartButton, #settingsButton, #settingsCloseButton, #settingsResetButton {
            padding: max(1.4vmin, 10px) max(2.8vmin, 20px);
            font-size: max(2.3vmin, 16px);
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: 15px;
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
            text-shadow: 1px 1px 1px rgba(0,0,0,0.4);
            transition: background-color 0.2s;
        }
        #startButton:hover, #restartButton:hover, #settingsButton:hover, #settingsCloseButton:hover, #settingsResetButton:hover {
            background-color: #45a049;
        }
        #startButton, #settingsButton { margin-right: 5px; }
        #characterSelect { display: flex; gap: 10px; align-items: center; }
        #characterSelect img { width: max(6vmin, 35px); height: max(6vmin, 35px); cursor: pointer; border: 3px solid transparent; border-radius: 5px; background-color: rgba(255, 255, 255, 0.7); padding: 1px; transition: border-color 0.2s, transform 0.2s; }
        #characterSelect img:hover { transform: scale(1.1); }
        #characterSelect img.selected { border-color: #ff9800; transform: scale(1.05); }
        #instructions { width: 90%; max-width: 600px; text-align: center; color: #444; font-size: max(1.7vmin, 14px); z-index: 5; background-color: rgba(210, 210, 210, 0.8); padding: max(0.7vmin, 5px) max(1.2vmin, 9px); border-radius: 5px; margin-top: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        /* Duck Button CSS - OPTIMIERT FÜR MOBILE UND TOUCH */
        #duckButton {
            bottom: 10%; /* Höher positioniert für bessere Erreichbarkeit */
            right: 5%; /* Weiter nach innen für bessere Erreichbarkeit */
            width: max(7.7vmin, 46.2px); /* DEUTLICH größer für mobile Touch */
            height: max(7.7vmin, 46.2px); /* DEUTLICH größer für mobile Touch */
            background-color: rgba(80, 80, 80, 0.8); /* Dunklerer Hintergrund */
            border: 1.4px solid rgba(255, 255, 255, 0.5); /* Weißer Rand für bessere Sichtbarkeit */
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: max(3.85vmin, 18.5px); /* Größerer Text */
            z-index: 100; /* Höherer z-index, um Überdeckung zu vermeiden */
            cursor: pointer;
            display: none;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 2.8px 5.6px rgba(0, 0, 0, 0.5); /* Stärkerer Schatten */
            touch-action: manipulation;
            padding: 0;
            overflow: hidden;
            transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s;
            /* Aktives Feedback-Leuchten für bessere Sichtbarkeit */
            animation: pulse-button 1.5s infinite alternate;
        }

        /* Duck-Button-Bild anpassen */
        #duckButton img {
            width: 70%;
            height: 70%;
            object-fit: contain;
            pointer-events: none;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5)); /* Schatten für das Bild */
        }

        /* Stärkeres visuelles Feedback bei Berührung */
        #duckButton:active {
            background-color: rgba(100, 100, 100, 0.9);
            transform: translateY(4px) scale(0.95);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.8);
        }

        /* Pulsier-Animation für den Duck-Button */
        @keyframes pulse-button {
            0% { box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); }
            100% { box-shadow: 0 4px 12px rgba(100, 255, 185, 0.7); }
        }
        @keyframes doubleJumpEffect { 0% { transform: scale(1); opacity: 0.7; } 100% { transform: scale(2.5); opacity: 0; } }
        .doubleJumpEffect { position: absolute; border-radius: 50%; background-color: rgba(255, 215, 0, 0.6); pointer-events: none; z-index: 15; animation: doubleJumpEffect 0.4s ease-out forwards; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

        /* Settings Panel Styles - UPDATED FOR DIFFICULTY LEVELS */
        #settingsPanel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 25;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
            overflow-y: auto;
        }

        /* Added settings header container to hold title and back button */
        .settings-header {
            display: flex;
            width: 100%;
            justify-content: center;
            align-items: center;
            position: relative;
            margin-bottom: 20px;
            padding-top: 10px;
        }

        /* Settings back button styling */
        #settingsBackButton {
            position: absolute;
            left: 0;
            width: max(4.5vmin, 30px);
            height: max(4.5vmin, 30px);
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: none;
            font-size: max(2.2vmin, 16px);
            line-height: 1;
            -webkit-tap-highlight-color: transparent;
        }

        #settingsBackButton:hover,
        #settingsBackButton:active {
            background-color: #45a049;
        }

        #settingsPanel h2 {
            font-size: max(3vmin, 20px);
            color: #4CAF50;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            text-align: center;
        }

        /* NEW DIFFICULTY SELECTION STYLES */
        .difficulty-selection {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 500px;
        }

        .difficulty-title {
            font-size: max(2.2vmin, 16px);
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            color: #4CAF50;
        }

        .difficulty-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        .difficulty-option {
            position: relative;
            width: calc(50% - 10px);
            min-width: 100px;
        }

        @media (max-width: 500px) {
            .difficulty-option {
                width: 100%;
            }
        }

        .difficulty-option input[type="radio"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }

        .difficulty-option label {
            display: block;
            padding: 10px 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            font-weight: bold;
            transition: all 0.2s;
        }

        .difficulty-option input[type="radio"]:checked + label {
            border-color: #4CAF50;
            background-color: rgba(76, 175, 80, 0.3);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .difficulty-option:nth-child(1) label {
            color: #90EE90; /* Light green for easy */
        }

        .difficulty-option:nth-child(2) label {
            color: #FFFFFF; /* White for normal */
        }

        .difficulty-option:nth-child(3) label {
            color: #FFA500; /* Orange for hard */
        }

        .difficulty-option:nth-child(4) label {
            color: #FF6347; /* Tomato for very hard */
        }

        /* Setting sections */
        .settings-section {
            display: flex;
            flex-direction: column;
            width: 90%;
            max-width: 500px;
            margin-bottom: 15px;
        }

        .settings-section-title {
            font-size: max(1.8vmin, 15px);
            margin-bottom: 5px;
            color: #DDD;
            text-align: center;
        }

        /* Checkbox styling for hitbox toggle */
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
        }

        .checkbox-container input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-container label {
            font-size: max(1.8vmin, 14px);
            cursor: pointer;
            font-weight: bold;
        }

        .settings-buttons {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Make buttons bigger on mobile for better touch targets */
        @media (max-width: 500px) {
            #settingsResetButton, #settingsCloseButton {
                padding: 12px 20px;
                font-size: 18px;
                margin: 5px;
            }
        }

        /* Debug overlay for hitboxes */
        #debugOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
        }

        /* Stil für Hintergrund-Info-Anzeige */
        #backgroundInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
            display: none; /* Standardmäßig ausgeblendet */
        }
    </style>
</head>
<body>
    <!-- HTML Struktur -->
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="debugOverlay"></div>
        <div id="loadingOverlay">
            <img id="loadingSpinner" src="https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/load.webp" alt="Loading..."
                 onerror="this.onerror=null; console.error('Loading image failed to load'); this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iNDAiIGN5PSI0MCIgcj0iMzYiIHN0cm9rZT0iIzRDQUY1MCIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSJub25lIiBzdHJva2UtZGFzaGFycmF5PSIxNTAgMTgwIiAvPjwvc3ZnPg==';"
                 onload="console.log('Loading spinner image loaded successfully!');">
        </div>
        <div id="gameControls">
            <button id="startButton">START</button>
            <button id="settingsButton">SETTINGS</button>
            <div id="characterSelect">
                <img id="fuchs" src="https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/Fuchs_einrad.webp" alt="Fuchs">
                <img id="waschbaer" src="https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/waschbaer_einrad.webp" alt="Waschbär">
            </div>
        </div>
        <div id="gameInfo">
            <div>SCORE: <span id="score">0</span></div>
            <div>HI: <span id="highScore">0</span></div>
        </div>
        <div id="livesDisplay"></div>
        <button id="quitButton">✕</button>
        <button id="backButton">⬅</button>
        <div id="pauseOverlay">
            <div><h2>GAME PAUSED</h2><p>Press 'P' or ESC or Tap to resume</p></div>
        </div>
        <button id="duckButton">↓</button>
        <div id="gameOver">
            <h2>GAME OVER</h2>
            <div>Final Score: <span id="finalScore">0</span></div>
            <button id="restartButton">RESTART</button>
        </div>
        <div id="backgroundInfo">Aktuelle Zeit: <span id="currentMinute">0</span> Minuten</div>

        <!-- Settings Panel - UPDATED WITH DIFFICULTY LEVELS -->
        <div id="settingsPanel">
            <div class="settings-header">
                <button id="settingsBackButton">⬅</button>
                <h2>Game Settings</h2>
            </div>

            <!-- Game Speed Setting -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Game Speed</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="speedEasy" name="speedSetting" value="easy">
                        <label for="speedEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="speedNormal" name="speedSetting" value="normal" checked>
                        <label for="speedNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="speedHard" name="speedSetting" value="hard">
                        <label for="speedHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="speedVeryHard" name="speedSetting" value="veryHard">
                        <label for="speedVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Jump Height Setting -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Jump Height</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="jumpEasy" name="jumpSetting" value="easy">
                        <label for="jumpEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="jumpNormal" name="jumpSetting" value="normal" checked>
                        <label for="jumpNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="jumpHard" name="jumpSetting" value="hard">
                        <label for="jumpHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="jumpVeryHard" name="jumpSetting" value="veryHard">
                        <label for="jumpVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Spawn Rate Setting -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Spawn Rate</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="spawnEasy" name="spawnSetting" value="easy">
                        <label for="spawnEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="spawnNormal" name="spawnSetting" value="normal" checked>
                        <label for="spawnNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="spawnHard" name="spawnSetting" value="hard">
                        <label for="spawnHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="spawnVeryHard" name="spawnSetting" value="veryHard">
                        <label for="spawnVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Flying Objects Height Setting - Default auf "Easy" gesetzt -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Flying Objects Height</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="flyingHeightEasy" name="flyingHeightSetting" value="easy" checked>
                        <label for="flyingHeightEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="flyingHeightNormal" name="flyingHeightSetting" value="normal">
                        <label for="flyingHeightNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="flyingHeightHard" name="flyingHeightSetting" value="hard">
                        <label for="flyingHeightHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="flyingHeightVeryHard" name="flyingHeightSetting" value="veryHard">
                        <label for="flyingHeightVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Hitbox Size Setting -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Hitbox Size</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="hitboxSizeEasy" name="hitboxSizeSetting" value="easy">
                        <label for="hitboxSizeEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="hitboxSizeNormal" name="hitboxSizeSetting" value="normal" checked>
                        <label for="hitboxSizeNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="hitboxSizeHard" name="hitboxSizeSetting" value="hard">
                        <label for="hitboxSizeHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="hitboxSizeVeryHard" name="hitboxSizeSetting" value="veryHard">
                        <label for="hitboxSizeVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Hitbox visualization toggle -->
            <div class="checkbox-container">
                <input type="checkbox" id="showHitboxSetting">
                <label for="showHitboxSetting">Show Hitboxes</label>
            </div>

            <!-- Background info toggle -->
            <div class="checkbox-container">
                <input type="checkbox" id="showBackgroundInfoSetting">
                <label for="showBackgroundInfoSetting">Show Background Info</label>
            </div>

            <div class="settings-buttons">
                <button id="settingsResetButton">Reset Defaults</button>
                <button id="settingsCloseButton">Close</button>
            </div>
        </div>
    </div>
    <div id="instructions">Press SPACE/UP/Tap to jump/double jump | DOWN/Button to duck | P/ESC to pause</div>

    <script>
        'use strict';
        console.log("--- Script Start ---");

        // --- Debug Utility ---
        function logImageStatus(name, img) {
            img.onload = () => console.log(`✓ ${name} loaded.`);
            img.onerror = (e) => console.error(`✗ ${name} FAILED loading from ${img.src}`, e);
        }

        // Initialize loading spinner first
        document.addEventListener('DOMContentLoaded', function() {
            const loadingSpinner = document.getElementById('loadingSpinner');
            const loadingOverlay = document.getElementById('loadingOverlay');

            // Make sure the loading overlay is visible
            if (loadingOverlay) {
                loadingOverlay.style.display = 'flex';
            }

            // Check if the image is loading correctly
            if (loadingSpinner) {
                if (!loadingSpinner.complete) {
                    console.log("Loading spinner image is still loading...");
                    loadingSpinner.onload = function() {
                        console.log("Loading spinner image has loaded successfully!");
                    };
                } else {
                    console.log("Loading spinner image was already loaded!");
                }
            }
        });

        // --- Asset Loading with progress tracking ---
        console.log("Assets: Defining...");
        // Track loading progress
        let totalAssets = 14; // Erhöht auf 14 für die zwei zusätzlichen Hintergrundbilder
        let loadedAssets = 0;
        const loadingOverlay = document.getElementById('loadingOverlay');

        function checkAllAssetsLoaded() {
            loadedAssets++;
            console.log(`Loaded ${loadedAssets}/${totalAssets} assets`);
            if (loadedAssets >= totalAssets) {
                // Hide loading overlay when all assets are loaded
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'none';
                }
                console.log("All assets loaded successfully!");
            }
        }

        function enhancedLogImageStatus(name, img) {
            img.onload = () => {
                console.log(`✓ ${name} loaded.`);
                checkAllAssetsLoaded();
            };
            img.onerror = (e) => {
                console.error(`✗ ${name} FAILED loading from ${img.src}`, e);
                checkAllAssetsLoaded(); // Count errors too, to avoid spinner getting stuck
            };
        }

        const fuchsImg = new Image(); enhancedLogImageStatus('Fuchs', fuchsImg);
        const waschbaerImg = new Image(); enhancedLogImageStatus('Waschbär', waschbaerImg);
        const duckButtonImg = new Image(); enhancedLogImageStatus('Duck Icon', duckButtonImg);

        // Backgrounds - Originale + neue Varianten
        const dayBgImg = new Image(); enhancedLogImageStatus('BG Day', dayBgImg);
        const nightBgImg = new Image(); enhancedLogImageStatus('BG Night', nightBgImg);
        const dayBgImg1 = new Image(); enhancedLogImageStatus('BG Day V4', dayBgImg1);
        const nightBgImg1 = new Image(); enhancedLogImageStatus('BG Night V4', nightBgImg1);

        const gameOverBannerImg = new Image(); enhancedLogImageStatus('Game Over Banner', gameOverBannerImg);

        // Obstacles - Ground
        const pallet4Img = new Image(); enhancedLogImageStatus('Obstacle Pallet 4', pallet4Img);
        const pallet6Img = new Image(); enhancedLogImageStatus('Obstacle Pallet 6', pallet6Img);
        const logImg = new Image(); enhancedLogImageStatus('Obstacle Log', logImg);
        const stumpImg = new Image(); enhancedLogImageStatus('Obstacle Stump', stumpImg);

        // Obstacles - Sky
        const owlImg = new Image(); enhancedLogImageStatus('Obstacle Owl', owlImg);
        const flyingUniImg = new Image(); enhancedLogImageStatus('Obstacle Flying Uni', flyingUniImg);

        // Set sources after setting up handlers
        fuchsImg.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/Fuchs_einrad.webp';
        waschbaerImg.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/waschbaer_einrad.webp';
        duckButtonImg.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/Muni_logo.webp';

        // Alle Hintergründe laden - Original und neue Version
        dayBgImg.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/Tag_BG.webp';
        nightBgImg.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/Nacht_BG.webp';
        dayBgImg1.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/Tag_BG_v4.webp';
        nightBgImg1.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/Nacht_BG_v4.webp';

        gameOverBannerImg.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/Banner.webp';
        pallet4Img.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/Paletten_4_IMG.webp';
        pallet6Img.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/Paletten_6_IMG.webp';
        logImg.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/baum_liegend.webp';
        stumpImg.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/baumstumpf.webp';
        owlImg.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/Eule_v1_L.webp';
        flyingUniImg.src = 'https://raw.githubusercontent.com/ErSieCode/ersiecode.github.io/main/images/Flug_Einrad_orange.png';

        console.log("Assets: Defined.");

        // --- DOM Elements ---
        console.log("DOM: Getting elements...");
        let canvas, ctx, scoreElement, highScoreElement, finalScoreElement, gameOverElement, restartButton, startButton,
            fuchsSelect, waschbaerSelect, characterSelectContainer, pauseOverlay, quitButton, livesDisplay, gameContainer,
            duckButton, backButton, settingsButton, settingsPanel, settingsCloseButton, settingsResetButton, debugOverlay,
            showHitboxSetting, settingsBackButton, showBackgroundInfoSetting, backgroundInfo, currentMinuteElement;

        // Frühe Initialisierung der Variablen
        canvas = document.getElementById('gameCanvas');
        ctx = canvas ? canvas.getContext('2d') : null;
        scoreElement = document.getElementById('score');
        highScoreElement = document.getElementById('highScore');
        finalScoreElement = document.getElementById('finalScore');
        gameOverElement = document.getElementById('gameOver');
        restartButton = document.getElementById('restartButton');
        startButton = document.getElementById('startButton');
        fuchsSelect = document.getElementById('fuchs');
        waschbaerSelect = document.getElementById('waschbaer');
        characterSelectContainer = document.getElementById('characterSelect');
        pauseOverlay = document.getElementById('pauseOverlay');
        quitButton = document.getElementById('quitButton');
        livesDisplay = document.getElementById('livesDisplay');
        gameContainer = document.getElementById('gameContainer');
        duckButton = document.getElementById('duckButton');
        backButton = document.getElementById('backButton');
        settingsButton = document.getElementById('settingsButton');
        settingsPanel = document.getElementById('settingsPanel');
        settingsCloseButton = document.getElementById('settingsCloseButton');
        settingsResetButton = document.getElementById('settingsResetButton');
        debugOverlay = document.getElementById('debugOverlay');
        showHitboxSetting = document.getElementById('showHitboxSetting');
        settingsBackButton = document.getElementById('settingsBackButton');
        showBackgroundInfoSetting = document.getElementById('showBackgroundInfoSetting');
        backgroundInfo = document.getElementById('backgroundInfo');
        currentMinuteElement = document.getElementById('currentMinute');

        if (!canvas || !ctx) {
             console.error("CRITICAL: Canvas or Context not available immediately!");
             document.addEventListener('DOMContentLoaded', () => { alert("Fehler: Spiel-Canvas konnte nicht initialisiert werden!"); });
        } else {
             console.log("DOM: Elements retrieved.");
             window.addEventListener('load', init); // Add listener only if canvas is okay
        }

        // --- Game State ---
        const GameState = {
            INIT: 'INIT',
            READY: 'READY',
            PLAYING: 'PLAYING',
            PAUSED: 'PAUSED',
            GAMEOVER: 'GAMEOVER',
            SETTINGS: 'SETTINGS'
        };

        let currentState = GameState.INIT;
        let character = 'fuchs';
        let score = 0;
        let highScore = 0;
        let lives = 3;
        const maxLives = 3;
        let speed = 0;
        let speedIncrement = 0.0005;
        let backgroundX = 0;
        let isDucking = false;
        let isNight = false;
        let isInvulnerable = false;
        let invulnerabilityTimer = null;
        const invulnerabilityDuration = 2000;

        // Variable für Hintergrund-Info-Anzeige
        let showBackgroundInfo = false;

        // --- Physics & Scaling ---
        let scaleFactor = 1;
        const baseWidth = 800;
        let baseSpeed = 250;
        let baseGravity = 1200;
        let baseJumpStrength = -550;
        let groundHeight = 0;
        let player = {};
        let obstacles = [];
        let clouds = [];
        let obstacleTimer = 0;
        let cloudTimer = 0;
        let minObstacleTime = 1.4;
        let maxObstacleTime = 2.8;
        const initialObstacleCooldown = 3.0;
        const highStumpMinTime = 45;

        // Variable to track separate spawn timers for ground and sky obstacles
        let groundObstacleTimer = 0;
        let skyObstacleTimer = 0;

        // Additional offset timers for more randomized spawning
        let groundObstacleTimerOffset = 0;
        let skyObstacleTimerOffset = 0;

        // Skalierungsfaktor für alle Spielelemente - Charakter etwas schmaler machen
        const globalSizeFactor = 1.25; // 25% größer
        const playerWidthRatio = 0.9; // Character width is 90% of normal to make it slightly slimmer

        // --- Verbesserte 4-stufige Spawnregeln, ÜBERARBEITET für bessere Progression ---
        const SpawnRules = {
            // Einfach: Wie früher "normal" - moderate Hindernisse mit etwas Vorhersehbarkeit
            EASY: {
                groundInterval: 2.5,    // Alle 2.5 Sekunden ein Bodenhindernis (wie altes NORMAL)
                skyInterval: 2.5,       // Alle 2.5 Sekunden ein Lufthindernis
                randomVariation: 0.3,   // ±30% Variation für gute Vorhersehbarkeit
                independent: false,     // Boden und Luft alternieren
                staggered: true,        // Versetzter Start
                randomTriggerChance: 0.001 // Sehr geringe Chance für zufällige Spawns
            },
            // Normal: Zwischen altem "normal" und "hard"
            NORMAL: {
                groundInterval: 2.2,    // Etwas häufiger als EASY
                skyInterval: 2.2,       // Etwas häufiger als EASY
                randomVariation: 0.4,   // ±40% Variation für etwas mehr Unvorhersehbarkeit
                independent: false,     // Immer noch alternierend
                staggered: true,        // Versetzter Start
                randomTriggerChance: 0.002 // Etwas mehr zufällige Spawns
            },
            // Schwer: Wie früher "very hard" - viele Hindernisse, unvorhersehbar
            HARD: {
                groundInterval: 1.6,    // Häufige Hindernisse (zwischen altem HARD und VERY_HARD)
                skyInterval: 1.8,       // Häufige Hindernisse
                randomVariation: 0.5,   // ±50% Variation für mehr Unvorhersehbarkeit
                independent: true,      // Boden und Luft unabhängig
                staggered: true,        // Versetzter Start
                randomTriggerChance: 0.004 // Mehr zufällige Spawns
            },
            // Sehr Schwer: Noch schwieriger als zuvor
            VERY_HARD: {
                groundInterval: 0.8,    // Extrem häufige Hindernisse (früher 1.0)
                skyInterval: 1.0,       // Extrem häufige Hindernisse (früher 1.2)
                randomVariation: 0.6,   // ±60% Variation für maximale Unvorhersehbarkeit
                independent: true,      // Boden und Luft völlig unabhängig
                staggered: false,       // Kein versetzter Start mehr für noch mehr Schwierigkeit
                randomTriggerChance: 0.008 // Häufige zufällige Spawns
            }
        };

        // --- Konsistente Hitbox-Größen für alle Schwierigkeitsstufen ---
        const HitboxSizes = {
            // Für alle Schwierigkeitsstufen sind die Hitboxen konsistent
            EASY: 0.65,       // 65% der visuellen Größe (sehr großzügig)
            NORMAL: 0.75,     // 75% der visuellen Größe (normal)
            HARD: 0.85,       // 85% der visuellen Größe (anspruchsvoll)
            VERY_HARD: 0.95   // 95% der visuellen Größe (sehr schwer)
        };

        // --- Flughöhen für fliegende Hindernisse ---
        // GEÄNDERT: Niedrigere Höhen für alle Schwierigkeitsgrade
        const FlyingHeights = {
            EASY: {
                heightFactor: 0.5,    // Mittlere Höhe (ursprünglich 0.3, jetzt tiefer)
                randomness: 0.3       // ±30% Zufallsvarianz
            },
            NORMAL: {
                heightFactor: 0.65,    // Etwas tiefer (ursprünglich 0.5, jetzt tiefer)
                randomness: 0.3       // ±30% Zufallsvarianz
            },
            HARD: {
                heightFactor: 0.8,    // Ziemlich tief (ursprünglich 0.7, jetzt tiefer)
                randomness: 0.2       // ±20% Zufallsvarianz
            },
            VERY_HARD: {
                heightFactor: 0.95,   // Sehr tief (nur durch Ducken zu vermeiden)
                randomness: 0.1       // ±10% Zufallsvarianz (konsistente Höhe)
            }
        };

        // --- Game Settings with difficulty levels ---
        let gameSettings = {
            // Standardeinstellungen, angepasst für besseres Spielerlebnis
            speedLevel: 'easy',           // Auf einfach gesetzt (vormals normal)
            jumpHeightLevel: 'easy',      // Auf einfach gesetzt (vormals normal)
            spawnRateLevel: 'easy',       // Auf einfach gesetzt (vormals normal)
            flyingHeightLevel: 'easy',    // Auf einfach gesetzt (vormals normal)
            hitboxSizeLevel: 'normal',    // Unverändert
            showHitboxes: false,          // Toggle für Hitbox-Visualisierung
            showBackgroundInfo: false     // Toggle für Hintergrund-Info
        };

        // Difficulty level values - ÜBERARBEITET für bessere Stufenverteilung
        const difficultyValues = {
            speed: {
                easy: 1.0,      // War vorher 'normal' (1.0), jetzt 'easy'
                normal: 1.3,    // War vorher 'hard' (1.3), jetzt 'normal'
                hard: 1.6,      // War vorher 'veryHard' (1.6), jetzt 'hard'
                veryHard: 2.0   // Neue noch höhere Schwierigkeit
            },
            jumpHeight: {
                easy: 1.0,      // War vorher 'normal', jetzt 'easy'
                normal: 0.85,   // Zwischen dem alten 'normal' und 'hard'
                hard: 0.75,     // Etwas leichter als das alte 'veryHard'
                veryHard: 0.65  // Noch schwieriger als zuvor
            },
            gravity: {
                easy: 1.0,      // War vorher 'normal', jetzt 'easy'
                normal: 1.15,   // Zwischen dem alten 'normal' und 'hard'
                hard: 1.3,      // Was vorher 'veryHard' war
                veryHard: 1.5   // Noch schwieriger als zuvor
            }
        };

        // --- Settings Control Functions ---
        function initializeSettings() {
            // Find all radio buttons for each setting type
            const speedRadios = document.querySelectorAll('input[name="speedSetting"]');
            const jumpRadios = document.querySelectorAll('input[name="jumpSetting"]');
            const spawnRadios = document.querySelectorAll('input[name="spawnSetting"]');
            const flyingHeightRadios = document.querySelectorAll('input[name="flyingHeightSetting"]');
            const hitboxSizeRadios = document.querySelectorAll('input[name="hitboxSizeSetting"]');

            // Set initial selections based on gameSettings
            setRadioByValue(speedRadios, gameSettings.speedLevel);
            setRadioByValue(jumpRadios, gameSettings.jumpHeightLevel);
            setRadioByValue(spawnRadios, gameSettings.spawnRateLevel);
            setRadioByValue(flyingHeightRadios, gameSettings.flyingHeightLevel);
            setRadioByValue(hitboxSizeRadios, gameSettings.hitboxSizeLevel);

            // Initialize hitbox visibility toggle
            if (showHitboxSetting) {
                showHitboxSetting.checked = gameSettings.showHitboxes;
                showHitboxSetting.addEventListener('change', (e) => {
                    gameSettings.showHitboxes = e.target.checked;

                    // Clear debug overlay if hitboxes are disabled
                    if (!gameSettings.showHitboxes && debugOverlay) {
                        debugOverlay.innerHTML = '';
                    }
                });
            }

            // Initialisiere Background-Info-Toggle
            if (showBackgroundInfoSetting) {
                showBackgroundInfoSetting.checked = gameSettings.showBackgroundInfo;
                showBackgroundInfoSetting.addEventListener('change', (e) => {
                    gameSettings.showBackgroundInfo = e.target.checked;

                    // Info-Anzeige ein- oder ausblenden
                    if (backgroundInfo) {
                        backgroundInfo.style.display = gameSettings.showBackgroundInfo ? 'block' : 'none';
                    }
                });
            }

            // Add event listeners to all radio buttons
            addRadioListeners(speedRadios, 'speedLevel');
            addRadioListeners(jumpRadios, 'jumpHeightLevel');
            addRadioListeners(spawnRadios, 'spawnRateLevel');
            addRadioListeners(flyingHeightRadios, 'flyingHeightLevel');
            addRadioListeners(hitboxSizeRadios, 'hitboxSizeLevel');
        }

        // Helper function to set a radio button by value
        function setRadioByValue(radios, value) {
            for (const radio of radios) {
                if (radio.value === value) {
                    radio.checked = true;
                    break;
                }
            }
        }

        // Helper function to add listeners to radio buttons
        function addRadioListeners(radios, settingName) {
            for (const radio of radios) {
                radio.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        gameSettings[settingName] = e.target.value;

                        // Apply settings if they changed during setup
                        if (currentState === GameState.READY) {
                            applyGameSettings();
                        }
                    }
                });
            }
        }

        function resetGameSettings() {
            gameSettings = {
                speedLevel: 'easy',          // Auf einfach gesetzt (vormals normal)
                jumpHeightLevel: 'easy',     // Auf einfach gesetzt (vormals normal)
                spawnRateLevel: 'easy',      // Auf einfach gesetzt (vormals normal)
                flyingHeightLevel: 'easy',   // Auf einfach gesetzt (vormals normal)
                hitboxSizeLevel: 'normal',   // Unverändert
                showHitboxes: false,
                showBackgroundInfo: false
            };

            // Update UI controls
            const speedRadios = document.querySelectorAll('input[name="speedSetting"]');
            const jumpRadios = document.querySelectorAll('input[name="jumpSetting"]');
            const spawnRadios = document.querySelectorAll('input[name="spawnSetting"]');
            const flyingHeightRadios = document.querySelectorAll('input[name="flyingHeightSetting"]');
            const hitboxSizeRadios = document.querySelectorAll('input[name="hitboxSizeSetting"]');

            setRadioByValue(speedRadios, 'easy');          // Geändert von 'normal'
            setRadioByValue(jumpRadios, 'easy');           // Geändert von 'normal'
            setRadioByValue(spawnRadios, 'easy');          // Geändert von 'normal'
            setRadioByValue(flyingHeightRadios, 'easy');   // Geändert von 'normal'
            setRadioByValue(hitboxSizeRadios, 'normal');   // Unverändert

            // Update hitbox checkbox
            if (showHitboxSetting) {
                showHitboxSetting.checked = false;
            }

            // Update background info checkbox
            if (showBackgroundInfoSetting) {
                showBackgroundInfoSetting.checked = false;
            }

            // Hide background info
            if (backgroundInfo) {
                backgroundInfo.style.display = 'none';
            }

            // Clear debug overlay
            if (debugOverlay) {
                debugOverlay.innerHTML = '';
            }

            // Apply settings
            if (currentState === GameState.READY) {
                applyGameSettings();
            }
        }

        function applyGameSettings() {
            // Get the appropriate multipliers based on difficulty levels
            const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];

            // Apply speed setting
            speed = baseSpeed * scaleFactor * speedMultiplier;

            // Other settings will be applied in their respective functions when needed
            // For example, jump height and gravity are applied in resetGame or when jumping
        }

        function toggleSettingsPanel() {
            if (currentState === GameState.SETTINGS) {
                // Close settings panel
                if (settingsPanel) settingsPanel.style.display = 'none';
                currentState = GameState.READY;
                updateUI();
            } else if (currentState === GameState.READY || currentState === GameState.GAMEOVER) {
                // Open settings panel
                if (settingsPanel) settingsPanel.style.display = 'flex';
                currentState = GameState.SETTINGS;
                updateUI();
            }
        }

        // --- Obstacle Definitions ---
        console.log("Defining obstacle data...");
        const ObstacleType = { PALLET_4: 'PALLET_4', PALLET_6: 'PALLET_6', LOG: 'LOG', STUMP: 'STUMP', STUMP_HIGH: 'STUMP_HIGH', OWL: 'OWL', FLYING_UNI: 'FLYING_UNI' };
        const obstacleData = { // Sorgfältig geprüft, korrekte Variablennamen verwendet
            [ObstacleType.PALLET_4]:   { img: pallet4Img,   baseWidth: 90 * globalSizeFactor,  baseHeight: 40 * globalSizeFactor, category: 'ground', level: 'LOW', hitboxOffsetX: 35 * globalSizeFactor },
            [ObstacleType.PALLET_6]:   { img: pallet6Img,   baseWidth: 90 * globalSizeFactor,  baseHeight: 60 * globalSizeFactor, category: 'ground', level: 'MED', hitboxOffsetX: 35 * globalSizeFactor },
            [ObstacleType.LOG]:        { img: logImg,       baseWidth: 100 * globalSizeFactor, baseHeight: 35 * globalSizeFactor, category: 'ground', level: 'LOW', hitboxOffsetX: 45 * globalSizeFactor },
            [ObstacleType.STUMP]:      { img: stumpImg,     baseWidth: 45 * globalSizeFactor,  baseHeight: 55 * globalSizeFactor, category: 'ground', level: 'MED', hitboxOffsetX: 10 * globalSizeFactor },
            [ObstacleType.STUMP_HIGH]: { img: stumpImg,     baseWidth: 45 * globalSizeFactor,  baseHeight: 55 * globalSizeFactor, category: 'ground', level: 'HIGH', isHigh: true, hitboxOffsetX: 10 * globalSizeFactor },
            [ObstacleType.OWL]:        { img: owlImg,       baseWidth: 60 * globalSizeFactor,  baseHeight: 50 * globalSizeFactor, category: 'sky', hitboxOffsetX: 10 * globalSizeFactor, hitboxOffsetY: 10 * globalSizeFactor },
            [ObstacleType.FLYING_UNI]: { img: flyingUniImg, baseWidth: 70 * globalSizeFactor,  baseHeight: 65 * globalSizeFactor, category: 'sky', hitboxOffsetX: 15 * globalSizeFactor, hitboxOffsetY: 15 * globalSizeFactor }
        }; // Syntax OK.
        const groundObstacleTypes = [ObstacleType.PALLET_4, ObstacleType.PALLET_6, ObstacleType.LOG, ObstacleType.STUMP];
        const skyObstacleTypes = [ObstacleType.OWL, ObstacleType.FLYING_UNI];
        console.log("Obstacle data defined.");

        // --- Game Loop ---
        let lastTime = 0; let animationFrameId = null; let gameTime = 0;

        // --- Initialization ---
        function init() {
            console.log(">>> init() started");
            if (!canvas || !ctx) { console.error("Init aborted: Canvas/Context missing."); return; }
            try {
                loadHighScore();
                initializeSettings();
                setupDOM();
                resizeCanvas();
                createHearts();
                resetGame();
                addEventListeners();
                currentState = GameState.READY;
                updateUI();
                lastTime = performance.now();
                if (!animationFrameId) animationFrameId = requestAnimationFrame(gameLoop);
                console.log("init: Animation loop started");
            } catch (error) {
                console.error("##### CRITICAL ERROR IN INIT #####", error);
                alert("Game Initialization Failed!");
            }
            console.log(">>> init() finished");
        }

        // --- Setup DOM ---
        function setupDOM() {
            if(highScoreElement) highScoreElement.textContent = highScore;
            if (duckButton) {
                 if (duckButtonImg.complete && duckButtonImg.naturalWidth > 0) { duckButton.innerHTML = ''; duckButton.appendChild(duckButtonImg.cloneNode()); }
                 else { duckButton.textContent = '↓'; if (!duckButtonImg.hasAttribute('data-onload-set')) { duckButtonImg.onload = () => { const btn = document.getElementById('duckButton'); if (btn) { btn.innerHTML = ''; btn.appendChild(duckButtonImg.cloneNode()); }}; duckButtonImg.setAttribute('data-onload-set', 'true'); } }
            }
            if(fuchsSelect) fuchsSelect.classList.toggle('selected', character === 'fuchs');
            if(waschbaerSelect) waschbaerSelect.classList.toggle('selected', character === 'waschbaer');

            // Setup für Hintergrund-Info
            if (backgroundInfo) {
                backgroundInfo.style.display = gameSettings.showBackgroundInfo ? 'block' : 'none';
            }
        }

        // --- ENHANCED: Resize Canvas with better orientation handling ---
        function resizeCanvas() {
            if (!gameContainer || !canvas) { return; }

            // Get new container dimensions
            const cw = gameContainer.clientWidth;
            const ch = gameContainer.clientHeight;
            if (cw === 0 || ch === 0) return;

            // Update canvas dimensions
            canvas.width = cw;
            canvas.height = ch;

            // Recalculate scale factor - crucial for correct hitbox positioning
            scaleFactor = (cw / baseWidth) * globalSizeFactor;
            groundHeight = 30 * scaleFactor;

            // Update player dimensions and position
            if (player && player.width) {
                const ps = 70; // Base player size
                const ss = ps * scaleFactor; // Scaled size

                // Make player width slimmer while keeping the height the same
                player.width = ss * playerWidthRatio;  // Slimmer width (90% of normal)
                player.baseHeight = ss;  // Normal height
                player.duckHeight = (ps/2) * scaleFactor;
                player.height = isDucking ? player.duckHeight : player.baseHeight;

                // IMPORTANT: Recalculate player X and Y position based on new dimensions
                player.x = 50 * scaleFactor;
                player.y = ch - groundHeight - player.height;

                // Apply gravity settings based on difficulty
                const gravityMultiplier = difficultyValues.gravity[gameSettings.jumpHeightLevel];
                player.gravity = baseGravity * scaleFactor * gravityMultiplier;

                // Apply jump height settings based on difficulty
                const jumpMultiplier = difficultyValues.jumpHeight[gameSettings.jumpHeightLevel];
                player.jumpStrength = baseJumpStrength * scaleFactor * jumpMultiplier;
            }

            // Update all obstacle positions and dimensions
            updateObstacleScaling();

            // Clear hitbox debug overlay
            if (debugOverlay) {
                debugOverlay.innerHTML = '';
            }

            // Force redraw
            if (currentState !== GameState.PLAYING) {
                draw();
            }
        }

        // --- NEW FUNCTION: Update obstacle scaling when orientation/size changes ---
        function updateObstacleScaling() {
            // Update existing obstacles to match new scale
            for (const obstacle of obstacles) {
                const data = obstacleData[obstacle.type];
                if (!data) continue;

                // Recalculate scaled dimensions
                const scaledWidth = data.baseWidth * scaleFactor;
                const scaledHeight = data.baseHeight * scaleFactor;

                // Calculate position ratio (how far across screen, as percentage)
                const positionRatio = obstacle.x / canvas.width;

                // Update obstacle with new dimensions
                obstacle.width = scaledWidth;
                obstacle.height = scaledHeight;

                // Calculate Y position based on category
                if (data.category === 'ground') {
                    obstacle.y = canvas.height - groundHeight - scaledHeight;
                    // Optional height adjustment for special types
                    if (data.isHigh) {
                        obstacle.y -= 20 * scaleFactor;
                    }
                } else {
                    // For flying obstacles, maintain their relative height position
                    const heightRatio = (canvas.height - obstacle.y - obstacle.height) / canvas.height;
                    obstacle.y = canvas.height - (heightRatio * canvas.height) - scaledHeight;
                }
            }
        }

        // --- NEW FUNCTION: Orientation change handler ---
        function handleOrientationChange(e) {
            // Log orientation change for debugging
            console.log("Orientation changed!");

            // Add small delay to ensure dimensions are updated after rotation completes
            setTimeout(() => {
                console.log("Applying orientation change adjustments");

                // Do a full resize with complete recalculation
                resizeCanvas();

                // Force collision check after resize
                if(currentState === GameState.PLAYING) {
                    checkCollision();
                }
            }, 100);
        }

        // --- High Score, Hearts ---
        function loadHighScore() { try{const s=localStorage.getItem('pixelRunnerHighScore');highScore=s?parseInt(s):0;}catch(e){highScore=0;} }
        function saveHighScore() { const fs=Math.floor(score/10);if(fs>highScore){highScore=fs;try{localStorage.setItem('pixelRunnerHighScore',highScore);if(highScoreElement)highScoreElement.textContent=highScore;}catch(e){}} }

        // --- Verbesserte Herz-Anzeige ---
        function createHearts() {
            if(!livesDisplay) return;

            // Container leeren
            livesDisplay.innerHTML = '';
            console.log("Herzen werden erstellt, maxLives:", maxLives);

            // Herzen mit korrekter Initialisierung erstellen
            for (let i = 0; i < maxLives; i++) {
                const h = document.createElement('span');
                h.classList.add('heart');
                h.innerHTML = '♥';
                h.setAttribute('data-index', i); // Index für Debugging hinzufügen

                // Herzen standardmäßig sichtbar machen
                h.style.visibility = 'visible';
                h.style.opacity = '1';
                h.style.transform = 'scale(1)';

                livesDisplay.appendChild(h);
                console.log(`Herz ${i} erstellt`);
            }

            // Anzeige sofort aktualisieren
            updateLivesDisplay();
        }

        // --- DEUTLICH VERBESSERTE Lebenanzeigeaktualisierung ---
        function updateLivesDisplay() {
            if(!livesDisplay) {
                console.error("Fehler: livesDisplay Element nicht gefunden!");
                return;
            }

            console.log("Herz-Anzeige wird aktualisiert, aktuelle Leben:", lives);

            // Container zuerst leeren und dann neu aufbauen für konsistenten Zustand
            livesDisplay.innerHTML = '';

            // Herzen neu erstellen, um eine zuverlässige Anzeige zu garantieren
            for (let i = 0; i < maxLives; i++) {
                const heart = document.createElement('span');
                heart.className = 'heart';
                heart.innerHTML = '♥';
                heart.setAttribute('data-index', i);

                // Herz sofort korrekt anzeigen oder verstecken
                if (i >= lives) {
                    heart.classList.add('hidden');
                    console.log(`Herz ${i} direkt versteckt erstellt`);
                } else {
                    console.log(`Herz ${i} sichtbar erstellt`);
                }

                livesDisplay.appendChild(heart);
            }

            // Feedback zu den aktuellen Herzen in der Konsole
            console.log(`Herzanzeige aktualisiert: ${lives}/${maxLives} Leben`);
        }

        // --- resetGame - Verbessert für Timer und Einstellungen ---
        function resetGame() {
            console.log("resetGame: Running...");
            if (!canvas || !ctx) { console.error("resetGame: Canvas/Context missing."); return; }
            score=0;
            gameTime=0;

            // Apply speed setting based on difficulty level
            const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];
            speed = baseSpeed * scaleFactor * speedMultiplier;

            backgroundX=0;
            lives=maxLives;
            isDucking=false;
            isNight=false;

            // FIXED: Reset invulnerability properly
            resetInvulnerability();

            obstacles=[];
            clouds=[];

            // --- Verbesserte Timer-Initialisierung mit 4-Stufen-System ---
            const spawnRules = getSpawnRules(gameSettings.spawnRateLevel);

            // Haupt-Timer
            obstacleTimer = initialObstacleCooldown;

            // Zufällige Startzeiten für alle Timer basierend auf Regelwerk
            const baseGround = initialObstacleCooldown * (0.8 + Math.random() * 0.4);
            const baseSky = initialObstacleCooldown * (0.7 + Math.random() * 0.5);

            groundObstacleTimer = baseGround;
            skyObstacleTimer = spawnRules.staggered ? baseGround + (spawnRules.groundInterval / 2) : baseSky;

            // Sekundäre Timer mit weiteren zufälligen Offsets
            groundObstacleTimerOffset = baseGround * 0.5 + Math.random() * baseGround * 0.5;
            skyObstacleTimerOffset = baseSky * 0.5 + Math.random() * baseSky * 0.5;

            cloudTimer = (2 + Math.random() * 3);

            const ps = 70 * globalSizeFactor; // Base player size
            const ss = ps * scaleFactor; // Scaled size
            const ch = canvas.height || 0;
            if (ch <= 0) return;

            // Apply gravity and jump settings based on difficulty
            const gravityMultiplier = difficultyValues.gravity[gameSettings.jumpHeightLevel];
            const jumpMultiplier = difficultyValues.jumpHeight[gameSettings.jumpHeightLevel];

            player = {
                x: 50 * scaleFactor,
                y: ch - groundHeight - ss,
                width: ss * playerWidthRatio, // Slimmer width (90% of normal)
                height: ss,
                baseHeight: ss,
                duckHeight: (ps/2) * scaleFactor,
                vy: 0,
                // Apply gravity and jump settings
                gravity: baseGravity * scaleFactor * gravityMultiplier,
                jumpStrength: baseJumpStrength * scaleFactor * jumpMultiplier,
                jumping: false,
                canDoubleJump: false,
                hasDoubleJumped: false,
                image: (character === 'fuchs' ? fuchsImg : waschbaerImg)
            };

            if(!(player.image && player.image.complete && player.image.naturalWidth>0)) { /* Warnung möglich */ }
            if(document.body) document.body.style.backgroundColor = '#e0e0e0'; // Start mit hellem Body-BG

            // Clear hitbox debug overlay
            if (debugOverlay) {
                debugOverlay.innerHTML = '';
            }

            // Leben-Anzeige aktualisieren
            updateLivesDisplay();

            console.log("resetGame: Finished. Lives:", lives, "Invulnerable:", isInvulnerable);
        }

        // --- NEUE FUNKTION: Setzt die Unverwundbarkeit zurück ---
        // --- ROBUSTE FUNKTION zum Zurücksetzen der Unverwundbarkeit ---
        function resetInvulnerability() {
            console.log("### UNVERWUNDBARKEIT WIRD VOLLSTÄNDIG ZURÜCKGESETZT ###");

            // Status eindeutig setzen
            isInvulnerable = false;

            // Timer sauber entfernen
            if (invulnerabilityTimer) {
                console.log("Bestehender Unverwundbarkeits-Timer wird gelöscht");
                clearTimeout(invulnerabilityTimer);
                invulnerabilityTimer = null;
            }

            // Alle visuellen Indikatoren entfernen
            if (gameContainer) {
                const indicators = gameContainer.querySelectorAll('.player-invulnerable-indicator');
                if (indicators.length > 0) {
                    console.log(`${indicators.length} Unverwundbarkeits-Indikatoren werden entfernt`);
                    indicators.forEach(indicator => {
                        if (indicator.parentNode) {
                            indicator.parentNode.removeChild(indicator);
                        }
                    });
                }
            }

            console.log("Unverwundbarkeit erfolgreich zurückgesetzt");
        }

        // --- Hilfsfunktion für Spawn-Regeln basierend auf Schwierigkeitsgrad ---
        function getSpawnRules(difficultyLevel) {
            switch(difficultyLevel) {
                case 'easy': return SpawnRules.EASY;
                case 'normal': return SpawnRules.NORMAL;
                case 'hard': return SpawnRules.HARD;
                case 'veryHard': return SpawnRules.VERY_HARD;
                default: return SpawnRules.NORMAL;
            }
        }

        // --- Hilfsfunktion für Hitbox-Größen basierend auf Schwierigkeitsgrad ---
        function getHitboxSize(difficultyLevel) {
            switch(difficultyLevel) {
                case 'easy': return HitboxSizes.EASY;
                case 'normal': return HitboxSizes.NORMAL;
                case 'hard': return HitboxSizes.HARD;
                case 'veryHard': return HitboxSizes.VERY_HARD;
                default: return HitboxSizes.NORMAL;
            }
        }

        // --- Hilfsfunktion für Flughöhen basierend auf Schwierigkeitsgrad ---
        function getFlyingHeight(difficultyLevel) {
            switch(difficultyLevel) {
                case 'easy': return FlyingHeights.EASY;
                case 'normal': return FlyingHeights.NORMAL;
                case 'hard': return FlyingHeights.HARD;
                case 'veryHard': return FlyingHeights.VERY_HARD;
                default: return FlyingHeights.NORMAL;
            }
        }

        // --- Game Logic ---
        function startGame() {
            if(currentState===GameState.PLAYING) return;
            console.log("Starting Game...");
            resetGame();
            currentState=GameState.PLAYING;
            updateUI();
            lastTime=performance.now();
            if(!animationFrameId) animationFrameId=requestAnimationFrame(gameLoop);
        }

        // --- VERBESSERTE loseLife-Funktion mit zuverlässiger Animation ---
        function loseLife() {
            // Ausführliche Debug-Ausgabe
            console.log("### loseLife AUFGERUFEN ###");
            console.log("Leben:", lives, "Unverwundbar:", isInvulnerable, "Status:", currentState);

            // Nichts tun, wenn bereits unverwundbar oder nicht im Spiel
            if(isInvulnerable || currentState !== GameState.PLAYING) {
                console.log("Kein Leben verloren - Spieler ist unverwundbar oder nicht im Spiel");
                return;
            }

            // Leben reduzieren
            lives = Math.max(0, lives - 1); // Verhindert negative Leben
            console.log("LEBEN VERLOREN! Verbleibende Leben:", lives);

            // Herzen-Anzeige sofort aktualisieren - VERBESSERT
            updateLivesDisplay();

            // Spieler unverwundbar machen
            makePlayerInvulnerable();

            // Visuelles Feedback für Treffer
            if(gameContainer) {
                // Spielcontainer-Rand rot färben
                gameContainer.style.borderColor='#ff0000';

                // Bildschirm rot aufblitzen lassen
                const flashEffect = document.createElement('div');
                flashEffect.className = 'damage-flash'; // Klasse für einfachere Identifikation
                flashEffect.style.position = 'absolute';
                flashEffect.style.top = '0';
                flashEffect.style.left = '0';
                flashEffect.style.width = '100%';
                flashEffect.style.height = '100%';
                flashEffect.style.backgroundColor = 'rgba(255,0,0,0.3)';
                flashEffect.style.pointerEvents = 'none';
                flashEffect.style.zIndex = '20';
                flashEffect.style.animation = 'fadeOut 0.5s forwards';

                // fadeOut-Animation hinzufügen, falls nicht vorhanden
                if (!document.getElementById('flashAnimation')) {
                    const style = document.createElement('style');
                    style.id = 'flashAnimation';
                    style.textContent = '@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }';
                    document.head.appendChild(style);
                }

                // Alte Flash-Effekte entfernen
                const oldFlashes = gameContainer.querySelectorAll('.damage-flash');
                oldFlashes.forEach(flash => {
                    if (flash.parentNode) flash.parentNode.removeChild(flash);
                });

                // Neuen Flash-Effekt hinzufügen
                gameContainer.appendChild(flashEffect);

                // Nach kurzer Zeit zurücksetzen
                setTimeout(() => {
                    if(gameContainer) {
                        gameContainer.style.borderColor = '#333';
                        if (flashEffect.parentNode) {
                            flashEffect.parentNode.removeChild(flashEffect);
                        }
                    }
                }, 200);
            }

            // Game Over, wenn keine Leben mehr übrig
            if(lives <= 0) {
                console.log("GAME OVER ausgelöst! Keine Leben mehr übrig.");
                gameOver();
            }
        }

        function gameOver() {
            currentState=GameState.GAMEOVER;
            saveHighScore();
            if(finalScoreElement) finalScoreElement.textContent=Math.floor(score/10);
            updateUI();
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId=null;
        }

        // --- KOMPLETT ÜBERARBEITETE ZUVERLÄSSIGE Unverwundbarkeits-Funktion ---
        function makePlayerInvulnerable() {
            console.log("### SPIELER WIRD UNVERWUNDBAR GEMACHT ###");

            // Status eindeutig setzen
            isInvulnerable = true;

            // Alten Timer sauber entfernen
            if (invulnerabilityTimer) {
                console.log("Alter Unverwundbarkeits-Timer wird gelöscht");
                clearTimeout(invulnerabilityTimer);
                invulnerabilityTimer = null;
            }

            // Visuellen Indikator aktivieren
            if (player) {
                // Zusätzliche visuelle Anzeige direkt am Spieler
                const playerFlash = document.createElement('div');
                playerFlash.className = 'player-invulnerable-indicator';
                playerFlash.style.position = 'absolute';
                playerFlash.style.left = `${player.x}px`;
                playerFlash.style.top = `${player.y}px`;
                playerFlash.style.width = `${player.width}px`;
                playerFlash.style.height = `${player.height}px`;
                playerFlash.style.border = '2px solid yellow';
                playerFlash.style.borderRadius = '50%';
                playerFlash.style.boxShadow = '0 0 10px yellow';
                playerFlash.style.animation = 'pulsate 0.5s infinite alternate';
                playerFlash.style.pointerEvents = 'none';
                playerFlash.style.zIndex = '11';

                // Pulsier-Animation für Unverwundbarkeit
                if (!document.getElementById('pulsateAnimation')) {
                    const style = document.createElement('style');
                    style.id = 'pulsateAnimation';
                    style.textContent = '@keyframes pulsate { 0% { opacity: 0.3; } 100% { opacity: 0.7; } }';
                    document.head.appendChild(style);
                }

                if (gameContainer) {
    // Alten Indikator entfernen falls vorhanden
    const oldIndicator = gameContainer.querySelector('.player-invulnerable-indicator');
    if (oldIndicator && oldIndicator.parentNode) {
        oldIndicator.parentNode.removeChild(oldIndicator);
    }

    gameContainer.appendChild(playerFlash);
}

console.log("Unverwundbarkeits-Effekte angewendet");
}

// Neuen Timer setzen - mit Darstellung der verbleibenden Zeit
console.log(`Starte Unverwundbarkeit für ${invulnerabilityDuration/1000} Sekunden`);
let timeLeft = invulnerabilityDuration;

// Erstelle eine Funktion, die die Unverwundbarkeit beendet
const endInvulnerability = () => {
    console.log("### UNVERWUNDBARKEIT BEENDET ###");
    isInvulnerable = false;
    invulnerabilityTimer = null;

    // Entferne den visuellen Indikator
    if (gameContainer) {
        const indicator = gameContainer.querySelector('.player-invulnerable-indicator');
        if (indicator && indicator.parentNode) {
            indicator.parentNode.removeChild(indicator);
        }
    }
};

// Verwende einen robusten Timer
invulnerabilityTimer = setTimeout(endInvulnerability, invulnerabilityDuration);

console.log(`Unverwundbarkeits-Timer gesetzt für ${invulnerabilityDuration}ms`);
}

function togglePause() {
    if(currentState===GameState.PLAYING){
        currentState=GameState.PAUSED;
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId=null;
    } else if(currentState===GameState.PAUSED){
        currentState=GameState.PLAYING;
        lastTime=performance.now();
        animationFrameId=requestAnimationFrame(gameLoop);
    }
    updateUI();
}

function quitGame() {
    if(currentState===GameState.PLAYING||currentState===GameState.PAUSED) saveHighScore();
    alert("Game ended.");
    try{window.close();}catch(e){}
    currentState=GameState.GAMEOVER;
    if(animationFrameId) cancelAnimationFrame(animationFrameId);
    animationFrameId=null;
    updateUI();
}

// Back to Menu Function
function backToMenu() {
    if (currentState === GameState.PLAYING || currentState === GameState.PAUSED) {
        saveHighScore();
        currentState = GameState.READY;
        resetGame();
        updateUI();
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        animationFrameId = requestAnimationFrame(gameLoop);
    }
}

function jump() {
    if(currentState!==GameState.PLAYING||isDucking||!player||typeof player.vy==='undefined') return;
    if(!player.jumping){
        player.vy = player.jumpStrength;
        player.jumping=true;
        player.canDoubleJump=true;
        player.hasDoubleJumped=false;
    } else if(player.canDoubleJump&&!player.hasDoubleJumped){
        player.vy = player.jumpStrength * 0.8;
        player.canDoubleJump=false;
        player.hasDoubleJumped=true;
        createDoubleJumpEffect();
    }
}

function setDucking(sd) {
    if(currentState!==GameState.PLAYING||player.jumping||!player||typeof player.height==='undefined') return;
    if(sd&&!isDucking){
        isDucking=true;
        player.height=player.duckHeight;
        player.y=canvas.height-groundHeight-player.height;
    } else if(!sd&&isDucking){
        isDucking=false;
        player.height=player.baseHeight;
        player.y=canvas.height-groundHeight-player.height;
        checkCollision();
    }
}

function createDoubleJumpEffect() {
    try{
        if(!player||!player.width) return;
        const s=player.width*1.2;
        const e=document.createElement('div');
        e.className='doubleJumpEffect';
        const cr=gameContainer.getBoundingClientRect();
        const cvr=canvas.getBoundingClientRect();
        const ox=cvr.left-cr.left;
        const oy=cvr.top-cr.top;
        e.style.width=`${s}px`;
        e.style.height=`${s}px`;
        e.style.left=`${ox+player.x+player.width/2-s/2}px`;
        e.style.top=`${oy+player.y+player.height/2-s/2}px`;
        if(gameContainer) gameContainer.appendChild(e);
        setTimeout(()=>{if(e.parentNode)e.remove();},400);
    }catch(err){}
}

// --- createObstacle - Verbessert für verschiedene Schwierigkeitsgrade und tiefere Flughöhe ---
function createObstacle(category = null) {
    try {
        let chosenType = null;
        let availableGroundTypes = [...groundObstacleTypes]; // Kopie der Basis-Bodentypen

        // Hohen Baumstumpf hinzufügen, wenn Zeit abgelaufen
        if (gameTime > highStumpMinTime) {
            availableGroundTypes.push(ObstacleType.STUMP_HIGH);
        }

        // Wenn keine Kategorie angegeben ist, zufällig entscheiden
        if (category === null) {
            category = Math.random() < 0.70 ? 'ground' : 'sky';
        }

        if (category === 'ground') {
            const randIdx = Math.floor(Math.random() * availableGroundTypes.length);
            chosenType = availableGroundTypes[randIdx];
        } else {
            const randIdx = Math.floor(Math.random() * skyObstacleTypes.length);
            chosenType = skyObstacleTypes[randIdx];
        }

        const data = obstacleData[chosenType];
        if (!data) { console.error("Obstacle data missing for type:", chosenType); return; } // Sicherheitscheck

        const scaledWidth = data.baseWidth * scaleFactor;
        const scaledHeight = data.baseHeight * scaleFactor;
        let yPos;

        if (data.category === 'ground') {
            yPos = canvas.height - groundHeight - scaledHeight;
            // Optional: Leichte Höhenanpassung für spezielle Typen hier möglich
            if (data.isHigh) { yPos -= 20 * scaleFactor; } // Höhenjustierung für STUMP_HIGH
        } else { // Positionierung von Flug-Hindernissen
            // Flughöhen-Einstellungen abrufen
            const flyingHeightSettings = getFlyingHeight(gameSettings.flyingHeightLevel);

            // Basiswerte - VOLLSTÄNDIG ANGEPASST für deutlich tiefere Flugobjekte
            const minTopMargin = 30 * scaleFactor; // STARK REDUZIERT: Von 120 auf 80, dann auf 50, jetzt auf 30 für extrem tiefe Flughöhen
            const playerClearance = player.baseHeight ? player.baseHeight * 0.7 : 40 * scaleFactor; // NOCHMALS REDUZIERT: von 1.3 auf 1.1, dann auf 0.9, jetzt auf 0.7
            const safeSkyBottom = canvas.height - groundHeight - playerClearance; // Untere Grenze noch tiefer angesetzt
            const duckHeight = player.duckHeight || (player.baseHeight * 0.5);

            // Gesamthöhenbereich berechnen
            const totalHeight = safeSkyBottom - minTopMargin;

            // Höhenfaktor und Zufallsbereich anwenden
            const heightFactor = flyingHeightSettings.heightFactor;
            const randomness = flyingHeightSettings.randomness;

            // Bei "Sehr Schwer" spezielle Logik für Duck-Höhe
            if (gameSettings.flyingHeightLevel === 'veryHard') {
                // Höhe berechnen, die Ducken erforderlich macht
                const duckRequiredY = canvas.height - groundHeight - player.baseHeight + (player.baseHeight - duckHeight) / 2;
                yPos = duckRequiredY - (scaledHeight / 2); // Objekt in Duck-Höhe zentrieren
            } else {
                // Normale Höhenberechnung für andere Schwierigkeitsgrade
                yPos = minTopMargin + (totalHeight * heightFactor);
            }

            // Zufälligkeit hinzufügen, umgekehrt proportional zum Schwierigkeitsgrad
            const randomRange = totalHeight * randomness;
            yPos += (Math.random() - 0.5) * randomRange;

            // Sicherstellen, dass wir im sicheren Bereich bleiben
            yPos = Math.max(minTopMargin, Math.min(safeSkyBottom - scaledHeight, yPos));
        }

        // Hindernis mit allen erforderlichen Informationen erstellen
        console.log(`Erstelle ${chosenType} Hindernis auf Position ${yPos}`);
        obstacles.push({
            x: canvas.width, // Start rechts außerhalb
            y: yPos,
            width: scaledWidth,
            height: scaledHeight,
            type: chosenType,
            image: data.img, // Referenz auf das Image-Objekt speichern
            category: data.category // Kategorie speichern für spätere Logik
        });
    } catch(err) {
         console.error("Fehler in createObstacle:", err);
    }
}

// --- createCloud - Mit angepasster Y-Position
function createCloud() {
    const bw = 60 * globalSizeFactor;
    const bh = 30 * globalSizeFactor;
    const sw = bw * scaleFactor;
    const sh = bh * scaleFactor;
    clouds.push({
        x: canvas.width,
        // --- HIER DIE ÄNDERUNG FÜR WOLKEN ---
        y: (30 + Math.random() * 80) * scaleFactor, // << GEÄNDERT: Startet tiefer und hat größeren Bereich nach unten
        // --- ENDE ÄNDERUNG ---
        width: sw,
        height: sh,
        speed: (baseSpeed * (0.2 + Math.random() * 0.3)) * scaleFactor * difficultyValues.speed[gameSettings.speedLevel]
    });
}

// --- Update ---
function update(dt) {
    if(currentState!==GameState.PLAYING) return;
    gameTime+=dt;
    updatePlayer(dt);
    updateObstacles(dt);
    updateClouds(dt);
    updateScore(dt);
    updateBackground(dt);
    updateDifficulty(dt);

    // Zeitanzeige aktualisieren, wenn aktiviert
    if (gameSettings.showBackgroundInfo && backgroundInfo && currentMinuteElement) {
        const currentMinutes = Math.floor(gameTime / 60);
        currentMinuteElement.textContent = currentMinutes;
    }

    // Kollisionsprüfung am Ende des Update-Zyklus
    checkCollision();
}

function updatePlayer(dt) {
    if(!player||typeof player.vy==='undefined') return;
    player.vy += player.gravity * dt;
    player.y += player.vy * dt;
    const gl = canvas.height - groundHeight - player.height;
    if(player.y >= gl){
        player.y = gl;
        player.vy = 0;
        if(player.jumping){
            player.jumping = false;
            player.canDoubleJump = false;
            player.hasDoubleJumped = false;
            setDucking(isDucking);
        }
    }
}

// --- updateObstacles - Verbessert mit 4-Stufen-System ---
function updateObstacles(dt) {
    // Erst die bestehenden Hindernisse aktualisieren
    for(let i=obstacles.length-1; i>=0; i--){
        // Geschwindigkeit basierend auf Schwierigkeitsgrad anwenden
        obstacles[i].x -= speed * dt;
        if(obstacles[i].x + obstacles[i].width < 0) obstacles.splice(i, 1);
    }

    // Spawn-Regeln für aktuellen Schwierigkeitsgrad abrufen
    const spawnRules = getSpawnRules(gameSettings.spawnRateLevel);

    // --- Je nach Schwierigkeitsgrad unterschiedliche Spawn-Logik verwenden ---

    // Gemeinsamer Timer für einfache Schwierigkeitsgrade
    if (!spawnRules.independent) {
        // Für leichtere Schwierigkeitsgrade: alternierendes System mit etwas Zufall
        obstacleTimer -= dt;

        // Kleine Zufallschance für Spawns unabhängig vom Timer
        const randomSpawn = Math.random() < spawnRules.randomTriggerChance;

        if (obstacleTimer <= 0 || randomSpawn) {
            // Bei einfacheren Levels ist die Auswahl halbwegs vorhersehbar
            let nextType;

            // Manchmal Zufall, manchmal Alternieren
            if (Math.random() < 0.3) {
                // Zufällige Auswahl mit Tendenz zu mehr Boden-Hindernissen
                nextType = Math.random() < 0.6 ? 'ground' : 'sky';
            } else {
                // Alternierendes Muster für etwas Vorhersehbarkeit
                if (obstacles.length > 0) {
                    const lastObstacle = obstacles[obstacles.length-1];
                    nextType = lastObstacle.category === 'ground' ? 'sky' : 'ground';
                } else {
                    nextType = 'ground';
                }
            }

            // Hindernis erstellen
            createObstacle(nextType);

            // Interval basierend auf Schwierigkeitsgrad setzen
            let baseInterval = nextType === 'ground' ? spawnRules.groundInterval : spawnRules.skyInterval;

            // Zufallsvarianz hinzufügen
            const variance = baseInterval * spawnRules.randomVariation;
            obstacleTimer = baseInterval + ((Math.random() * 2 - 1) * variance);
        }
    }
    // Unabhängige Timer für schwerere Schwierigkeitsgrade
    else {
        // Unabhängige Timer für Boden- und Flug-Hindernisse

        // Boden-Hindernis-Timer
        groundObstacleTimer -= dt;
        groundObstacleTimerOffset -= dt;

        // Wenn ein Boden-Timer 0 erreicht, ein Boden-Hindernis spawnen
        if (groundObstacleTimer <= 0 || groundObstacleTimerOffset <= 0 || Math.random() < spawnRules.randomTriggerChance) {
            // Manchmal kein Spawn trotz Timer-Auslösung (für mehr Unvorhersehbarkeit)
            if (Math.random() < 0.9) {
                createObstacle('ground');
            }

            // Zufällige neue Zeiten berechnen
            const baseTime = spawnRules.groundInterval;
            const variance = baseTime * spawnRules.randomVariation;

            // Den ausgelösten Timer zurücksetzen
            if (groundObstacleTimer <= 0) {
                groundObstacleTimer = baseTime + ((Math.random() * 2 - 1) * variance);
            }
            if (groundObstacleTimerOffset <= 0) {
                groundObstacleTimerOffset = baseTime + ((Math.random() * 2 - 1) * variance);
            }
        }

        // Flug-Hindernis-Timer
        skyObstacleTimer -= dt;
        skyObstacleTimerOffset -= dt;

        // Wenn ein Flug-Timer 0 erreicht, ein Flug-Hindernis spawnen
        if (skyObstacleTimer <= 0 || skyObstacleTimerOffset <= 0 || Math.random() < spawnRules.randomTriggerChance) {
            // Manchmal kein Spawn trotz Timer-Auslösung
            if (Math.random() < 0.9) {
                createObstacle('sky');
            }

            // Zufällige neue Zeiten berechnen
            const baseTime = spawnRules.skyInterval;
            const variance = baseTime * spawnRules.randomVariation;

            // Den ausgelösten Timer zurücksetzen
            if (skyObstacleTimer <= 0) {
                skyObstacleTimer = baseTime + ((Math.random() * 2 - 1) * variance);
            }
            if (skyObstacleTimerOffset <= 0) {
                skyObstacleTimerOffset = baseTime + ((Math.random() * 2 - 1) * variance);
            }
        }
    }
}

function updateClouds(dt) {
    for(let i=clouds.length-1; i>=0; i--){
        clouds[i].x -= clouds[i].speed * dt;
        if(clouds[i].x + clouds[i].width < 0) clouds.splice(i, 1);
    }
    cloudTimer -= dt;
    if(cloudTimer <= 0 && clouds.length < 5){
        createCloud();
        // Cloud spawn rate is simpler and less affected by difficulty
        cloudTimer = 3 + Math.random() * 5;
    }
}

function updateScore(dt) {
    if(!scoreElement) return;
    // Apply speed setting to score calculation
    const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];
    score += (speed / scaleFactor) * dt * 0.1;
    scoreElement.textContent = Math.floor(score/10);
}

// --- <<< ÜBERARBEITETE HILFSFUNKTION FÜR HINTERGRUNDBILD (MIT LOOPING) >>> ---
        function getCurrentBackground() {
            // Array der Hintergrundbilder in der gewünschten Reihenfolge
            const backgroundImages = [
                dayBgImg,    // Minute 1 (Index 0)
                nightBgImg,  // Minute 2 (Index 1)
                dayBgImg1,   // Minute 3 (Index 2)
                nightBgImg1  // Minute 4 (Index 3)
            ];

            // Berechne die *ganzen* vergangenen Minuten
            const minutesPassed = Math.floor(gameTime / 60);

            // Berechne den Index mit Modulo 4, um durch 0, 1, 2, 3 zu loopen
            const backgroundIndex = minutesPassed % 4;

            // Gib das entsprechende Bild aus dem Array zurück
            // Füge einen Fallback hinzu, falls der Index ungültig ist (sollte nicht passieren)
            return backgroundImages[backgroundIndex] || dayBgImg; // Fallback auf das erste Bild
        }
        // --- <<< ENDE ÜBERARBEITETE HILFSFUNKTION >>> ---


        // --- updateDifficulty - `isNight` jetzt ZEITBASIERT statt Score-basiert ---
        function updateDifficulty(dt) {
            // Get the speed multiplier from settings
            const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];

            // Apply speed increment based on speed setting and game progress
            speed += (speedIncrement * baseSpeed) * scaleFactor * speedMultiplier * dt;

            // --- `isNight`-Logik basierend auf dem AKTUELLEN HINTERGRUND-INDEX ---
            const minutesPassed = Math.floor(gameTime / 60);
            const backgroundIndex = minutesPassed % 4;
            const shouldBeNight = (backgroundIndex === 1 || backgroundIndex === 3); // Indizes 1 und 3 sind Nacht

            if (shouldBeNight !== isNight) {
                isNight = shouldBeNight;
                console.log(`Setting theme based on time: ${isNight ? 'Night' : 'Day'} (Minute: ${minutesPassed + 1}, Index: ${backgroundIndex})`);
                if (document.body) {
                    document.body.style.backgroundColor = isNight ? '#2d2d3a' : '#e0e0e0';
                }
                // Optional: Hier könnten auch Wolken- und Bodenfarben direkt aktualisiert werden,
                // aber sie werden ohnehin in jedem Draw-Frame neu gezeichnet.
            }
            // --- Ende `isNight`-Logik ---
            // Flughöhen-Logik basierend auf Schwierigkeitsgrad und Spielzeit (bleibt wie es war)
            const flyingHeightSettings = getFlyingHeight(gameSettings.flyingHeightLevel);
            const timeInMinutes = gameTime / 60; // Exakte Zeit für feinere Anpassungen

            // Dynamische Anpassung der Flughöhe (Beispiel bleibt gleich)
            if (gameSettings.flyingHeightLevel !== 'veryHard') {
                const adjustmentFactor = Math.min(0.2, (timeInMinutes - 1.0) * 0.05);
                if (adjustmentFactor > 0) {
                    // Hole die ursprüngliche Basishöhe für diesen Schwierigkeitsgrad
                    const baseHeightFactor = FlyingHeights[gameSettings.flyingHeightLevel].heightFactor;
                    // Passe sie an, aber nicht über 0.95 und nicht unter 0.1
                    flyingHeightSettings.heightFactor = Math.min(0.95, Math.max(0.1, baseHeightFactor + adjustmentFactor));
                }
            }
        }

// --- updateDifficulty - Mit konsistenter Hitbox und dynamischer Geschwindigkeit ---
function updateDifficulty(dt) {
    // Get the speed multiplier from settings
    const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];

    // Apply speed increment based on speed setting and game progress
    speed += (speedIncrement * baseSpeed) * scaleFactor * speedMultiplier * dt;

    // Base night/day logic
    const timeMinutes = gameTime / 60;
    const cycleMinutes = timeMinutes % 5; // 5-Minuten-Zyklus

    // Hier ist eine einfachere Logik, die auf der Minute basiert
    if (cycleMinutes < 1) {
        // Minute 0-1: Tag mit Tag_BG.webp
        isNight = false;
    } else if (cycleMinutes < 2) {
        // Minute 1-2: Nacht mit Nacht_BG.webp
        isNight = true;
    } else if (cycleMinutes < 3) {
        // Minute 2-3: Tag mit Tag_BG_v4.webp (wird in drawBackground gehandhabt)
        isNight = false;
    } else if (cycleMinutes < 4) {
        // Minute 3-4: Nacht mit Nacht_BG_v4.webp (wird in drawBackground gehandhabt)
        isNight = true;
    } else {
        // Minute 4-5: Übergangsphase oder einfach zurück zu Tag
        isNight = false;
    }

    // Body-Hintergrundfarbe basierend auf Tag/Nacht aktualisieren
    if (document.body) {
        document.body.style.backgroundColor = isNight ? '#2d2d3a' : '#e0e0e0';
    }
}

// --- updateBackground - Nutzt neue BG Logik ---
function updateBackground(dt) {
    // Hintergrundbewegung aktualisieren
    const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];
    backgroundX -= (speed * 0.3) * dt;

    // Bestimmen der verfügbaren Breite für den Hintergrund
    const h = canvas.height;
    let img;

    // Auswahl des richtigen Hintergrundbildes basierend auf der Spielzeit
    const timeMinutes = gameTime / 60;
    const cycleMinutes = timeMinutes % 5; // 5-Minuten-Zyklus

    if (cycleMinutes < 1) {
        // Minute 0-1: Originale Hintergrundbilder
        img = isNight ? nightBgImg : dayBgImg;
    } else if (cycleMinutes < 2) {
        // Minute 1-2: Originale Hintergrundbilder
        img = isNight ? nightBgImg : dayBgImg;
    } else if (cycleMinutes < 3) {
        // Minute 2-3: Neue Tag-Version v4
        img = dayBgImg1;
    } else if (cycleMinutes < 4) {
        // Minute 3-4: Neue Nacht-Version v4
        img = nightBgImg1;
    } else {
        // Minute 4-5: Zurück zu originalen Hintergrundbildern
        img = isNight ? nightBgImg : dayBgImg;
    }

    // Hintergrundbreite berechnen und zurücksetzen bei Bedarf
    if (img && img.complete && img.naturalWidth > 0) {
        const r = img.naturalWidth / img.naturalHeight;
        let sw = h * r;
        if(sw < canvas.width) sw = canvas.width;

        if(backgroundX <= -sw) backgroundX += sw;
    }
}

// --- ENHANCED FUNCTION: Improved collision detection for orientation changes ---
function checkCollision() {
    // Debug output if hitbox visualization is enabled
    if (gameSettings.showHitboxes) {
        console.log("Checking collisions. Invulnerable:", isInvulnerable);
    }

    // Safety checks
    if (!player) {
        console.error("Collision check: Player object missing!");
        return;
    }

    // Status check
    if (currentState !== GameState.PLAYING) {
        return;
    }

    // Skip collision check if invulnerable
    if (isInvulnerable) {
        if (gameSettings.showHitboxes) {
            console.log("Collision check skipped - player is invulnerable");
        }
        return;
    }

    // Get consistent hitbox size based on difficulty level
    const hitboxSize = getHitboxSize(gameSettings.hitboxSizeLevel);

    // Calculate player hitbox with consistent reduction
    const pLeft = player.x + player.width * (1-hitboxSize) / 2;
    const pTop = player.y + player.height * (1-hitboxSize) / 2;
    const pWidth = player.width * hitboxSize;
    const pHeight = player.height * hitboxSize;

    // Visualize hitboxes if enabled
    if (gameSettings.showHitboxes && debugOverlay) {
        debugOverlay.innerHTML = ''; // Clear previous hitboxes

        // Draw player hitbox
        const playerBox = document.createElement('div');
        playerBox.style.position = 'absolute';
        playerBox.style.left = pLeft + 'px';
        playerBox.style.top = pTop + 'px';
        playerBox.style.width = pWidth + 'px';
        playerBox.style.height = pHeight + 'px';
        playerBox.style.backgroundColor = 'rgba(0, 255, 0, 0.3)';
        playerBox.style.border = '2px solid lime';
        playerBox.style.zIndex = '100';
        debugOverlay.appendChild(playerBox);
    }

    // Check each obstacle
    for (const obstacle of obstacles) {
        // Use consistent hitbox reduction for obstacles
        const obstacleHitboxReduction = 0.2; // 20% smaller than visual size

        // Calculate obstacle hitbox
        const oLeft = obstacle.x + obstacle.width * obstacleHitboxReduction / 2;
        const oTop = obstacle.y + obstacle.height * obstacleHitboxReduction / 2;
        const oWidth = obstacle.width * (1 - obstacleHitboxReduction);
        const oHeight = obstacle.height * (1 - obstacleHitboxReduction);

        // Visualize obstacle hitboxes if enabled
        if (gameSettings.showHitboxes && debugOverlay) {
            const obstacleBox = document.createElement('div');
            obstacleBox.style.position = 'absolute';
            obstacleBox.style.left = oLeft + 'px';
            obstacleBox.style.top = oTop + 'px';
            obstacleBox.style.width = oWidth + 'px';
            obstacleBox.style.height = oHeight + 'px';
            obstacleBox.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            obstacleBox.style.border = '2px solid red';
            obstacleBox.style.zIndex = '100';
            debugOverlay.appendChild(obstacleBox);
        }

        // AABB collision detection (Axis-Aligned Bounding Box)
        if (
            pLeft < oLeft + oWidth &&
            pLeft + pWidth > oLeft &&
            pTop < oTop + oHeight &&
            pTop + pHeight > oTop
        ) {
            // Collision detected!
            console.log("COLLISION DETECTED with:", obstacle.type);
            loseLife();
            return; // Exit after collision processing
        }
    }
}

// --- Draw ---
function draw() {
    if(!ctx) return;
    drawBackground();
    drawClouds();
    drawGround();
    drawObstacles();
    drawPlayer();
}

// --- drawBackground - Fallback-Logik angepasst ---
        function drawBackground() {
            if(!ctx) return;

            // Hole das korrekte Hintergrundbild basierend auf der Spielzeit
            const img = getCurrentBackground();

            if (img && img.complete && img.naturalWidth > 0){
                const h = canvas.height;
                const r = img.naturalWidth / img.naturalHeight;
                let sw = h * r;
                let sh = h;
                let y = 0;

                if(sw < canvas.width){
                    sw = canvas.width;
                    sh = sw / r;
                    y = h - sh;
                }

                const copies = Math.ceil(canvas.width / sw) + 1;
                for(let i = 0; i < copies; i++) {
                    try {
                        ctx.drawImage(img, backgroundX + (sw * i), y, sw, sh);
                    } catch(e){
                        console.error("BG Draw Err:", e, "Image:", img.src);
                        // Fallback: Fülle mit einer Farbe basierend auf dem *erwarteten* Thema (zeitbasiert)
                        const minutesPassed = Math.floor(gameTime / 60);
                        const backgroundIndex = minutesPassed % 4;
                        const isExpectedNight = (backgroundIndex === 1 || backgroundIndex === 3); // Indizes 1 und 3 sind Nacht
                        const fallbackColor = isExpectedNight ? '#2d2d3a' : '#87CEEB';
                        ctx.fillStyle = fallbackColor;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        break;
                    }
                }
            } else {
                // Fallback, wenn das Bild nicht verfügbar ist
                const minutesPassed = Math.floor(gameTime / 60);
                const backgroundIndex = minutesPassed % 4;
                const isExpectedNight = (backgroundIndex === 1 || backgroundIndex === 3); // Indizes 1 und 3 sind Nacht
                const fallbackColor = isExpectedNight ? '#2d2d3a' : '#87CEEB';
                ctx.fillStyle = fallbackColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                 if (!img) console.warn("drawBackground: Image object is null or undefined.");
            }
        }

function drawGround() {
            if(!ctx) return;
            // Nutzt jetzt die ZEITBASIERTE isNight Variable
            ctx.fillStyle = isNight ? 'rgba(40,40,50,0.8)' : 'rgba(100,140,80,0.7)';
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
            ctx.fillStyle = isNight ? 'rgba(50,50,60,0.8)' : 'rgba(120,160,100,0.7)';
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, 2 * scaleFactor);
        }

function drawPlayer() {
    if(!ctx || !player || !player.image) return;
    ctx.globalAlpha = (isInvulnerable && currentState === GameState.PLAYING) ? (0.6 + Math.sin(Date.now() / 100) * 0.4) : 1;
    if(player.image.complete && player.image.naturalWidth > 0){
        ctx.drawImage(player.image, player.x, player.y, player.width, player.height);
    } else {
        ctx.fillStyle = (character === 'fuchs' ? '#ff6f00' : '#8d6e63');
        ctx.fillRect(player.x, player.y, player.width, player.height);
        /*Face*/
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(player.x + player.width * 0.35, player.y + player.height * 0.3, player.width * 0.08, 0, Math.PI * 2);
        ctx.arc(player.x + player.width * 0.65, player.y + player.height * 0.3, player.width * 0.08, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1 * scaleFactor;
        ctx.beginPath();
        ctx.arc(player.x + player.width * 0.5, player.y + player.height * 0.6, player.width * 0.15, 0.2 * Math.PI, 0.8 * Math.PI);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
}

function drawObstacles() {
    if (!ctx) return;
    for (const obstacle of obstacles) {
        try {
            if (obstacle.image && obstacle.image.complete && obstacle.image.naturalWidth > 0) {
                ctx.drawImage(obstacle.image, obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            } else {
                ctx.fillStyle = obstacle.category === 'sky' ? '#ADD8E6' : '#A0522D';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.fillStyle = '#000';
                ctx.font = `${Math.max(10, obstacle.height * 0.2)}px Courier New`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(obstacle.type.substring(0, 3), obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
            }
        } catch (drawErr) {
            console.error("Fehler beim Zeichnen des Hindernisses:", obstacle.type, drawErr);
            ctx.fillStyle = 'red';
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
        } finally {
             ctx.textAlign = 'start';
             ctx.textBaseline = 'alphabetic';
        }
    }
}

function drawClouds() {
            if(!ctx) return;
             // Nutzt jetzt die ZEITBASIERTE isNight Variable
            ctx.fillStyle = isNight ? 'rgba(100,100,100,0.6)' : 'rgba(255,255,255,0.7)';
            ctx.strokeStyle = isNight ? 'rgba(80,80,80,0.6)' : 'rgba(220,220,220,0.7)';
            ctx.lineWidth = 1 * scaleFactor;
            for(const c of clouds){
                ctx.beginPath();
                ctx.ellipse(c.x + c.width / 2, c.y + c.height / 2, c.width / 2, c.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                // ctx.stroke(); // Optional
            }
        }

// --- UI Update --- Updated for settings panel and back button
function updateUI() {
    try {
        const pl = currentState === GameState.PLAYING;
        const pa = currentState === GameState.PAUSED;
        const go = currentState === GameState.GAMEOVER;
        const re = currentState === GameState.READY;
        const se = currentState === GameState.SETTINGS;

        if(startButton) startButton.style.display = (re || go) ? 'inline-block' : 'none';
        if(settingsButton) settingsButton.style.display = (re || go) ? 'inline-block' : 'none';
        if(characterSelectContainer) characterSelectContainer.style.display = (re || go) ? 'flex' : 'none';
        if(restartButton) restartButton.style.display = go ? 'inline-block' : 'none';
        if(gameOverElement) gameOverElement.style.display = go ? 'flex' : 'none';
        if(pauseOverlay) pauseOverlay.style.display = pa ? 'flex' : 'none';
        if(settingsPanel) settingsPanel.style.display = se ? 'flex' : 'none';
        if(duckButton) duckButton.style.display = pl ? 'flex' : 'none';
        if(backButton) backButton.style.display = (pl || pa) ? 'flex' : 'none';
        if(backgroundInfo) backgroundInfo.style.display = (pl && gameSettings.showBackgroundInfo) ? 'block' : 'none';

        const instructionsElement = document.getElementById('instructions');
        if(instructionsElement) {
            instructionsElement.style.display = (re || go) ? 'block' : 'none';
        }

        if(fuchsSelect) fuchsSelect.style.pointerEvents = (re || go) ? 'auto' : 'none';
        if(waschbaerSelect) waschbaerSelect.style.pointerEvents = (re || go) ? 'auto' : 'none';
    } catch(err) {
        console.error("Fehler in updateUI:", err);
    }
}

// --- ROBUSTERE GAME LOOP mit besserer Fehlerbehandlung ---
function gameLoop(timestamp) {
    // Sicherheitsüberprüfung für lastTime und timestamp
    if(typeof lastTime === 'undefined' || isNaN(timestamp)){
        console.error("Loop Error: Ungültiger Timestamp oder lastTime", { timestamp, lastTime });
        lastTime = performance.now();
        if(animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        // Neustart der Animation nach einer kurzen Verzögerung
        setTimeout(() => {
            console.log("Loop wird nach Fehler neu gestartet");
            lastTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }, 100);
        return;
    }

    // Berechnung der Zeitdifferenz mit Sicherheitsbegrenzung
    const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
    lastTime = timestamp;

    // Hauptspiellogik mit Fehlerbehandlung
    try {
        // Update nur im PLAYING-Zustand
        if (currentState === GameState.PLAYING) {
            update(dt);

            // Regelmäßige Überprüfung der Herz-Anzeige
            if (Math.random() < 0.02) { // Etwa alle 50 Frames
                updateLivesDisplay();
            }
        }

        // Zeichnen in allen Zuständen
        draw();

        // Anzeigedebug für mobile Geräte
        if (currentState === GameState.PLAYING && Math.random() < 0.005) {
            console.log(`Spielstatus: ${lives} Leben, Unverwundbar: ${isInvulnerable}, Spielzeit: ${Math.floor(gameTime / 60)} Minuten`);
        }
    } catch (error) {
        console.error("!!! KRITISCHER LAUFZEIT-FEHLER IN DER SPIELSCHLEIFE:", error);
        console.error("Fehlerdetails:", error.message, error.stack);

        // Fehlerbehandlung für den Spieler
        if(currentState === GameState.PLAYING) {
            alert("Es ist ein Fehler aufgetreten. Das Spiel wird zurückgesetzt.");
        }

        if(animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }

        currentState = GameState.GAMEOVER;
        updateUI();
        return;
    }

    // Animation fortsetzen, wenn wir in einem aktiven Zustand sind
    if (currentState === GameState.PLAYING || currentState === GameState.READY || currentState === GameState.INIT) {
        animationFrameId = requestAnimationFrame(gameLoop);
    } else {
        if(animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
    }
}

// --- Event Handlers ---
function handleKeyDown(e) {
    try{
        let a = false;
        if(e.key === 'p' || e.key === 'P' || e.key === 'Escape'){
            if(currentState === GameState.PLAYING || currentState === GameState.PAUSED)
                togglePause();
            a = true;
        } else if(e.key === ' ' || e.key === 'ArrowUp'){
            if(currentState === GameState.READY || currentState === GameState.GAMEOVER)
                startGame();
            else if(currentState === GameState.PLAYING)
                jump();
            a = true;
        } else if(e.key === 'ArrowDown'){
            if(currentState === GameState.PLAYING)
                setDucking(true);
            a = true;
        }
        if(a) e.preventDefault();
    } catch(err){}
}

function handleKeyUp(e) {
    try{
        let a = false;
        if(e.key === 'ArrowDown'){
            if(currentState === GameState.PLAYING)
                setDucking(false);
            a = true;
        }
        if(a) e.preventDefault();
    } catch(err){}
}

// --- VERBESSERTE Touch-Behandlung für Mobilgeräte ---
function handleCanvasPointerDown(e) {
    try {
        // Visuelle Rückmeldung für Touch-Ereignisse hinzufügen
        if (gameContainer && currentState === GameState.PLAYING) {
            const touchFeedback = document.createElement('div');
            touchFeedback.className = 'touch-feedback';
            touchFeedback.style.position = 'absolute';
            touchFeedback.style.left = `${e.clientX - 20}px`;
            touchFeedback.style.top = `${e.clientY - 20}px`;
            touchFeedback.style.width = '40px';
            touchFeedback.style.height = '40px';
            touchFeedback.style.borderRadius = '50%';
            touchFeedback.style.backgroundColor = 'rgba(255, 255, 255, 0.4)';
            touchFeedback.style.pointerEvents = 'none';
            touchFeedback.style.zIndex = '50';
            touchFeedback.style.animation = 'touch-ripple 0.6s forwards';

            // Animation hinzufügen
            if (!document.getElementById('touchRippleAnimation')) {
                const style = document.createElement('style');
                style.id = 'touchRippleAnimation';
                style.textContent = '@keyframes touch-ripple { 0% { transform: scale(0.5); opacity: 1; } 100% { transform: scale(2); opacity: 0; } }';
                document.head.appendChild(style);
            }

            document.body.appendChild(touchFeedback);

            // Touch-Feedback nach Animation entfernen
            setTimeout(() => {
                if (touchFeedback.parentNode) {
                    touchFeedback.parentNode.removeChild(touchFeedback);
                }
            }, 600);
        }

        // Spielzustandslogik
        if (currentState === GameState.PAUSED) {
            togglePause();
            console.log("Spiel fortgesetzt durch Touch");
        }
        else if (currentState === GameState.READY || currentState === GameState.GAMEOVER) {
            startGame();
            console.log("Spiel gestartet durch Touch");
        }
        else if (currentState === GameState.PLAYING) {
            jump();
            console.log("Sprung ausgelöst durch Touch");
        }

        e.preventDefault();
    } catch(err) {
        console.error("Fehler bei Touch-Verarbeitung:", err);
    }
}

function handleDuckButtonPointerDown(e) {
    try{
        if(currentState === GameState.PLAYING && e.target){
            setDucking(true);
            e.target.setPointerCapture(e.pointerId);
        }
        e.preventDefault();
    } catch(err){}
}

function handleDuckButtonPointerUp(e) {
    try{
        if(currentState === GameState.PLAYING && e.target){
            setDucking(false);
            if(e.target.hasPointerCapture(e.pointerId))
                e.target.releasePointerCapture(e.pointerId);
        }
        e.preventDefault();
    } catch(err){}
}

function handleDuckButtonPointerCancel(e) {
    try{
        if(currentState === GameState.PLAYING && e.target){
            setDucking(false);
            if(e.target.hasPointerCapture(e.pointerId))
                e.target.releasePointerCapture(e.pointerId);
        }
        e.preventDefault();
    } catch(err){}
}

function handleCharacterSelect(e) {
    try{
        if((currentState !== GameState.READY && currentState !== GameState.GAMEOVER) || !e.target || e.target.tagName !== 'IMG')
            return;
        const nc = (e.target.id === 'fuchs') ? 'fuchs' : 'waschbaer';
        if(nc !== character){
            character = nc;
            if(fuchsSelect) fuchsSelect.classList.toggle('selected', character === 'fuchs');
            if(waschbaerSelect) waschbaerSelect.classList.toggle('selected', character === 'waschbaer');
            if(player) player.image = (character === 'fuchs' ? fuchsImg : waschbaerImg);
            if(currentState === GameState.READY){
                resetGame();
                draw();
            }
        }
    } catch(err){}
}

// --- ENHANCED FUNCTION: Improved resize handler that calls orientation handler ---
function handleResize() {
    try {
        console.log("Window resized");
        // Delegate to orientation handler for consistent behavior
        handleOrientationChange();
    } catch(err) {
        console.error("Error in resize handler:", err);
    }
}

// --- ENHANCED FUNCTION: Event listeners with orientation change handler ---
function addEventListeners() {
    console.log("Listeners: Adding...");
    try {
        // Existing event listeners
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        if(canvas) canvas.addEventListener('pointerdown', handleCanvasPointerDown);
        if(startButton) startButton.addEventListener('click', startGame);
        if(restartButton) restartButton.addEventListener('click', startGame);
        if(quitButton) quitButton.addEventListener('click', quitGame);
        if(backButton) backButton.addEventListener('click', backToMenu);
        if(settingsButton) settingsButton.addEventListener('click', toggleSettingsPanel);
        if(settingsCloseButton) settingsCloseButton.addEventListener('click', toggleSettingsPanel);
        if(settingsResetButton) settingsResetButton.addEventListener('click', resetGameSettings);

        // Event-Listener für den Settings-Zurück-Button
        if(settingsBackButton) settingsBackButton.addEventListener('click', toggleSettingsPanel);

        if(duckButton) {
            duckButton.addEventListener('pointerdown', handleDuckButtonPointerDown);
            duckButton.addEventListener('pointerup', handleDuckButtonPointerUp);
            duckButton.addEventListener('pointercancel', handleDuckButtonPointerCancel);
            duckButton.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        if(characterSelectContainer) characterSelectContainer.addEventListener('click', handleCharacterSelect);

        // ADD THIS: Orientation change handler - IMPORTANT FOR RELIABLE HITBOXES
        window.addEventListener('orientationchange', handleOrientationChange);

        // Keep the resize listener as a backup
        window.addEventListener('resize', handleResize);

        console.log("Listeners: Added.");
    } catch(e) {
        console.error("Listener Add Error", e);
    }
}

      console.log("--- Script End ---");
    </script>
</body>
</html>
