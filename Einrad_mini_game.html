<!DOCTYPE html>
<html>
<head>
    <title>Pixel Runner Adventure</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#333333">
    <meta charset="UTF-8">
    <!-- Preload the loading image first -->
    <link rel="preload" href="https://raw.githubusercontent.com/ErSieCode/1Rad/main/load.png" as="image">
    <style>
        /* Reset and Base Styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100vh; overflow: hidden; background-color: #e0e0e0; font-family: 'Courier New', monospace; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; }
        #gameContainer { position: relative; width: 95vw; max-width: 800px; aspect-ratio: 16 / 9; max-height: 85vh; overflow: hidden; border: 2px solid #333; box-shadow: 0 5px 15px rgba(0,0,0,0.2); background-color: #87CEEB; /* Himmelsblau als Fallback */ }
        #gameCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        /* Loading Spinner Styles */
        #loadingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #loadingSpinner {
            width: 100px;
            height: 100px;
            animation: spin 2s linear infinite;
            display: block;
            object-fit: contain;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* UI Styles - VERBESSERT FÜR SMARTPHONES */
        #gameControls, #gameInfo, #livesDisplay, #quitButton, #pauseOverlay, #gameOver, #duckButton { position: absolute; z-index: 10; font-size: max(2.2vmin, 16px); } /* Größere Schrift */
        #gameControls {
            top: 2%;
            left: 2%;
            display: flex;
            gap: 12px; /* Größerer Abstand für Touch */
            align-items: center;
        }
        #gameInfo {
            top: 2%;
            right: 10%;
            text-align: right;
            color: #fff; /* Besserer Kontrast */
            background-color: rgba(0, 0, 0, 0.7); /* Dunklerer Hintergrund für bessere Lesbarkeit */
            padding: max(0.8vmin, 5px) max(1.4vmin, 8px); /* Größerer Padding */
            border-radius: 8px; /* Abgerundete Ecken */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3); /* Schatten für bessere Sichtbarkeit */
        }
        #gameInfo div { margin-bottom: 3px; font-weight: bold; } /* Fetter Text */

        /* Stark verbesserte Herz-Anzeige für bessere Sichtbarkeit */
        #livesDisplay {
            top: calc(2% + 60px);
            right: 10%;
            background-color: rgba(0, 0, 0, 0.7);
            padding: max(0.8vmin, 5px) max(1.4vmin, 8px);
            border-radius: 8px;
            display: flex;
            gap: 8px; /* Größerer Abstand zwischen Herzen */
            box-shadow: 0 2px 4px rgba(0,0,0,0.3); /* Schatten für bessere Sichtbarkeit */
            border: 1px solid rgba(255,255,255,0.3); /* Subtiler Rand */
        }

        /* Deutlich verbesserte, größere und auffälligere Herz-Anzeige */
        .heart {
            color: #ff3333; /* Kräftigeres Rot */
            font-size: max(4vmin, 22px); /* Deutlich größer */
            font-weight: bold;
            text-shadow:
                0 0 5px rgba(255,0,0,0.7), /* Rotes Leuchten */
                1px 1px 2px rgba(0,0,0,0.9); /* Dunkler Schatten */
            transition: transform 0.3s ease-out, opacity 0.3s ease-out, visibility 0s; /* Längere Animation */
            display: inline-block;
            visibility: visible;
            opacity: 1;
            transform: scale(1);
            line-height: 1; /* Besseres Zentrieren */
            -webkit-text-stroke: 1px rgba(0,0,0,0.5); /* Schwarzer Umriss für besseren Kontrast */
        }

        /* Animierte Herz-Ausblendung */
        .heart.hidden {
            visibility: hidden;
            opacity: 0;
            transform: scale(0.2) rotate(180deg); /* Dreht sich und schrumpft */
            transition: transform 0.5s ease-out, opacity 0.5s ease-out, visibility 0s 0.5s;
        }
        #quitButton { top: 2%; right: 2%; width: max(4vmin, 24px); height: max(4vmin, 24px); background-color: #ff3333; color: white; font-weight: bold; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; z-index: 30; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); border: none; font-size: max(2vmin, 12px); line-height: 1; }
        #quitButton:hover { background-color: #cc0000; }
        /* Back Button Styling - Moved to far left and changed to green */
        #backButton {
            top: 2%;
            left: 2%;
            width: max(4vmin, 24px);
            height: max(4vmin, 24px);
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 30;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: none;
            font-size: max(2vmin, 12px);
            line-height: 1;
            position: absolute;
        }
        #backButton:hover {
            background-color: #45a049;
        }
        #pauseOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 20; }
        #pauseOverlay h2 { color: #ffffff; font-size: max(4.5vmin, 26px); text-align: center; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); margin-bottom: 10px; }
        #pauseOverlay p { color: #f0f0f0; font-size: max(2.2vmin, 16px); text-align: center; margin-top: 15px; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); }
        /* Game Over mit Banner */
        #gameOver { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 20; background-image: url('https://raw.githubusercontent.com/ErSieCode/1Rad/main/Banner.png'); background-size: contain; background-repeat: no-repeat; background-position: center center; background-color: rgba(0, 0, 0, 0.6); text-align: center; }
        #gameOver h2 { color: #ffffff; font-size: max(4.5vmin, 26px); text-align: center; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); margin-bottom: 10px; margin-top: -10%; }
        #gameOver div { color: #f0f0f0; margin-bottom: 15px; font-size: max(2.5vmin, 17px); background-color: rgba(0,0,0,0.6); padding: 5px 10px; border-radius: 4px; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); }
        /* Buttons */
        #startButton, #restartButton, #settingsButton, #settingsCloseButton, #settingsResetButton {
            padding: max(1.4vmin, 10px) max(2.8vmin, 20px);
            font-size: max(2.3vmin, 16px);
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: 15px;
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
            text-shadow: 1px 1px 1px rgba(0,0,0,0.4);
            transition: background-color 0.2s;
        }
        #startButton:hover, #restartButton:hover, #settingsButton:hover, #settingsCloseButton:hover, #settingsResetButton:hover {
            background-color: #45a049;
        }
        #startButton, #settingsButton { margin-right: 5px; }
        #characterSelect { display: flex; gap: 10px; align-items: center; }
        #characterSelect img { width: max(6vmin, 35px); height: max(6vmin, 35px); cursor: pointer; border: 3px solid transparent; border-radius: 5px; background-color: rgba(255, 255, 255, 0.7); padding: 1px; transition: border-color 0.2s, transform 0.2s; }
        #characterSelect img:hover { transform: scale(1.1); }
        #characterSelect img.selected { border-color: #ff9800; transform: scale(1.05); }
        #instructions { width: 90%; max-width: 600px; text-align: center; color: #444; font-size: max(1.7vmin, 14px); z-index: 5; background-color: rgba(210, 210, 210, 0.8); padding: max(0.7vmin, 5px) max(1.2vmin, 9px); border-radius: 5px; margin-top: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        /* Duck Button CSS - OPTIMIERT FÜR MOBILE UND TOUCH */
        #duckButton {
            bottom: 5%; /* Höher positioniert für bessere Erreichbarkeit */
            right: 5%; /* Weiter nach innen für bessere Erreichbarkeit */
            width: max(10vmin, 60px); /* DEUTLICH größer für mobile Touch */
            height: max(10vmin, 60px); /* DEUTLICH größer für mobile Touch */
            background-color: rgba(80, 80, 80, 0.8); /* Dunklerer Hintergrund */
            border: 2px solid rgba(255, 255, 255, 0.5); /* Weißer Rand für bessere Sichtbarkeit */
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: max(5vmin, 24px); /* Größerer Text */
            z-index: 100; /* Höherer z-index, um Überdeckung zu vermeiden */
            cursor: pointer;
            display: none;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); /* Stärkerer Schatten */
            touch-action: manipulation;
            padding: 0;
            overflow: hidden;
            transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s;
            /* Aktives Feedback-Leuchten für bessere Sichtbarkeit */
            animation: pulse-button 1.5s infinite alternate;
        }

        /* Duck-Button-Bild anpassen */
        #duckButton img {
            width: 70%;
            height: 70%;
            object-fit: contain;
            pointer-events: none;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5)); /* Schatten für das Bild */
        }

        /* Stärkeres visuelles Feedback bei Berührung */
        #duckButton:active {
            background-color: rgba(100, 100, 100, 0.9);
            transform: translateY(4px) scale(0.95);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.8);
        }

        /* Pulsier-Animation für den Duck-Button */
        @keyframes pulse-button {
            0% { box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); }
            100% { box-shadow: 0 4px 12px rgba(100, 255, 185, 0.7); }
        }
        @keyframes doubleJumpEffect { 0% { transform: scale(1); opacity: 0.7; } 100% { transform: scale(2.5); opacity: 0; } }
        .doubleJumpEffect { position: absolute; border-radius: 50%; background-color: rgba(255, 215, 0, 0.6); pointer-events: none; z-index: 15; animation: doubleJumpEffect 0.4s ease-out forwards; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

        /* Settings Panel Styles - UPDATED FOR DIFFICULTY LEVELS */
        #settingsPanel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 25;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
            overflow-y: auto;
        }

        /* Added settings header container to hold title and back button */
        .settings-header {
            display: flex;
            width: 100%;
            justify-content: center;
            align-items: center;
            position: relative;
            margin-bottom: 20px;
            padding-top: 10px;
        }

        /* Settings back button styling */
        #settingsBackButton {
            position: absolute;
            left: 0;
            width: max(4.5vmin, 30px);
            height: max(4.5vmin, 30px);
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: none;
            font-size: max(2.2vmin, 16px);
            line-height: 1;
            -webkit-tap-highlight-color: transparent;
        }

        #settingsBackButton:hover,
        #settingsBackButton:active {
            background-color: #45a049;
        }

        #settingsPanel h2 {
            font-size: max(3vmin, 20px);
            color: #4CAF50;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            text-align: center;
        }

        /* NEW DIFFICULTY SELECTION STYLES */
        .difficulty-selection {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 500px;
        }

        .difficulty-title {
            font-size: max(2.2vmin, 16px);
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            color: #4CAF50;
        }

        .difficulty-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        .difficulty-option {
            position: relative;
            width: calc(50% - 10px);
            min-width: 100px;
        }

        @media (max-width: 500px) {
            .difficulty-option {
                width: 100%;
            }
        }

        .difficulty-option input[type="radio"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }

        .difficulty-option label {
            display: block;
            padding: 10px 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            font-weight: bold;
            transition: all 0.2s;
        }

        .difficulty-option input[type="radio"]:checked + label {
            border-color: #4CAF50;
            background-color: rgba(76, 175, 80, 0.3);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .difficulty-option:nth-child(1) label {
            color: #90EE90; /* Light green for easy */
        }

        .difficulty-option:nth-child(2) label {
            color: #FFFFFF; /* White for normal */
        }

        .difficulty-option:nth-child(3) label {
            color: #FFA500; /* Orange for hard */
        }

        .difficulty-option:nth-child(4) label {
            color: #FF6347; /* Tomato for very hard */
        }

        /* Setting sections */
        .settings-section {
            display: flex;
            flex-direction: column;
            width: 90%;
            max-width: 500px;
            margin-bottom: 15px;
        }

        .settings-section-title {
            font-size: max(1.8vmin, 15px);
            margin-bottom: 5px;
            color: #DDD;
            text-align: center;
        }

        /* Checkbox styling for hitbox toggle */
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
        }

        .checkbox-container input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-container label {
            font-size: max(1.8vmin, 14px);
            cursor: pointer;
            font-weight: bold;
        }

        .settings-buttons {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Make buttons bigger on mobile for better touch targets */
        @media (max-width: 500px) {
            #settingsResetButton, #settingsCloseButton {
                padding: 12px 20px;
                font-size: 18px;
                margin: 5px;
            }
        }

        /* Debug overlay for hitboxes */
        #debugOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
        }
    </style>
</head>
<body>
    <!-- HTML Struktur -->
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="debugOverlay"></div>
        <div id="loadingOverlay">
            <img id="loadingSpinner" src="https://raw.githubusercontent.com/ErSieCode/1Rad/main/load.png" alt="Loading..."
                 onerror="this.onerror=null; console.error('Loading image failed to load'); this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iNDAiIGN5PSI0MCIgcj0iMzYiIHN0cm9rZT0iIzRDQUY1MCIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSJub25lIiBzdHJva2UtZGFzaGFycmF5PSIxNTAgMTgwIiAvPjwvc3ZnPg==';"
                 onload="console.log('Loading spinner image loaded successfully!');">
        </div>
        <div id="gameControls">
            <button id="startButton">START</button>
            <button id="settingsButton">SETTINGS</button>
            <div id="characterSelect">
                <img id="fuchs" src="https://raw.githubusercontent.com/ErSieCode/1Rad/main/Fuchs_einrad.png" alt="Fuchs">
                <img id="waschbaer" src="https://raw.githubusercontent.com/ErSieCode/1Rad/main/waschbaer_einrad.png" alt="Waschbär">
            </div>
        </div>
        <div id="gameInfo">
            <div>SCORE: <span id="score">0</span></div>
            <div>HI: <span id="highScore">0</span></div>
        </div>
        <div id="livesDisplay"></div>
        <button id="quitButton">✕</button>
        <button id="backButton">⬅</button>
        <div id="pauseOverlay">
            <div><h2>GAME PAUSED</h2><p>Press 'P' or ESC or Tap to resume</p></div>
        </div>
        <button id="duckButton">↓</button>
        <div id="gameOver">
            <h2>GAME OVER</h2>
            <div>Final Score: <span id="finalScore">0</span></div>
            <button id="restartButton">RESTART</button>
        </div>

        <!-- Settings Panel - UPDATED WITH DIFFICULTY LEVELS -->
        <div id="settingsPanel">
            <div class="settings-header">
                <button id="settingsBackButton">⬅</button>
                <h2>Game Settings</h2>
            </div>

            <!-- Game Speed Setting -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Game Speed</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="speedEasy" name="speedSetting" value="easy">
                        <label for="speedEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="speedNormal" name="speedSetting" value="normal" checked>
                        <label for="speedNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="speedHard" name="speedSetting" value="hard">
                        <label for="speedHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="speedVeryHard" name="speedSetting" value="veryHard">
                        <label for="speedVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Jump Height Setting -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Jump Height</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="jumpEasy" name="jumpSetting" value="easy">
                        <label for="jumpEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="jumpNormal" name="jumpSetting" value="normal" checked>
                        <label for="jumpNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="jumpHard" name="jumpSetting" value="hard">
                        <label for="jumpHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="jumpVeryHard" name="jumpSetting" value="veryHard">
                        <label for="jumpVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Spawn Rate Setting -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Spawn Rate</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="spawnEasy" name="spawnSetting" value="easy">
                        <label for="spawnEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="spawnNormal" name="spawnSetting" value="normal" checked>
                        <label for="spawnNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="spawnHard" name="spawnSetting" value="hard">
                        <label for="spawnHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="spawnVeryHard" name="spawnSetting" value="veryHard">
                        <label for="spawnVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            // Flying Objects Height Setting - Default auf "Easy" gesetzt
            <div class="difficulty-selection">
                <div class="difficulty-title">Flying Objects Height</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="flyingHeightEasy" name="flyingHeightSetting" value="easy" checked>
                        <label for="flyingHeightEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="flyingHeightNormal" name="flyingHeightSetting" value="normal">
                        <label for="flyingHeightNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="flyingHeightHard" name="flyingHeightSetting" value="hard">
                        <label for="flyingHeightHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="flyingHeightVeryHard" name="flyingHeightSetting" value="veryHard">
                        <label for="flyingHeightVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Hitbox Size Setting -->
            <div class="difficulty-selection">
                <div class="difficulty-title">Hitbox Size</div>
                <div class="difficulty-options">
                    <div class="difficulty-option">
                        <input type="radio" id="hitboxSizeEasy" name="hitboxSizeSetting" value="easy">
                        <label for="hitboxSizeEasy">Einfach</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="hitboxSizeNormal" name="hitboxSizeSetting" value="normal" checked>
                        <label for="hitboxSizeNormal">Normal</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="hitboxSizeHard" name="hitboxSizeSetting" value="hard">
                        <label for="hitboxSizeHard">Schwer</label>
                    </div>
                    <div class="difficulty-option">
                        <input type="radio" id="hitboxSizeVeryHard" name="hitboxSizeSetting" value="veryHard">
                        <label for="hitboxSizeVeryHard">Sehr Schwer</label>
                    </div>
                </div>
            </div>

            <!-- Hitbox visualization toggle -->
            <div class="checkbox-container">
                <input type="checkbox" id="showHitboxSetting">
                <label for="showHitboxSetting">Show Hitboxes</label>
            </div>

            <div class="settings-buttons">
                <button id="settingsResetButton">Reset Defaults</button>
                <button id="settingsCloseButton">Close</button>
            </div>
        </div>
    </div>
    <div id="instructions">Press SPACE/UP/Tap to jump/double jump | DOWN/Button to duck | P/ESC to pause</div>

    <script>
        'use strict';
        console.log("--- Script Start ---");

        // --- Debug Utility ---
        function logImageStatus(name, img) {
            img.onload = () => console.log(`✓ ${name} loaded.`);
            img.onerror = (e) => console.error(`✗ ${name} FAILED loading from ${img.src}`, e);
        }

        // Initialize loading spinner first
        document.addEventListener('DOMContentLoaded', function() {
            const loadingSpinner = document.getElementById('loadingSpinner');
            const loadingOverlay = document.getElementById('loadingOverlay');

            // Make sure the loading overlay is visible
            if (loadingOverlay) {
                loadingOverlay.style.display = 'flex';
            }

            // Check if the image is loading correctly
            if (loadingSpinner) {
                if (!loadingSpinner.complete) {
                    console.log("Loading spinner image is still loading...");
                    loadingSpinner.onload = function() {
                        console.log("Loading spinner image has loaded successfully!");
                    };
                } else {
                    console.log("Loading spinner image was already loaded!");
                }
            }
        });

        // --- Asset Loading with progress tracking ---
        console.log("Assets: Defining...");
        // Track loading progress
        let totalAssets = 12; // Total number of images to load
        let loadedAssets = 0;
        const loadingOverlay = document.getElementById('loadingOverlay');

        function checkAllAssetsLoaded() {
            loadedAssets++;
            console.log(`Loaded ${loadedAssets}/${totalAssets} assets`);
            if (loadedAssets >= totalAssets) {
                // Hide loading overlay when all assets are loaded
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'none';
                }
                console.log("All assets loaded successfully!");
            }
        }

        function enhancedLogImageStatus(name, img) {
            img.onload = () => {
                console.log(`✓ ${name} loaded.`);
                checkAllAssetsLoaded();
            };
            img.onerror = (e) => {
                console.error(`✗ ${name} FAILED loading from ${img.src}`, e);
                checkAllAssetsLoaded(); // Count errors too, to avoid spinner getting stuck
            };
        }

        const fuchsImg = new Image(); enhancedLogImageStatus('Fuchs', fuchsImg);
        const waschbaerImg = new Image(); enhancedLogImageStatus('Waschbär', waschbaerImg);
        const duckButtonImg = new Image(); enhancedLogImageStatus('Duck Icon', duckButtonImg);
        // Backgrounds
        const dayBgImg = new Image(); enhancedLogImageStatus('BG Day', dayBgImg);
        const nightBgImg = new Image(); enhancedLogImageStatus('BG Night', nightBgImg);
        const gameOverBannerImg = new Image(); enhancedLogImageStatus('Game Over Banner', gameOverBannerImg);
        // Obstacles - Ground
        const pallet4Img = new Image(); enhancedLogImageStatus('Obstacle Pallet 4', pallet4Img);
        const pallet6Img = new Image(); enhancedLogImageStatus('Obstacle Pallet 6', pallet6Img);
        const logImg = new Image(); enhancedLogImageStatus('Obstacle Log', logImg);
        const stumpImg = new Image(); enhancedLogImageStatus('Obstacle Stump', stumpImg);
        // Obstacles - Sky
        const owlImg = new Image(); enhancedLogImageStatus('Obstacle Owl', owlImg);
        const flyingUniImg = new Image(); enhancedLogImageStatus('Obstacle Flying Uni', flyingUniImg);

        // Set sources after setting up handlers
        fuchsImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Fuchs_einrad.png';
        waschbaerImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/waschbaer_einrad.png';
        duckButtonImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Muni_logo.png';
        dayBgImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Tag_BG.png';
        nightBgImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Nacht_BG.png';
        gameOverBannerImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Banner.png';
        pallet4Img.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Paletten_4_IMG.png';
        pallet6Img.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Paletten_6_IMG.png';
        logImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/baum_liegend.png';
        stumpImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/baumstumpf.png';
        owlImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Eule_v1_L.png';
        flyingUniImg.src = 'https://raw.githubusercontent.com/ErSieCode/1Rad/main/Fulg_Einrad_orange.png';

        console.log("Assets: Defined.");

        // --- DOM Elements ---
        console.log("DOM: Getting elements...");
        let canvas, ctx, scoreElement, highScoreElement, finalScoreElement, gameOverElement, restartButton, startButton,
            fuchsSelect, waschbaerSelect, characterSelectContainer, pauseOverlay, quitButton, livesDisplay, gameContainer,
            duckButton, backButton, settingsButton, settingsPanel, settingsCloseButton, settingsResetButton, debugOverlay,
            showHitboxSetting, settingsBackButton;

        // Frühe Initialisierung der Variablen
        canvas = document.getElementById('gameCanvas');
        ctx = canvas ? canvas.getContext('2d') : null;
        scoreElement = document.getElementById('score');
        highScoreElement = document.getElementById('highScore');
        finalScoreElement = document.getElementById('finalScore');
        gameOverElement = document.getElementById('gameOver');
        restartButton = document.getElementById('restartButton');
        startButton = document.getElementById('startButton');
        fuchsSelect = document.getElementById('fuchs');
        waschbaerSelect = document.getElementById('waschbaer');
        characterSelectContainer = document.getElementById('characterSelect');
        pauseOverlay = document.getElementById('pauseOverlay');
        quitButton = document.getElementById('quitButton');
        livesDisplay = document.getElementById('livesDisplay');
        gameContainer = document.getElementById('gameContainer');
        duckButton = document.getElementById('duckButton');
        backButton = document.getElementById('backButton');
        settingsButton = document.getElementById('settingsButton');
        settingsPanel = document.getElementById('settingsPanel');
        settingsCloseButton = document.getElementById('settingsCloseButton');
        settingsResetButton = document.getElementById('settingsResetButton');
        debugOverlay = document.getElementById('debugOverlay');
        showHitboxSetting = document.getElementById('showHitboxSetting');
        settingsBackButton = document.getElementById('settingsBackButton');

        if (!canvas || !ctx) {
             console.error("CRITICAL: Canvas or Context not available immediately!");
             document.addEventListener('DOMContentLoaded', () => { alert("Fehler: Spiel-Canvas konnte nicht initialisiert werden!"); });
        } else {
             console.log("DOM: Elements retrieved.");
             window.addEventListener('load', init); // Add listener only if canvas is okay
        }

        // --- Game State ---
        const GameState = {
            INIT: 'INIT',
            READY: 'READY',
            PLAYING: 'PLAYING',
            PAUSED: 'PAUSED',
            GAMEOVER: 'GAMEOVER',
            SETTINGS: 'SETTINGS'
        };

        let currentState = GameState.INIT;
        let character = 'fuchs';
        let score = 0;
        let highScore = 0;
        let lives = 3;
        const maxLives = 3;
        let speed = 0;
        let speedIncrement = 0.0005;
        let backgroundX = 0;
        let isDucking = false;
        let isNight = false;
        let isInvulnerable = false;
        let invulnerabilityTimer = null;
        const invulnerabilityDuration = 2000;

        // --- Physics & Scaling ---
        let scaleFactor = 1;
        const baseWidth = 800;
        let baseSpeed = 250;
        let baseGravity = 1200;
        let baseJumpStrength = -550;
        let groundHeight = 0;
        let player = {};
        let obstacles = [];
        let clouds = [];
        let obstacleTimer = 0;
        let cloudTimer = 0;
        let minObstacleTime = 1.4;
        let maxObstacleTime = 2.8;
        const initialObstacleCooldown = 3.0;
        const highStumpMinTime = 45;

        // Variable to track separate spawn timers for ground and sky obstacles
        let groundObstacleTimer = 0;
        let skyObstacleTimer = 0;

        // Additional offset timers for more randomized spawning
        let groundObstacleTimerOffset = 0;
        let skyObstacleTimerOffset = 0;

        // Skalierungsfaktor für alle Spielelemente - Charakter etwas schmaler machen
        const globalSizeFactor = 1.25; // 25% größer
        const playerWidthRatio = 0.9; // Character width is 90% of normal to make it slightly slimmer

        // --- Verbesserte 4-stufige Spawnregeln, ÜBERARBEITET für bessere Progression ---
        const SpawnRules = {
            // Einfach: Wie früher "normal" - moderate Hindernisse mit etwas Vorhersehbarkeit
            EASY: {
                groundInterval: 2.5,    // Alle 2.5 Sekunden ein Bodenhindernis (wie altes NORMAL)
                skyInterval: 2.5,       // Alle 2.5 Sekunden ein Lufthindernis
                randomVariation: 0.3,   // ±30% Variation für gute Vorhersehbarkeit
                independent: false,     // Boden und Luft alternieren
                staggered: true,        // Versetzter Start
                randomTriggerChance: 0.001 // Sehr geringe Chance für zufällige Spawns
            },
            // Normal: Zwischen altem "normal" und "hard"
            NORMAL: {
                groundInterval: 2.2,    // Etwas häufiger als EASY
                skyInterval: 2.2,       // Etwas häufiger als EASY
                randomVariation: 0.4,   // ±40% Variation für etwas mehr Unvorhersehbarkeit
                independent: false,     // Immer noch alternierend
                staggered: true,        // Versetzter Start
                randomTriggerChance: 0.002 // Etwas mehr zufällige Spawns
            },
            // Schwer: Wie früher "very hard" - viele Hindernisse, unvorhersehbar
            HARD: {
                groundInterval: 1.6,    // Häufige Hindernisse (zwischen altem HARD und VERY_HARD)
                skyInterval: 1.8,       // Häufige Hindernisse
                randomVariation: 0.5,   // ±50% Variation für mehr Unvorhersehbarkeit
                independent: true,      // Boden und Luft unabhängig
                staggered: true,        // Versetzter Start
                randomTriggerChance: 0.004 // Mehr zufällige Spawns
            },
            // Sehr Schwer: Noch schwieriger als zuvor
            VERY_HARD: {
                groundInterval: 0.8,    // Extrem häufige Hindernisse (früher 1.0)
                skyInterval: 1.0,       // Extrem häufige Hindernisse (früher 1.2)
                randomVariation: 0.6,   // ±60% Variation für maximale Unvorhersehbarkeit
                independent: true,      // Boden und Luft völlig unabhängig
                staggered: false,       // Kein versetzter Start mehr für noch mehr Schwierigkeit
                randomTriggerChance: 0.008 // Häufige zufällige Spawns
            }
        };

        // --- Konsistente Hitbox-Größen für alle Schwierigkeitsstufen ---
        const HitboxSizes = {
            // Für alle Schwierigkeitsstufen sind die Hitboxen konsistent
            EASY: 0.65,       // 65% der visuellen Größe (sehr großzügig)
            NORMAL: 0.75,     // 75% der visuellen Größe (normal)
            HARD: 0.85,       // 85% der visuellen Größe (anspruchsvoll)
            VERY_HARD: 0.95   // 95% der visuellen Größe (sehr schwer)
        };

        // --- Flughöhen für fliegende Hindernisse ---
        // GEÄNDERT: Niedrigere Höhen für alle Schwierigkeitsgrade
        const FlyingHeights = {
            EASY: {
                heightFactor: 0.5,    // Mittlere Höhe (ursprünglich 0.3, jetzt tiefer)
                randomness: 0.3       // ±30% Zufallsvarianz
            },
            NORMAL: {
                heightFactor: 0.65,    // Etwas tiefer (ursprünglich 0.5, jetzt tiefer)
                randomness: 0.3       // ±30% Zufallsvarianz
            },
            HARD: {
                heightFactor: 0.8,    // Ziemlich tief (ursprünglich 0.7, jetzt tiefer)
                randomness: 0.2       // ±20% Zufallsvarianz
            },
            VERY_HARD: {
                heightFactor: 0.95,   // Sehr tief (nur durch Ducken zu vermeiden)
                randomness: 0.1       // ±10% Zufallsvarianz (konsistente Höhe)
            }
        };

        // --- Game Settings with difficulty levels ---
        let gameSettings = {
            // Standardeinstellungen, angepasst für besseres Spielerlebnis
            speedLevel: 'easy',           // Auf einfach gesetzt (vormals normal)
            jumpHeightLevel: 'easy',      // Auf einfach gesetzt (vormals normal)
            spawnRateLevel: 'easy',       // Auf einfach gesetzt (vormals normal)
            flyingHeightLevel: 'easy',    // Auf einfach gesetzt (vormals normal)
            hitboxSizeLevel: 'normal',    // Unverändert
            showHitboxes: false           // Toggle für Hitbox-Visualisierung
        };

        // Difficulty level values - ÜBERARBEITET für bessere Stufenverteilung
        const difficultyValues = {
            speed: {
                easy: 1.0,      // War vorher 'normal' (1.0), jetzt 'easy'
                normal: 1.3,    // War vorher 'hard' (1.3), jetzt 'normal'
                hard: 1.6,      // War vorher 'veryHard' (1.6), jetzt 'hard'
                veryHard: 2.0   // Neue noch höhere Schwierigkeit
            },
            jumpHeight: {
                easy: 1.0,      // War vorher 'normal', jetzt 'easy'
                normal: 0.85,   // Zwischen dem alten 'normal' und 'hard'
                hard: 0.75,     // Etwas leichter als das alte 'veryHard'
                veryHard: 0.65  // Noch schwieriger als zuvor
            },
            gravity: {
                easy: 1.0,      // War vorher 'normal', jetzt 'easy'
                normal: 1.15,   // Zwischen dem alten 'normal' und 'hard'
                hard: 1.3,      // Was vorher 'veryHard' war
                veryHard: 1.5   // Noch schwieriger als zuvor
            }
        };

        // --- Settings Control Functions ---
        function initializeSettings() {
            // Find all radio buttons for each setting type
            const speedRadios = document.querySelectorAll('input[name="speedSetting"]');
            const jumpRadios = document.querySelectorAll('input[name="jumpSetting"]');
            const spawnRadios = document.querySelectorAll('input[name="spawnSetting"]');
            const flyingHeightRadios = document.querySelectorAll('input[name="flyingHeightSetting"]');
            const hitboxSizeRadios = document.querySelectorAll('input[name="hitboxSizeSetting"]');

            // Set initial selections based on gameSettings
            setRadioByValue(speedRadios, gameSettings.speedLevel);
            setRadioByValue(jumpRadios, gameSettings.jumpHeightLevel);
            setRadioByValue(spawnRadios, gameSettings.spawnRateLevel);
            setRadioByValue(flyingHeightRadios, gameSettings.flyingHeightLevel);
            setRadioByValue(hitboxSizeRadios, gameSettings.hitboxSizeLevel);

            // Initialize hitbox visibility toggle
            if (showHitboxSetting) {
                showHitboxSetting.checked = gameSettings.showHitboxes;
                showHitboxSetting.addEventListener('change', (e) => {
                    gameSettings.showHitboxes = e.target.checked;

                    // Clear debug overlay if hitboxes are disabled
                    if (!gameSettings.showHitboxes && debugOverlay) {
                        debugOverlay.innerHTML = '';
                    }
                });
            }

            // Add event listeners to all radio buttons
            addRadioListeners(speedRadios, 'speedLevel');
            addRadioListeners(jumpRadios, 'jumpHeightLevel');
            addRadioListeners(spawnRadios, 'spawnRateLevel');
            addRadioListeners(flyingHeightRadios, 'flyingHeightLevel');
            addRadioListeners(hitboxSizeRadios, 'hitboxSizeLevel');
        }

        // Helper function to set a radio button by value
        function setRadioByValue(radios, value) {
            for (const radio of radios) {
                if (radio.value === value) {
                    radio.checked = true;
                    break;
                }
            }
        }

        // Helper function to add listeners to radio buttons
        function addRadioListeners(radios, settingName) {
            for (const radio of radios) {
                radio.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        gameSettings[settingName] = e.target.value;

                        // Apply settings if they changed during setup
                        if (currentState === GameState.READY) {
                            applyGameSettings();
                        }
                    }
                });
            }
        }

        function resetGameSettings() {
            gameSettings = {
                speedLevel: 'easy',          // Auf einfach gesetzt (vormals normal)
                jumpHeightLevel: 'easy',     // Auf einfach gesetzt (vormals normal)
                spawnRateLevel: 'easy',      // Auf einfach gesetzt (vormals normal)
                flyingHeightLevel: 'easy',   // Auf einfach gesetzt (vormals normal)
                hitboxSizeLevel: 'normal',   // Unverändert
                showHitboxes: false
            };

            // Update UI controls
            const speedRadios = document.querySelectorAll('input[name="speedSetting"]');
            const jumpRadios = document.querySelectorAll('input[name="jumpSetting"]');
            const spawnRadios = document.querySelectorAll('input[name="spawnSetting"]');
            const flyingHeightRadios = document.querySelectorAll('input[name="flyingHeightSetting"]');
            const hitboxSizeRadios = document.querySelectorAll('input[name="hitboxSizeSetting"]');

            setRadioByValue(speedRadios, 'easy');          // Geändert von 'normal'
            setRadioByValue(jumpRadios, 'easy');           // Geändert von 'normal'
            setRadioByValue(spawnRadios, 'easy');          // Geändert von 'normal'
            setRadioByValue(flyingHeightRadios, 'easy');   // Geändert von 'normal'
            setRadioByValue(hitboxSizeRadios, 'normal');   // Unverändert

            // Update hitbox checkbox
            if (showHitboxSetting) {
                showHitboxSetting.checked = false;
            }

            // Clear debug overlay
            if (debugOverlay) {
                debugOverlay.innerHTML = '';
            }

            // Apply settings
            if (currentState === GameState.READY) {
                applyGameSettings();
            }
        }

        function applyGameSettings() {
            // Get the appropriate multipliers based on difficulty levels
            const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];

            // Apply speed setting
            speed = baseSpeed * scaleFactor * speedMultiplier;

            // Other settings will be applied in their respective functions when needed
            // For example, jump height and gravity are applied in resetGame or when jumping
        }

        function toggleSettingsPanel() {
            if (currentState === GameState.SETTINGS) {
                // Close settings panel
                if (settingsPanel) settingsPanel.style.display = 'none';
                currentState = GameState.READY;
                updateUI();
            } else if (currentState === GameState.READY || currentState === GameState.GAMEOVER) {
                // Open settings panel
                if (settingsPanel) settingsPanel.style.display = 'flex';
                currentState = GameState.SETTINGS;
                updateUI();
            }
        }

        // --- Obstacle Definitions ---
        console.log("Defining obstacle data...");
        const ObstacleType = { PALLET_4: 'PALLET_4', PALLET_6: 'PALLET_6', LOG: 'LOG', STUMP: 'STUMP', STUMP_HIGH: 'STUMP_HIGH', OWL: 'OWL', FLYING_UNI: 'FLYING_UNI' };
        const obstacleData = { // Sorgfältig geprüft, korrekte Variablennamen verwendet
            [ObstacleType.PALLET_4]:   { img: pallet4Img,   baseWidth: 90 * globalSizeFactor,  baseHeight: 40 * globalSizeFactor, category: 'ground', level: 'LOW', hitboxOffsetX: 35 * globalSizeFactor },
            [ObstacleType.PALLET_6]:   { img: pallet6Img,   baseWidth: 90 * globalSizeFactor,  baseHeight: 60 * globalSizeFactor, category: 'ground', level: 'MED', hitboxOffsetX: 35 * globalSizeFactor },
            [ObstacleType.LOG]:        { img: logImg,       baseWidth: 100 * globalSizeFactor, baseHeight: 35 * globalSizeFactor, category: 'ground', level: 'LOW', hitboxOffsetX: 45 * globalSizeFactor },
            [ObstacleType.STUMP]:      { img: stumpImg,     baseWidth: 45 * globalSizeFactor,  baseHeight: 55 * globalSizeFactor, category: 'ground', level: 'MED', hitboxOffsetX: 10 * globalSizeFactor },
            [ObstacleType.STUMP_HIGH]: { img: stumpImg,     baseWidth: 45 * globalSizeFactor,  baseHeight: 55 * globalSizeFactor, category: 'ground', level: 'HIGH', isHigh: true, hitboxOffsetX: 10 * globalSizeFactor },
            [ObstacleType.OWL]:        { img: owlImg,       baseWidth: 60 * globalSizeFactor,  baseHeight: 50 * globalSizeFactor, category: 'sky', hitboxOffsetX: 10 * globalSizeFactor, hitboxOffsetY: 10 * globalSizeFactor },
            [ObstacleType.FLYING_UNI]: { img: flyingUniImg, baseWidth: 70 * globalSizeFactor,  baseHeight: 65 * globalSizeFactor, category: 'sky', hitboxOffsetX: 15 * globalSizeFactor, hitboxOffsetY: 15 * globalSizeFactor }
        }; // Syntax OK.
        const groundObstacleTypes = [ObstacleType.PALLET_4, ObstacleType.PALLET_6, ObstacleType.LOG, ObstacleType.STUMP];
        const skyObstacleTypes = [ObstacleType.OWL, ObstacleType.FLYING_UNI];
        console.log("Obstacle data defined.");

        // --- Game Loop ---
        let lastTime = 0; let animationFrameId = null; let gameTime = 0;

        // --- Initialization ---
        function init() {
            console.log(">>> init() started");
            if (!canvas || !ctx) { console.error("Init aborted: Canvas/Context missing."); return; }
            try {
                loadHighScore();
                initializeSettings();
                setupDOM();
                resizeCanvas();
                createHearts();
                resetGame();
                addEventListeners();
                currentState = GameState.READY;
                updateUI();
                lastTime = performance.now();
                if (!animationFrameId) animationFrameId = requestAnimationFrame(gameLoop);
                console.log("init: Animation loop started");
            } catch (error) {
                console.error("##### CRITICAL ERROR IN INIT #####", error);
                alert("Game Initialization Failed!");
            }
            console.log(">>> init() finished");
        }

        // --- Setup DOM ---
        function setupDOM() {
            if(highScoreElement) highScoreElement.textContent = highScore;
            if (duckButton) {
                 if (duckButtonImg.complete && duckButtonImg.naturalWidth > 0) { duckButton.innerHTML = ''; duckButton.appendChild(duckButtonImg.cloneNode()); }
                 else { duckButton.textContent = '↓'; if (!duckButtonImg.hasAttribute('data-onload-set')) { duckButtonImg.onload = () => { const btn = document.getElementById('duckButton'); if (btn) { btn.innerHTML = ''; btn.appendChild(duckButtonImg.cloneNode()); }}; duckButtonImg.setAttribute('data-onload-set', 'true'); } }
            }
            if(fuchsSelect) fuchsSelect.classList.toggle('selected', character === 'fuchs');
            if(waschbaerSelect) waschbaerSelect.classList.toggle('selected', character === 'waschbaer');
        }

        // --- Resize Canvas ---
        function resizeCanvas() {
            if (!gameContainer || !canvas) { return; }
            const cw = gameContainer.clientWidth; const ch = gameContainer.clientHeight; if (cw === 0 || ch === 0) return;
            canvas.width = cw; canvas.height = ch; scaleFactor = (cw / baseWidth) * globalSizeFactor; groundHeight = 30 * scaleFactor;

            if (player && player.width) {
                const ps = 70; // Base player size
                const ss = ps * scaleFactor; // Scaled size

                // Make player width slimmer while keeping the height the same
                player.width = ss * playerWidthRatio;  // Slimmer width (90% of normal)
                player.baseHeight = ss;  // Normal height
                player.duckHeight = (ps/2) * scaleFactor;
                player.height = isDucking ? player.duckHeight : player.baseHeight;

                player.x = 50 * scaleFactor;
                player.y = ch - groundHeight - player.height;

                // Apply gravity settings based on difficulty
                const gravityMultiplier = difficultyValues.gravity[gameSettings.jumpHeightLevel];
                player.gravity = baseGravity * scaleFactor * gravityMultiplier;

                // Apply jump height settings based on difficulty
                const jumpMultiplier = difficultyValues.jumpHeight[gameSettings.jumpHeightLevel];
                player.jumpStrength = baseJumpStrength * scaleFactor * jumpMultiplier;
            }
        }

        // --- High Score, Hearts ---
        function loadHighScore() { try{const s=localStorage.getItem('pixelRunnerHighScore');highScore=s?parseInt(s):0;}catch(e){highScore=0;} }
        function saveHighScore() { const fs=Math.floor(score/10);if(fs>highScore){highScore=fs;try{localStorage.setItem('pixelRunnerHighScore',highScore);if(highScoreElement)highScoreElement.textContent=highScore;}catch(e){}} }

        // --- Verbesserte Herz-Anzeige ---
        function createHearts() {
            if(!livesDisplay) return;

            // Container leeren
            livesDisplay.innerHTML = '';
            console.log("Herzen werden erstellt, maxLives:", maxLives);

            // Herzen mit korrekter Initialisierung erstellen
            for (let i = 0; i < maxLives; i++) {
                const h = document.createElement('span');
                h.classList.add('heart');
                h.innerHTML = '♥';
                h.setAttribute('data-index', i); // Index für Debugging hinzufügen

                // Herzen standardmäßig sichtbar machen
                h.style.visibility = 'visible';
                h.style.opacity = '1';
                h.style.transform = 'scale(1)';

                livesDisplay.appendChild(h);
                console.log(`Herz ${i} erstellt`);
            }

            // Anzeige sofort aktualisieren
            updateLivesDisplay();
        }

        // --- DEUTLICH VERBESSERTE Lebenanzeigeaktualisierung ---
        function updateLivesDisplay() {
            if(!livesDisplay) {
                console.error("Fehler: livesDisplay Element nicht gefunden!");
                return;
            }

            console.log("Herz-Anzeige wird aktualisiert, aktuelle Leben:", lives);

            // Container zuerst leeren und dann neu aufbauen für konsistenten Zustand
            livesDisplay.innerHTML = '';

            // Herzen neu erstellen, um eine zuverlässige Anzeige zu garantieren
            for (let i = 0; i < maxLives; i++) {
                const heart = document.createElement('span');
                heart.className = 'heart';
                heart.innerHTML = '♥';
                heart.setAttribute('data-index', i);

                // Herz sofort korrekt anzeigen oder verstecken
                if (i >= lives) {
                    heart.classList.add('hidden');
                    console.log(`Herz ${i} direkt versteckt erstellt`);
                } else {
                    console.log(`Herz ${i} sichtbar erstellt`);
                }

                livesDisplay.appendChild(heart);
            }

            // Feedback zu den aktuellen Herzen in der Konsole
            console.log(`Herzanzeige aktualisiert: ${lives}/${maxLives} Leben`);
        }

        // --- resetGame - Verbessert für Timer und Einstellungen ---
        function resetGame() {
            console.log("resetGame: Running...");
            if (!canvas || !ctx) { console.error("resetGame: Canvas/Context missing."); return; }
            score=0;
            gameTime=0;

            // Apply speed setting based on difficulty level
            const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];
            speed = baseSpeed * scaleFactor * speedMultiplier;

            backgroundX=0;
            lives=maxLives;
            isDucking=false;
            isNight=false;

            // FIXED: Reset invulnerability properly
            resetInvulnerability();

            obstacles=[];
            clouds=[];

            // --- Verbesserte Timer-Initialisierung mit 4-Stufen-System ---
            const spawnRules = getSpawnRules(gameSettings.spawnRateLevel);

            // Haupt-Timer
            obstacleTimer = initialObstacleCooldown;

            // Zufällige Startzeiten für alle Timer basierend auf Regelwerk
            const baseGround = initialObstacleCooldown * (0.8 + Math.random() * 0.4);
            const baseSky = initialObstacleCooldown * (0.7 + Math.random() * 0.5);

            groundObstacleTimer = baseGround;
            skyObstacleTimer = spawnRules.staggered ? baseGround + (spawnRules.groundInterval / 2) : baseSky;

            // Sekundäre Timer mit weiteren zufälligen Offsets
            groundObstacleTimerOffset = baseGround * 0.5 + Math.random() * baseGround * 0.5;
            skyObstacleTimerOffset = baseSky * 0.5 + Math.random() * baseSky * 0.5;

            cloudTimer = (2 + Math.random() * 3);

            const ps = 70 * globalSizeFactor; // Base player size
            const ss = ps * scaleFactor; // Scaled size
            const ch = canvas.height || 0;
            if (ch <= 0) return;

            // Apply gravity and jump settings based on difficulty
            const gravityMultiplier = difficultyValues.gravity[gameSettings.jumpHeightLevel];
            const jumpMultiplier = difficultyValues.jumpHeight[gameSettings.jumpHeightLevel];

            player = {
                x: 50 * scaleFactor,
                y: ch - groundHeight - ss,
                width: ss * playerWidthRatio, // Slimmer width (90% of normal)
                height: ss,
                baseHeight: ss,
                duckHeight: (ps/2) * scaleFactor,
                vy: 0,
                // Apply gravity and jump settings
                gravity: baseGravity * scaleFactor * gravityMultiplier,
                jumpStrength: baseJumpStrength * scaleFactor * jumpMultiplier,
                jumping: false,
                canDoubleJump: false,
                hasDoubleJumped: false,
                image: (character === 'fuchs' ? fuchsImg : waschbaerImg)
            };

            if(!(player.image && player.image.complete && player.image.naturalWidth>0)) { /* Warnung möglich */ }
            if(document.body) document.body.style.backgroundColor = '#e0e0e0'; // Start mit hellem Body-BG

            // Clear hitbox debug overlay
            if (debugOverlay) {
                debugOverlay.innerHTML = '';
            }

            // Leben-Anzeige aktualisieren
            updateLivesDisplay();

            console.log("resetGame: Finished. Lives:", lives, "Invulnerable:", isInvulnerable);
        }

        // --- NEUE FUNKTION: Setzt die Unverwundbarkeit zurück ---
        // --- ROBUSTE FUNKTION zum Zurücksetzen der Unverwundbarkeit ---
        function resetInvulnerability() {
            console.log("### UNVERWUNDBARKEIT WIRD VOLLSTÄNDIG ZURÜCKGESETZT ###");

            // Status eindeutig setzen
            isInvulnerable = false;

            // Timer sauber entfernen
            if (invulnerabilityTimer) {
                console.log("Bestehender Unverwundbarkeits-Timer wird gelöscht");
                clearTimeout(invulnerabilityTimer);
                invulnerabilityTimer = null;
            }

            // Alle visuellen Indikatoren entfernen
            if (gameContainer) {
                const indicators = gameContainer.querySelectorAll('.player-invulnerable-indicator');
                if (indicators.length > 0) {
                    console.log(`${indicators.length} Unverwundbarkeits-Indikatoren werden entfernt`);
                    indicators.forEach(indicator => {
                        if (indicator.parentNode) {
                            indicator.parentNode.removeChild(indicator);
                        }
                    });
                }
            }

            console.log("Unverwundbarkeit erfolgreich zurückgesetzt");
        }

        // --- Hilfsfunktion für Spawn-Regeln basierend auf Schwierigkeitsgrad ---
        function getSpawnRules(difficultyLevel) {
            switch(difficultyLevel) {
                case 'easy': return SpawnRules.EASY;
                case 'normal': return SpawnRules.NORMAL;
                case 'hard': return SpawnRules.HARD;
                case 'veryHard': return SpawnRules.VERY_HARD;
                default: return SpawnRules.NORMAL;
            }
        }

        // --- Hilfsfunktion für Hitbox-Größen basierend auf Schwierigkeitsgrad ---
        function getHitboxSize(difficultyLevel) {
            switch(difficultyLevel) {
                case 'easy': return HitboxSizes.EASY;
                case 'normal': return HitboxSizes.NORMAL;
                case 'hard': return HitboxSizes.HARD;
                case 'veryHard': return HitboxSizes.VERY_HARD;
                default: return HitboxSizes.NORMAL;
            }
        }

        // --- Hilfsfunktion für Flughöhen basierend auf Schwierigkeitsgrad ---
        function getFlyingHeight(difficultyLevel) {
            switch(difficultyLevel) {
                case 'easy': return FlyingHeights.EASY;
                case 'normal': return FlyingHeights.NORMAL;
                case 'hard': return FlyingHeights.HARD;
                case 'veryHard': return FlyingHeights.VERY_HARD;
                default: return FlyingHeights.NORMAL;
            }
        }

        // --- Game Logic ---
        function startGame() {
            if(currentState===GameState.PLAYING) return;
            console.log("Starting Game...");
            resetGame();
            currentState=GameState.PLAYING;
            updateUI();
            lastTime=performance.now();
            if(!animationFrameId) animationFrameId=requestAnimationFrame(gameLoop);
        }

        // --- VERBESSERTE loseLife-Funktion mit zuverlässiger Animation ---
        function loseLife() {
            // Ausführliche Debug-Ausgabe
            console.log("### loseLife AUFGERUFEN ###");
            console.log("Leben:", lives, "Unverwundbar:", isInvulnerable, "Status:", currentState);

            // Nichts tun, wenn bereits unverwundbar oder nicht im Spiel
            if(isInvulnerable || currentState !== GameState.PLAYING) {
                console.log("Kein Leben verloren - Spieler ist unverwundbar oder nicht im Spiel");
                return;
            }

            // Leben reduzieren
            lives = Math.max(0, lives - 1); // Verhindert negative Leben
            console.log("LEBEN VERLOREN! Verbleibende Leben:", lives);

            // Herzen-Anzeige sofort aktualisieren - VERBESSERT
            updateLivesDisplay();

            // Spieler unverwundbar machen
            makePlayerInvulnerable();

            // Visuelles Feedback für Treffer
            if(gameContainer) {
                // Spielcontainer-Rand rot färben
                gameContainer.style.borderColor='#ff0000';

                // Bildschirm rot aufblitzen lassen
                const flashEffect = document.createElement('div');
                flashEffect.className = 'damage-flash'; // Klasse für einfachere Identifikation
                flashEffect.style.position = 'absolute';
                flashEffect.style.top = '0';
                flashEffect.style.left = '0';
                flashEffect.style.width = '100%';
                flashEffect.style.height = '100%';
                flashEffect.style.backgroundColor = 'rgba(255,0,0,0.3)';
                flashEffect.style.pointerEvents = 'none';
                flashEffect.style.zIndex = '20';
                flashEffect.style.animation = 'fadeOut 0.5s forwards';

                // fadeOut-Animation hinzufügen, falls nicht vorhanden
                if (!document.getElementById('flashAnimation')) {
                    const style = document.createElement('style');
                    style.id = 'flashAnimation';
                    style.textContent = '@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }';
                    document.head.appendChild(style);
                }

                // Alte Flash-Effekte entfernen
                const oldFlashes = gameContainer.querySelectorAll('.damage-flash');
                oldFlashes.forEach(flash => {
                    if (flash.parentNode) flash.parentNode.removeChild(flash);
                });

                // Neuen Flash-Effekt hinzufügen
                gameContainer.appendChild(flashEffect);

                // Nach kurzer Zeit zurücksetzen
                setTimeout(() => {
                    if(gameContainer) {
                        gameContainer.style.borderColor = '#333';
                        if (flashEffect.parentNode) {
                            flashEffect.parentNode.removeChild(flashEffect);
                        }
                    }
                }, 200);
            }

            // Game Over, wenn keine Leben mehr übrig
            if(lives <= 0) {
                console.log("GAME OVER ausgelöst! Keine Leben mehr übrig.");
                gameOver();
            }
        }

        function gameOver() {
            currentState=GameState.GAMEOVER;
            saveHighScore();
            if(finalScoreElement) finalScoreElement.textContent=Math.floor(score/10);
            updateUI();
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId=null;
        }

        // --- KOMPLETT ÜBERARBEITETE ZUVERLÄSSIGE Unverwundbarkeits-Funktion ---
        function makePlayerInvulnerable() {
            console.log("### SPIELER WIRD UNVERWUNDBAR GEMACHT ###");

            // Status eindeutig setzen
            isInvulnerable = true;

            // Alten Timer sauber entfernen
            if (invulnerabilityTimer) {
                console.log("Alter Unverwundbarkeits-Timer wird gelöscht");
                clearTimeout(invulnerabilityTimer);
                invulnerabilityTimer = null;
            }

            // Visuellen Indikator aktivieren
            if (player) {
                // Zusätzliche visuelle Anzeige direkt am Spieler
                const playerFlash = document.createElement('div');
                playerFlash.className = 'player-invulnerable-indicator';
                playerFlash.style.position = 'absolute';
                playerFlash.style.left = `${player.x}px`;
                playerFlash.style.top = `${player.y}px`;
                playerFlash.style.width = `${player.width}px`;
                playerFlash.style.height = `${player.height}px`;
                playerFlash.style.border = '2px solid yellow';
                playerFlash.style.borderRadius = '50%';
                playerFlash.style.boxShadow = '0 0 10px yellow';
                playerFlash.style.animation = 'pulsate 0.5s infinite alternate';
                playerFlash.style.pointerEvents = 'none';
                playerFlash.style.zIndex = '11';

                // Pulsier-Animation für Unverwundbarkeit
                if (!document.getElementById('pulsateAnimation')) {
                    const style = document.createElement('style');
                    style.id = 'pulsateAnimation';
                    style.textContent = '@keyframes pulsate { 0% { opacity: 0.3; } 100% { opacity: 0.7; } }';
                    document.head.appendChild(style);
                }

                if (gameContainer) {
                    // Alten Indikator entfernen falls vorhanden
                    const oldIndicator = gameContainer.querySelector('.player-invulnerable-indicator');
                    if (oldIndicator && oldIndicator.parentNode) {
                        oldIndicator.parentNode.removeChild(oldIndicator);
                    }

                    gameContainer.appendChild(playerFlash);
                }

                console.log("Unverwundbarkeits-Effekte angewendet");
            }

            // Neuen Timer setzen - mit Darstellung der verbleibenden Zeit
            console.log(`Starte Unverwundbarkeit für ${invulnerabilityDuration/1000} Sekunden`);
            let timeLeft = invulnerabilityDuration;

            // Erstelle eine Funktion, die die Unverwundbarkeit beendet
            const endInvulnerability = () => {
                console.log("### UNVERWUNDBARKEIT BEENDET ###");
                isInvulnerable = false;
                invulnerabilityTimer = null;

                // Entferne den visuellen Indikator
                if (gameContainer) {
                    const indicator = gameContainer.querySelector('.player-invulnerable-indicator');
                    if (indicator && indicator.parentNode) {
                        indicator.parentNode.removeChild(indicator);
                    }
                }
            };

            // Verwende einen robusten Timer
            invulnerabilityTimer = setTimeout(endInvulnerability, invulnerabilityDuration);

            console.log(`Unverwundbarkeits-Timer gesetzt für ${invulnerabilityDuration}ms`);
        }

        function togglePause() {
            if(currentState===GameState.PLAYING){
                currentState=GameState.PAUSED;
                if(animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId=null;
            } else if(currentState===GameState.PAUSED){
                currentState=GameState.PLAYING;
                lastTime=performance.now();
                animationFrameId=requestAnimationFrame(gameLoop);
            }
            updateUI();
        }

        function quitGame() {
            if(currentState===GameState.PLAYING||currentState===GameState.PAUSED) saveHighScore();
            alert("Game ended.");
            try{window.close();}catch(e){}
            currentState=GameState.GAMEOVER;
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId=null;
            updateUI();
        }

        // Back to Menu Function
        function backToMenu() {
            if (currentState === GameState.PLAYING || currentState === GameState.PAUSED) {
                saveHighScore();
                currentState = GameState.READY;
                resetGame();
                updateUI();
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        function jump() {
            if(currentState!==GameState.PLAYING||isDucking||!player||typeof player.vy==='undefined') return;
            if(!player.jumping){
                player.vy = player.jumpStrength;
                player.jumping=true;
                player.canDoubleJump=true;
                player.hasDoubleJumped=false;
            } else if(player.canDoubleJump&&!player.hasDoubleJumped){
                player.vy = player.jumpStrength * 0.8;
                player.canDoubleJump=false;
                player.hasDoubleJumped=true;
                createDoubleJumpEffect();
            }
        }

        function setDucking(sd) {
            if(currentState!==GameState.PLAYING||player.jumping||!player||typeof player.height==='undefined') return;
            if(sd&&!isDucking){
                isDucking=true;
                player.height=player.duckHeight;
                player.y=canvas.height-groundHeight-player.height;
            } else if(!sd&&isDucking){
                isDucking=false;
                player.height=player.baseHeight;
                player.y=canvas.height-groundHeight-player.height;
                checkCollision();
            }
        }

        function createDoubleJumpEffect() {
            try{
                if(!player||!player.width) return;
                const s=player.width*1.2;
                const e=document.createElement('div');
                e.className='doubleJumpEffect';
                const cr=gameContainer.getBoundingClientRect();
                const cvr=canvas.getBoundingClientRect();
                const ox=cvr.left-cr.left;
                const oy=cvr.top-cr.top;
                e.style.width=`${s}px`;
                e.style.height=`${s}px`;
                e.style.left=`${ox+player.x+player.width/2-s/2}px`;
                e.style.top=`${oy+player.y+player.height/2-s/2}px`;
                if(gameContainer) gameContainer.appendChild(e);
                setTimeout(()=>{if(e.parentNode)e.remove();},400);
            }catch(err){}
        }

        // --- createObstacle - Verbessert für verschiedene Schwierigkeitsgrade und tiefere Flughöhe ---
        function createObstacle(category = null) {
            try {
                let chosenType = null;
                let availableGroundTypes = [...groundObstacleTypes]; // Kopie der Basis-Bodentypen

                // Hohen Baumstumpf hinzufügen, wenn Zeit abgelaufen
                if (gameTime > highStumpMinTime) {
                    availableGroundTypes.push(ObstacleType.STUMP_HIGH);
                }

                // Wenn keine Kategorie angegeben ist, zufällig entscheiden
                if (category === null) {
                    category = Math.random() < 0.70 ? 'ground' : 'sky';
                }

                if (category === 'ground') {
                    const randIdx = Math.floor(Math.random() * availableGroundTypes.length);
                    chosenType = availableGroundTypes[randIdx];
                } else {
                    const randIdx = Math.floor(Math.random() * skyObstacleTypes.length);
                    chosenType = skyObstacleTypes[randIdx];
                }

                const data = obstacleData[chosenType];
                if (!data) { console.error("Obstacle data missing for type:", chosenType); return; } // Sicherheitscheck

                const scaledWidth = data.baseWidth * scaleFactor;
                const scaledHeight = data.baseHeight * scaleFactor;
                let yPos;

                if (data.category === 'ground') {
                    yPos = canvas.height - groundHeight - scaledHeight;
                    // Optional: Leichte Höhenanpassung für spezielle Typen hier möglich
                    if (data.isHigh) { yPos -= 20 * scaleFactor; } // Höhenjustierung für STUMP_HIGH
                } else { // Positionierung von Flug-Hindernissen
                    // Flughöhen-Einstellungen abrufen
                    const flyingHeightSettings = getFlyingHeight(gameSettings.flyingHeightLevel);

                    // Basiswerte - VOLLSTÄNDIG ANGEPASST für deutlich tiefere Flugobjekte
                    const minTopMargin = 30 * scaleFactor; // STARK REDUZIERT: Von 120 auf 80, dann auf 50, jetzt auf 30 für extrem tiefe Flughöhen
                    const playerClearance = player.baseHeight ? player.baseHeight * 0.7 : 40 * scaleFactor; // NOCHMALS REDUZIERT: von 1.3 auf 1.1, dann auf 0.9, jetzt auf 0.7
                    const safeSkyBottom = canvas.height - groundHeight - playerClearance; // Untere Grenze noch tiefer angesetzt
                    const duckHeight = player.duckHeight || (player.baseHeight * 0.5);

                    // Gesamthöhenbereich berechnen
                    const totalHeight = safeSkyBottom - minTopMargin;

                    // Höhenfaktor und Zufallsbereich anwenden
                    const heightFactor = flyingHeightSettings.heightFactor;
                    const randomness = flyingHeightSettings.randomness;

                    // Bei "Sehr Schwer" spezielle Logik für Duck-Höhe
                    if (gameSettings.flyingHeightLevel === 'veryHard') {
                        // Höhe berechnen, die Ducken erforderlich macht
                        const duckRequiredY = canvas.height - groundHeight - player.baseHeight + (player.baseHeight - duckHeight) / 2;
                        yPos = duckRequiredY - (scaledHeight / 2); // Objekt in Duck-Höhe zentrieren
                    } else {
                        // Normale Höhenberechnung für andere Schwierigkeitsgrade
                        yPos = minTopMargin + (totalHeight * heightFactor);
                    }

                    // Zufälligkeit hinzufügen, umgekehrt proportional zum Schwierigkeitsgrad
                    const randomRange = totalHeight * randomness;
                    yPos += (Math.random() - 0.5) * randomRange;

                    // Sicherstellen, dass wir im sicheren Bereich bleiben
                    yPos = Math.max(minTopMargin, Math.min(safeSkyBottom - scaledHeight, yPos));
                }

                // Hindernis mit allen erforderlichen Informationen erstellen
                console.log(`Erstelle ${chosenType} Hindernis auf Position ${yPos}`);
                obstacles.push({
                    x: canvas.width, // Start rechts außerhalb
                    y: yPos,
                    width: scaledWidth,
                    height: scaledHeight,
                    type: chosenType,
                    image: data.img, // Referenz auf das Image-Objekt speichern
                    category: data.category // Kategorie speichern für spätere Logik
                });
            } catch(err) {
                 console.error("Fehler in createObstacle:", err);
            }
        }

        // --- createCloud - Mit angepasster Y-Position
        function createCloud() {
            const bw = 60 * globalSizeFactor;
            const bh = 30 * globalSizeFactor;
            const sw = bw * scaleFactor;
            const sh = bh * scaleFactor;
            clouds.push({
                x: canvas.width,
                // --- HIER DIE ÄNDERUNG FÜR WOLKEN ---
                y: (100 + Math.random() * 100) * scaleFactor, // << GEÄNDERT: Startet tiefer und hat größeren Bereich nach unten
                // --- ENDE ÄNDERUNG ---
                width: sw,
                height: sh,
                speed: (baseSpeed * (0.2 + Math.random() * 0.3)) * scaleFactor * difficultyValues.speed[gameSettings.speedLevel]
            });
        }

        // --- Update ---
        function update(dt) {
            if(currentState!==GameState.PLAYING) return;
            gameTime+=dt;
            updatePlayer(dt);
            updateObstacles(dt);
            updateClouds(dt);
            updateScore(dt);
            updateBackground(dt);
            updateDifficulty(dt);

            // Kollisionsprüfung am Ende des Update-Zyklus
            checkCollision();
        }

        function updatePlayer(dt) {
            if(!player||typeof player.vy==='undefined') return;
            player.vy += player.gravity * dt;
            player.y += player.vy * dt;
            const gl = canvas.height - groundHeight - player.height;
            if(player.y >= gl){
                player.y = gl;
                player.vy = 0;
                if(player.jumping){
                    player.jumping = false;
                    player.canDoubleJump = false;
                    player.hasDoubleJumped = false;
                    setDucking(isDucking);
                }
            }
        }

        // --- updateObstacles - Verbessert mit 4-Stufen-System ---
        function updateObstacles(dt) {
            // Erst die bestehenden Hindernisse aktualisieren
            for(let i=obstacles.length-1; i>=0; i--){
                // Geschwindigkeit basierend auf Schwierigkeitsgrad anwenden
                obstacles[i].x -= speed * dt;
                if(obstacles[i].x + obstacles[i].width < 0) obstacles.splice(i, 1);
            }

            // Spawn-Regeln für aktuellen Schwierigkeitsgrad abrufen
            const spawnRules = getSpawnRules(gameSettings.spawnRateLevel);

            // --- Je nach Schwierigkeitsgrad unterschiedliche Spawn-Logik verwenden ---

            // Gemeinsamer Timer für einfache Schwierigkeitsgrade
            if (!spawnRules.independent) {
                // Für leichtere Schwierigkeitsgrade: alternierendes System mit etwas Zufall
                obstacleTimer -= dt;

                // Kleine Zufallschance für Spawns unabhängig vom Timer
                const randomSpawn = Math.random() < spawnRules.randomTriggerChance;

                if (obstacleTimer <= 0 || randomSpawn) {
                    // Bei einfacheren Levels ist die Auswahl halbwegs vorhersehbar
                    let nextType;

                    // Manchmal Zufall, manchmal Alternieren
                    if (Math.random() < 0.3) {
                        // Zufällige Auswahl mit Tendenz zu mehr Boden-Hindernissen
                        nextType = Math.random() < 0.6 ? 'ground' : 'sky';
                    } else {
                        // Alternierendes Muster für etwas Vorhersehbarkeit
                        if (obstacles.length > 0) {
                            const lastObstacle = obstacles[obstacles.length-1];
                            nextType = lastObstacle.category === 'ground' ? 'sky' : 'ground';
                        } else {
                            nextType = 'ground';
                        }
                    }

                    // Hindernis erstellen
                    createObstacle(nextType);

                    // Interval basierend auf Schwierigkeitsgrad setzen
                    let baseInterval = nextType === 'ground' ? spawnRules.groundInterval : spawnRules.skyInterval;

                    // Zufallsvarianz hinzufügen
                    const variance = baseInterval * spawnRules.randomVariation;
                    obstacleTimer = baseInterval + ((Math.random() * 2 - 1) * variance);
                }
            }
            // Unabhängige Timer für schwerere Schwierigkeitsgrade
            else {
                // Unabhängige Timer für Boden- und Flug-Hindernisse

                // Boden-Hindernis-Timer
                groundObstacleTimer -= dt;
                groundObstacleTimerOffset -= dt;

                // Wenn ein Boden-Timer 0 erreicht, ein Boden-Hindernis spawnen
                if (groundObstacleTimer <= 0 || groundObstacleTimerOffset <= 0 || Math.random() < spawnRules.randomTriggerChance) {
                    // Manchmal kein Spawn trotz Timer-Auslösung (für mehr Unvorhersehbarkeit)
                    if (Math.random() < 0.9) {
                        createObstacle('ground');
                    }

                    // Zufällige neue Zeiten berechnen
                    const baseTime = spawnRules.groundInterval;
                    const variance = baseTime * spawnRules.randomVariation;

                    // Den ausgelösten Timer zurücksetzen
                    if (groundObstacleTimer <= 0) {
                        groundObstacleTimer = baseTime + ((Math.random() * 2 - 1) * variance);
                    }
                    if (groundObstacleTimerOffset <= 0) {
                        groundObstacleTimerOffset = baseTime + ((Math.random() * 2 - 1) * variance);
                    }
                }

                // Flug-Hindernis-Timer
                skyObstacleTimer -= dt;
                skyObstacleTimerOffset -= dt;

                // Wenn ein Flug-Timer 0 erreicht, ein Flug-Hindernis spawnen
                if (skyObstacleTimer <= 0 || skyObstacleTimerOffset <= 0 || Math.random() < spawnRules.randomTriggerChance) {
                    // Manchmal kein Spawn trotz Timer-Auslösung
                    if (Math.random() < 0.9) {
                        createObstacle('sky');
                    }

                    // Zufällige neue Zeiten berechnen
                    const baseTime = spawnRules.skyInterval;
                    const variance = baseTime * spawnRules.randomVariation;

                    // Den ausgelösten Timer zurücksetzen
                    if (skyObstacleTimer <= 0) {
                        skyObstacleTimer = baseTime + ((Math.random() * 2 - 1) * variance);
                    }
                    if (skyObstacleTimerOffset <= 0) {
                        skyObstacleTimerOffset = baseTime + ((Math.random() * 2 - 1) * variance);
                    }
                }
            }
        }

        function updateClouds(dt) {
            for(let i=clouds.length-1; i>=0; i--){
                clouds[i].x -= clouds[i].speed * dt;
                if(clouds[i].x + clouds[i].width < 0) clouds.splice(i, 1);
            }
            cloudTimer -= dt;
            if(cloudTimer <= 0 && clouds.length < 5){
                createCloud();
                // Cloud spawn rate is simpler and less affected by difficulty
                cloudTimer = 3 + Math.random() * 5;
            }
        }

        function updateScore(dt) {
            if(!scoreElement) return;
            // Apply speed setting to score calculation
            const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];
            score += (speed / scaleFactor) * dt * 0.1;
            scoreElement.textContent = Math.floor(score/10);
        }

        // --- updateDifficulty - Mit konsistenter Hitbox und dynamischer Geschwindigkeit ---
function updateDifficulty(dt) {
    // Get the speed multiplier from settings
    const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];

    // Apply speed increment based on speed setting and game progress
    speed += (speedIncrement * baseSpeed) * scaleFactor * speedMultiplier * dt;

    // Flughöhen-Logik für fliegende Hindernisse
    const tier = Math.floor(Math.floor(score/10)/100);
    const night = tier % 2 !== 0;
    if(night !== isNight) {
        isNight = night;
        if(document.body) document.body.style.backgroundColor = isNight ? '#2d2d3a' : '#e0e0e0';
    }

    // Flughöhen-Logik basierend auf Spielzeit
    const timeInGame = gameTime;
    const timeInMinutes = timeInGame / 60;

    // Flughöhen-Einstellungen basierend auf Schwierigkeitsgrad
    const flyingHeightSettings = getFlyingHeight(gameSettings.flyingHeightLevel);

    // 30% Variation ab 30 Sekunden
    if (timeInMinutes >= 0.5) {
        const heightVariation = 0.3;
        flyingHeightSettings.heightFactor = Math.min(0.95, flyingHeightSettings.heightFactor + (heightVariation * (timeInMinutes - 0.5) * 2));
    }

    // 64% Wahrscheinlichkeit bei 1 Minute
    if (timeInMinutes >= 1.0) {
        const targetHeight = 0.64;
        flyingHeightSettings.heightFactor = Math.min(0.95, flyingHeightSettings.heightFactor + (targetHeight * (timeInMinutes - 1.0)));
    }

    // Duck-Logik für fliegende Hindernisse
    if (gameSettings.flyingHeightLevel === 'veryHard') {
        // Bei "Sehr Schwer" spezielle Logik für Duck-Höhe
        const duckRequiredY = canvas.height - groundHeight - player.baseHeight + (player.baseHeight - player.duckHeight) / 2;
        flyingHeightSettings.heightFactor = Math.min(0.95, flyingHeightSettings.heightFactor + (timeInMinutes * 0.1));
    }
}

// --- createObstacle - Verbessert für verschiedene Schwierigkeitsgrade und tiefere Flughöhe ---
function createObstacle(category = null) {
    try {
        let chosenType = null;
        let availableGroundTypes = [...groundObstacleTypes]; // Kopie der Basis-Bodentypen

        // Hohen Baumstumpf hinzufügen, wenn Zeit abgelaufen
        if (gameTime > highStumpMinTime) {
            availableGroundTypes.push(ObstacleType.STUMP_HIGH);
        }

        // Wenn keine Kategorie angegeben ist, zufällig entscheiden
        if (category === null) {
            category = Math.random() < 0.70 ? 'ground' : 'sky';
        }

        if (category === 'ground') {
            const randIdx = Math.floor(Math.random() * availableGroundTypes.length);
            chosenType = availableGroundTypes[randIdx];
        } else {
            const randIdx = Math.floor(Math.random() * skyObstacleTypes.length);
            chosenType = skyObstacleTypes[randIdx];
        }

        const data = obstacleData[chosenType];
        if (!data) { console.error("Obstacle data missing for type:", chosenType); return; } // Sicherheitscheck

        const scaledWidth = data.baseWidth * scaleFactor;
        const scaledHeight = data.baseHeight * scaleFactor;
        let yPos;

        if (data.category === 'ground') {
            yPos = canvas.height - groundHeight - scaledHeight;
            // Optional: Leichte Höhenanpassung für spezielle Typen hier möglich
            if (data.isHigh) { yPos -= 20 * scaleFactor; } // Höhenjustierung für STUMP_HIGH
        } else { // Positionierung von Flug-Hindernissen
            // Basiswerte - VOLLSTÄNDIG ANGEPASST für deutlich tiefere Flugobjekte
            const minTopMargin = 30 * scaleFactor; // STARK REDUZIERT: Von 120 auf 80, dann auf 50, jetzt auf 30 für extrem tiefe Flughöhen
            const playerClearance = player.baseHeight ? player.baseHeight * 0.7 : 40 * scaleFactor; // NOCHMALS REDUZIERT: von 1.3 auf 1.1, dann auf 0.9, jetzt auf 0.7
            const safeSkyBottom = canvas.height - groundHeight - playerClearance; // Untere Grenze noch tiefer angesetzt
            const duckHeight = player.duckHeight || (player.baseHeight * 0.5);

            // Gesamthöhenbereich berechnen
            const totalHeight = safeSkyBottom - minTopMargin;

            // Höhenfaktor und Zufallsbereich anwenden
            const flyingHeightSettings = getFlyingHeight(gameSettings.flyingHeightLevel);
            const heightFactor = flyingHeightSettings.heightFactor;
            const randomness = flyingHeightSettings.randomness;

            // Bei "Sehr Schwer" spezielle Logik für Duck-Höhe
            if (gameSettings.flyingHeightLevel === 'veryHard') {
                // Höhe berechnen, die Ducken erforderlich macht
                const duckRequiredY = canvas.height - groundHeight - player.baseHeight + (player.baseHeight - duckHeight) / 2;
                yPos = duckRequiredY - (scaledHeight / 2); // Objekt in Duck-Höhe zentrieren
            } else {
                // Normale Höhenberechnung für andere Schwierigkeitsgrade
                yPos = minTopMargin + (totalHeight * heightFactor);
            }

            // Zufälligkeit hinzufügen, umgekehrt proportional zum Schwierigkeitsgrad
            const randomRange = totalHeight * randomness;
            yPos = Math.max(minTopMargin, Math.min(safeSkyBottom - scaledHeight, yPos + (Math.random() - 0.5) * randomRange));
        }

        // Hindernis mit allen erforderlichen Informationen erstellen
        console.log(`Erstelle ${chosenType} Hindernis auf Position ${yPos}`);
        obstacles.push({
            x: canvas.width, // Start rechts außerhalb
            y: yPos,
            width: scaledWidth,
            height: scaledHeight,
            type: chosenType,
            image: data.img, // Referenz auf das Image-Objekt speichern
            category: data.category // Kategorie speichern für spätere Logik
        });
    } catch(err) {
         console.error("Fehler in createObstacle:", err);
    }
}

        // --- updateBackground - Nutzt neue BG Logik ---
        function updateBackground(dt) {
            const img = isNight ? nightBgImg : dayBgImg;
            if (!img || !img.complete || img.naturalWidth === 0) return;
            const h = canvas.height;
            const r = img.naturalWidth / img.naturalHeight;
            let sw = h * r;
            if(sw < canvas.width) sw = canvas.width;

            // Apply speed setting to parallax
            const speedMultiplier = difficultyValues.speed[gameSettings.speedLevel];
            backgroundX -= (speed * 0.3) * dt;
            if(backgroundX <= -sw) backgroundX += sw;
        }

        // --- KOMPLETT ÜBERARBEITETE checkCollision mit zuverlässigerer Erkennung ---
        function checkCollision() {
            // Debug-Ausgabe für Kollisionsprüfung
            if (gameSettings.showHitboxes) {
                console.log("Prüfe Kollisionen. Unverwundbar:", isInvulnerable);
            }

            // Sicherheitsüberprüfungen
            if (!player) {
                console.error("Kollisionsprüfung: Player-Objekt fehlt!");
                return;
            }

            // Status-Check
            if (currentState !== GameState.PLAYING) {
                return;
            }

            // Kollisionsprüfung überspringen, wenn unverwundbar
            if (isInvulnerable) {
                if (gameSettings.showHitboxes) {
                    console.log("Kollisionsprüfung übersprungen - Spieler ist unverwundbar");
                }
                return;
            }

            // Konsistente Hitbox-Größe basierend auf Schwierigkeitsgrad verwenden
            const hitboxSize = getHitboxSize(gameSettings.hitboxSizeLevel);

            // Spieler-Hitbox mit einheitlicher Verkleinerung berechnen
            const pLeft = player.x + player.width * (1-hitboxSize) / 2;
            const pTop = player.y + player.height * (1-hitboxSize) / 2;
            const pWidth = player.width * hitboxSize;
            const pHeight = player.height * hitboxSize;

            // Hitboxen visualisieren, wenn aktiviert
            if (gameSettings.showHitboxes && debugOverlay) {
                debugOverlay.innerHTML = ''; // Vorherige Hitboxen löschen

                // Spieler-Hitbox zeichnen
                const playerBox = document.createElement('div');
                playerBox.style.position = 'absolute';
                playerBox.style.left = pLeft + 'px';
                playerBox.style.top = pTop + 'px';
                playerBox.style.width = pWidth + 'px';
                playerBox.style.height = pHeight + 'px';
                playerBox.style.backgroundColor = 'rgba(0, 255, 0, 0.3)';
                playerBox.style.border = '2px solid lime';
                playerBox.style.zIndex = '100';
                debugOverlay.appendChild(playerBox);
            }

            // Jedes Hindernis prüfen
            for (const obstacle of obstacles) {
                // Hindernis-Hitbox-Verkleinerung konsistent halten
                const obstacleHitboxReduction = 0.2; // 20% kleiner als visuelle Größe

                // Hindernis-Hitbox berechnen
                const oLeft = obstacle.x + obstacle.width * obstacleHitboxReduction / 2;
                const oTop = obstacle.y + obstacle.height * obstacleHitboxReduction / 2;
                const oWidth = obstacle.width * (1 - obstacleHitboxReduction);
                const oHeight = obstacle.height * (1 - obstacleHitboxReduction);

                // Hindernis-Hitboxen visualisieren, wenn aktiviert
                if (gameSettings.showHitboxes && debugOverlay) {
                    const obstacleBox = document.createElement('div');
                    obstacleBox.style.position = 'absolute';
                    obstacleBox.style.left = oLeft + 'px';
                    obstacleBox.style.top = oTop + 'px';
                    obstacleBox.style.width = oWidth + 'px';
                    obstacleBox.style.height = oHeight + 'px';
                    obstacleBox.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                    obstacleBox.style.border = '2px solid red';
                    obstacleBox.style.zIndex = '100';
                    debugOverlay.appendChild(obstacleBox);
                }

                // AABB-Kollisionserkennung (Axis-Aligned Bounding Box)
                // Dies ist die zuverlässigste Methode für Rechteck-Kollisionen
                if (
                    pLeft < oLeft + oWidth &&
                    pLeft + pWidth > oLeft &&
                    pTop < oTop + oHeight &&
                    pTop + pHeight > oTop
                ) {
                    // Kollision erkannt!
                    console.log("KOLLISION ERKANNT mit:", obstacle.type);
                    loseLife();
                    return; // Nach Kollisionsverarbeitung beenden
                }
            }
        }

        // --- Draw ---
        function draw() {
            if(!ctx) return;
            drawBackground();
            drawClouds();
            drawGround();
            drawObstacles();
            drawPlayer();
        }

        // --- drawBackground - Nutzt neue BG Logik ---
        function drawBackground() {
            const img = isNight ? nightBgImg : dayBgImg;
            if (img && img.complete && img.naturalWidth > 0){
                const h = canvas.height;
                const r = img.naturalWidth / img.naturalHeight;
                let sw = h * r;
                let sh = h;
                let y = 0;
                if(sw < canvas.width){
                    sw = canvas.width;
                    sh = sw / r;
                    y = h - sh;
                }
                const copies = Math.ceil(canvas.width / sw) + 1;
                for(let i = 0; i < copies; i++) {
                    try {
                        ctx.drawImage(img, backgroundX + (sw * i), y, sw, sh);
                    } catch(e){
                        console.error("BG Draw Err:", e);
                        ctx.fillStyle = isNight ? '#2d2d3a' : '#87CEEB';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        break;
                    }
                }
            } else {
                ctx.fillStyle = isNight ? '#2d2d3a' : '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function drawGround() {
            if(!ctx) return;
            ctx.fillStyle = isNight ? 'rgba(40,40,50,0.8)' : 'rgba(100,140,80,0.7)';
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
            ctx.fillStyle = isNight ? 'rgba(50,50,60,0.8)' : 'rgba(120,160,100,0.7)';
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, 2 * scaleFactor);
        }

        function drawPlayer() {
            if(!ctx || !player || !player.image) return;
            ctx.globalAlpha = (isInvulnerable && currentState === GameState.PLAYING) ? (0.6 + Math.sin(Date.now() / 100) * 0.4) : 1;
            if(player.image.complete && player.image.naturalWidth > 0){
                ctx.drawImage(player.image, player.x, player.y, player.width, player.height);
            } else {
                ctx.fillStyle = (character === 'fuchs' ? '#ff6f00' : '#8d6e63');
                ctx.fillRect(player.x, player.y, player.width, player.height);
                /*Face*/
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(player.x + player.width * 0.35, player.y + player.height * 0.3, player.width * 0.08, 0, Math.PI * 2);
                ctx.arc(player.x + player.width * 0.65, player.y + player.height * 0.3, player.width * 0.08, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1 * scaleFactor;
                ctx.beginPath();
                ctx.arc(player.x + player.width * 0.5, player.y + player.height * 0.6, player.width * 0.15, 0.2 * Math.PI, 0.8 * Math.PI);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        function drawObstacles() {
            if (!ctx) return;
            for (const obstacle of obstacles) {
                try {
                    if (obstacle.image && obstacle.image.complete && obstacle.image.naturalWidth > 0) {
                        ctx.drawImage(obstacle.image, obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    } else {
                        ctx.fillStyle = obstacle.category === 'sky' ? '#ADD8E6' : '#A0522D';
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        ctx.fillStyle = '#000';
                        ctx.font = `${Math.max(10, obstacle.height * 0.2)}px Courier New`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(obstacle.type.substring(0, 3), obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                    }
                } catch (drawErr) {
                    console.error("Fehler beim Zeichnen des Hindernisses:", obstacle.type, drawErr);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                } finally {
                     ctx.textAlign = 'start';
                     ctx.textBaseline = 'alphabetic';
                }
            }
        }

        function drawClouds() {
            if(!ctx) return;
            ctx.fillStyle = isNight ? 'rgba(100,100,100,0.6)' : 'rgba(255,255,255,0.7)';
            ctx.strokeStyle = isNight ? 'rgba(80,80,80,0.6)' : 'rgba(220,220,220,0.7)';
            ctx.lineWidth = 1 * scaleFactor;
            for(const c of clouds){
                ctx.beginPath();
                ctx.ellipse(c.x + c.width / 2, c.y + c.height / 2, c.width / 2, c.height / 2, 0, 0, Math.PI * 2);
                ctx.ellipse(c.x + c.width * 0.3, c.y + c.height * 0.3, c.width * 0.3, c.height * 0.4, 0, 0, Math.PI * 2);
                ctx.ellipse(c.x + c.width * 0.7, c.y + c.height * 0.4, c.width * 0.4, c.height * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }

        // --- UI Update --- Updated for settings panel and back button
        function updateUI() {
            try {
                const pl = currentState === GameState.PLAYING;
                const pa = currentState === GameState.PAUSED;
                const go = currentState === GameState.GAMEOVER;
                const re = currentState === GameState.READY;
                const se = currentState === GameState.SETTINGS;

                if(startButton) startButton.style.display = (re || go) ? 'inline-block' : 'none';
                if(settingsButton) settingsButton.style.display = (re || go) ? 'inline-block' : 'none';
                if(characterSelectContainer) characterSelectContainer.style.display = (re || go) ? 'flex' : 'none';
                if(restartButton) restartButton.style.display = go ? 'inline-block' : 'none';
                if(gameOverElement) gameOverElement.style.display = go ? 'flex' : 'none';
                if(pauseOverlay) pauseOverlay.style.display = pa ? 'flex' : 'none';
                if(settingsPanel) settingsPanel.style.display = se ? 'flex' : 'none';
                if(duckButton) duckButton.style.display = pl ? 'flex' : 'none';
                if(backButton) backButton.style.display = (pl || pa) ? 'flex' : 'none';

                const instructionsElement = document.getElementById('instructions');
                if(instructionsElement) {
                    instructionsElement.style.display = (re || go) ? 'block' : 'none';
                }

                if(fuchsSelect) fuchsSelect.style.pointerEvents = (re || go) ? 'auto' : 'none';
                if(waschbaerSelect) waschbaerSelect.style.pointerEvents = (re || go) ? 'auto' : 'none';
            } catch(err) {
                console.error("Fehler in updateUI:", err);
            }
        }

        // --- ROBUSTERE GAME LOOP mit besserer Fehlerbehandlung ---
        function gameLoop(timestamp) {
            // Sicherheitsüberprüfung für lastTime und timestamp
            if(typeof lastTime === 'undefined' || isNaN(timestamp)){
                console.error("Loop Error: Ungültiger Timestamp oder lastTime", { timestamp, lastTime });
                lastTime = performance.now();
                if(animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                // Neustart der Animation nach einer kurzen Verzögerung
                setTimeout(() => {
                    console.log("Loop wird nach Fehler neu gestartet");
                    lastTime = performance.now();
                    animationFrameId = requestAnimationFrame(gameLoop);
                }, 100);
                return;
            }

            // Berechnung der Zeitdifferenz mit Sicherheitsbegrenzung
            const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
            lastTime = timestamp;

            // Hauptspiellogik mit Fehlerbehandlung
            try {
                // Update nur im PLAYING-Zustand
                if (currentState === GameState.PLAYING) {
                    update(dt);

                    // Regelmäßige Überprüfung der Herz-Anzeige
                    if (Math.random() < 0.02) { // Etwa alle 50 Frames
                        updateLivesDisplay();
                    }
                }

                // Zeichnen in allen Zuständen
                draw();

                // Anzeigedebug für mobile Geräte
                if (currentState === GameState.PLAYING && Math.random() < 0.005) {
                    console.log(`Spielstatus: ${lives} Leben, Unverwundbar: ${isInvulnerable}`);
                }
            } catch (error) {
                console.error("!!! KRITISCHER LAUFZEIT-FEHLER IN DER SPIELSCHLEIFE:", error);
                console.error("Fehlerdetails:", error.message, error.stack);

                // Fehlerbehandlung für den Spieler
                if(currentState === GameState.PLAYING) {
                    alert("Es ist ein Fehler aufgetreten. Das Spiel wird zurückgesetzt.");
                }

                if(animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }

                currentState = GameState.GAMEOVER;
                updateUI();
                return;
            }

            // Animation fortsetzen, wenn wir in einem aktiven Zustand sind
            if (currentState === GameState.PLAYING || currentState === GameState.READY || currentState === GameState.INIT) {
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                if(animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            }
        }

        // --- Event Handlers ---
        function handleKeyDown(e) {
            try{
                let a = false;
                if(e.key === 'p' || e.key === 'P' || e.key === 'Escape'){
                    if(currentState === GameState.PLAYING || currentState === GameState.PAUSED)
                        togglePause();
                    a = true;
                } else if(e.key === ' ' || e.key === 'ArrowUp'){
                    if(currentState === GameState.READY || currentState === GameState.GAMEOVER)
                        startGame();
                    else if(currentState === GameState.PLAYING)
                        jump();
                    a = true;
                } else if(e.key === 'ArrowDown'){
                    if(currentState === GameState.PLAYING)
                        setDucking(true);
                    a = true;
                }
                if(a) e.preventDefault();
            } catch(err){}
        }

        function handleKeyUp(e) {
            try{
                let a = false;
                if(e.key === 'ArrowDown'){
                    if(currentState === GameState.PLAYING)
                        setDucking(false);
                    a = true;
                }
                if(a) e.preventDefault();
            } catch(err){}
        }

        // --- VERBESSERTE Touch-Behandlung für Mobilgeräte ---
        function handleCanvasPointerDown(e) {
            try {
                // Visuelle Rückmeldung für Touch-Ereignisse hinzufügen
                if (gameContainer && currentState === GameState.PLAYING) {
                    const touchFeedback = document.createElement('div');
                    touchFeedback.className = 'touch-feedback';
                    touchFeedback.style.position = 'absolute';
                    touchFeedback.style.left = `${e.clientX - 20}px`;
                    touchFeedback.style.top = `${e.clientY - 20}px`;
                    touchFeedback.style.width = '40px';
                    touchFeedback.style.height = '40px';
                    touchFeedback.style.borderRadius = '50%';
                    touchFeedback.style.backgroundColor = 'rgba(255, 255, 255, 0.4)';
                    touchFeedback.style.pointerEvents = 'none';
                    touchFeedback.style.zIndex = '50';
                    touchFeedback.style.animation = 'touch-ripple 0.6s forwards';

                    // Animation hinzufügen
                    if (!document.getElementById('touchRippleAnimation')) {
                        const style = document.createElement('style');
                        style.id = 'touchRippleAnimation';
                        style.textContent = '@keyframes touch-ripple { 0% { transform: scale(0.5); opacity: 1; } 100% { transform: scale(2); opacity: 0; } }';
                        document.head.appendChild(style);
                    }

                    document.body.appendChild(touchFeedback);

                    // Touch-Feedback nach Animation entfernen
                    setTimeout(() => {
                        if (touchFeedback.parentNode) {
                            touchFeedback.parentNode.removeChild(touchFeedback);
                        }
                    }, 600);
                }

                // Spielzustandslogik
                if (currentState === GameState.PAUSED) {
                    togglePause();
                    console.log("Spiel fortgesetzt durch Touch");
                }
                else if (currentState === GameState.READY || currentState === GameState.GAMEOVER) {
                    startGame();
                    console.log("Spiel gestartet durch Touch");
                }
                else if (currentState === GameState.PLAYING) {
                    jump();
                    console.log("Sprung ausgelöst durch Touch");
                }

                e.preventDefault();
            } catch(err) {
                console.error("Fehler bei Touch-Verarbeitung:", err);
            }
        }

        function handleDuckButtonPointerDown(e) {
            try{
                if(currentState === GameState.PLAYING && e.target){
                    setDucking(true);
                    e.target.setPointerCapture(e.pointerId);
                }
                e.preventDefault();
            } catch(err){}
        }

        function handleDuckButtonPointerUp(e) {
            try{
                if(currentState === GameState.PLAYING && e.target){
                    setDucking(false);
                    if(e.target.hasPointerCapture(e.pointerId))
                        e.target.releasePointerCapture(e.pointerId);
                }
                e.preventDefault();
            } catch(err){}
        }

        function handleDuckButtonPointerCancel(e) {
            try{
                if(currentState === GameState.PLAYING && e.target){
                    setDucking(false);
                    if(e.target.hasPointerCapture(e.pointerId))
                        e.target.releasePointerCapture(e.pointerId);
                }
                e.preventDefault();
            } catch(err){}
        }

        function handleCharacterSelect(e) {
            try{
                if((currentState !== GameState.READY && currentState !== GameState.GAMEOVER) || !e.target || e.target.tagName !== 'IMG')
                    return;
                const nc = (e.target.id === 'fuchs') ? 'fuchs' : 'waschbaer';
                if(nc !== character){
                    character = nc;
                    if(fuchsSelect) fuchsSelect.classList.toggle('selected', character === 'fuchs');
                    if(waschbaerSelect) waschbaerSelect.classList.toggle('selected', character === 'waschbaer');
                    if(player) player.image = (character === 'fuchs' ? fuchsImg : waschbaerImg);
                    if(currentState === GameState.READY){
                        resetGame();
                        draw();
                    }
                }
            } catch(err){}
        }

        function handleResize() {
            try{
                resizeCanvas();
                if(currentState !== GameState.PLAYING) draw();
            } catch(err){}
        }

        function addEventListeners() {
            console.log("Listeners: Adding...");
            try {
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('keyup', handleKeyUp);
                if(canvas) canvas.addEventListener('pointerdown', handleCanvasPointerDown);
                if(startButton) startButton.addEventListener('click', startGame);
                if(restartButton) restartButton.addEventListener('click', startGame);
                if(quitButton) quitButton.addEventListener('click', quitGame);
                if(backButton) backButton.addEventListener('click', backToMenu);
                if(settingsButton) settingsButton.addEventListener('click', toggleSettingsPanel);
                if(settingsCloseButton) settingsCloseButton.addEventListener('click', toggleSettingsPanel);
                if(settingsResetButton) settingsResetButton.addEventListener('click', resetGameSettings);

                // Event-Listener für den Settings-Zurück-Button
                if(settingsBackButton) settingsBackButton.addEventListener('click', toggleSettingsPanel);

                if(duckButton) {
                    duckButton.addEventListener('pointerdown', handleDuckButtonPointerDown);
                    duckButton.addEventListener('pointerup', handleDuckButtonPointerUp);
                    duckButton.addEventListener('pointercancel', handleDuckButtonPointerCancel);
                    duckButton.addEventListener('contextmenu', (e) => e.preventDefault());
                }
                if(characterSelectContainer) characterSelectContainer.addEventListener('click', handleCharacterSelect);
                window.addEventListener('resize', handleResize);
                console.log("Listeners: Added.");
            } catch(e) {
                console.error("Listener Add Error", e);
            }
        }

        // --- Start ---
        console.log("--- Script End ---");
    </script>
</body>
</html>