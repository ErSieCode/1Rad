<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Event-Wettkampf Anlagen Belegungsplan</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <!-- Mobile DragDrop Polyfill -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mobile-drag-drop/2.3.0/index.min.js"></script>
  <!-- Excel-Bibliothek (SheetJS) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- PapaParse f√ºr CSV-Verarbeitung -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <!-- Standard CSS f√ºr Mobile DragDrop -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mobile-drag-drop/2.3.0/default.css">
  <style>
    :root {
      --settings-width-open: 300px;
      --settings-width-closed: 0px;
      --settings-width: var(--settings-width-open);
      --delete-btn-size: 24px; /* Gr√∂√üerer Touch-Bereich */
      --primary-color: #2196F3;
      --success-color: #4CAF50;
      --danger-color: #F44336;
      --warning-color: #FF9800;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: rgba(0,0,0,0); /* Entfernt blaues Highlight bei Tap */
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: grid;
      grid-template-columns: var(--settings-width) 1fr;
      height: 100vh;
      transition: grid-template-columns 0.3s ease;
      position: relative;
      overscroll-behavior: none; /* Verhindert Pull-to-refresh auf mobilen Ger√§ten */
      touch-action: manipulation; /* Verbessert Touch-Reaktion */
    }

    body.settings-closed {
      --settings-width: var(--settings-width-closed);
    }

    /* Mobile Styles */
    @media (max-width: 768px) {
      body {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }

      body.settings-open {
        grid-template-rows: 100vh 0fr;
        overflow: hidden;
      }

      #toggle-settings {
        z-index: 1002;
      }

      #settings {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1001;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
      }

      body.settings-open #settings {
        transform: translateX(0);
      }
    }

    #toggle-settings {
      position: fixed;
      top: 10px;
      left: 10px;
      padding: 0.5rem;
      background: var(--primary-color);
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      z-index: 1001;
      transition: left 0.3s ease;
      width: 44px; /* Gr√∂√üerer Touch-Bereich */
      height: 44px; /* Gr√∂√üerer Touch-Bereich */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    body:not(.settings-closed) #toggle-settings {
      left: calc(var(--settings-width-open) + 10px);
    }

    @media (max-width: 768px) {
      body.settings-open #toggle-settings {
        left: 10px;
      }

      #toggle-settings {
        left: 10px;
      }
    }

    #exports {
      position: fixed;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 0.5rem;
      z-index: 1000;
    }

    #exports button {
      padding: 0.5rem;
      background: var(--success-color);
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      min-height: 44px; /* Gr√∂√üerer Touch-Bereich */
      min-width: 44px; /* Gr√∂√üerer Touch-Bereich */
    }

    @media (max-width: 480px) {
      #exports {
        flex-direction: column;
        top: 10px;
        right: 10px;
      }
    }

    #settings {
      background: #f7f7f7;
      padding: 1rem;
      border-right: 1px solid #ccc;
      overflow-y: auto;
      width: var(--settings-width-open);
      overflow-x: hidden;
      transition: width 0.3s ease, transform 0.3s ease;
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch; /* Gl√§tteres Scrollen auf iOS */
    }

    body.settings-closed #settings {
      width: 0;
      padding: 0;
      border: none;
    }

    #main {
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    #disc-panel {
      background: #fff;
      padding: 1rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      z-index: 10;
      flex-shrink: 0;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .disc-item {
      background: var(--primary-color);
      color: #fff;
      padding: 0.75rem;
      border-radius: 4px;
      cursor: grab;
      user-select: none;
      transition: transform 0.1s ease, opacity 0.2s ease;
      min-height: 44px; /* Gr√∂√üerer Touch-Bereich */
      min-width: 44px; /* Gr√∂√üerer Touch-Bereich */
      touch-action: none; /* Verbessert Drag-Funktionalit√§t */
      position: relative;
    }

    .disc-item.dragging {
      opacity: 0.7;
      transform: scale(1.05);
      z-index: 100;
    }

    .disc-item:active {
      transform: scale(1.05);
      cursor: grabbing;
    }

    /* Drag-Indikator f√ºr besseres visuelles Feedback */
    .disc-item::after {
      content: "";
      position: absolute;
      right: 4px;
      bottom: 4px;
      width: 10px;
      height: 10px;
      background: rgba(255,255,255,0.3);
      border-radius: 50%;
      display: none;
    }

    @media (max-width: 768px) {
      .disc-item::after {
        display: block;
      }
    }

    #planner {
      flex-grow: 1;
      overflow: auto;
      background: #fafafa;
      padding: 0.5rem;
      -webkit-overflow-scrolling: touch;
      user-select: none; /* Verhindert Textauswahl beim Scrollen */
    }

    @media (max-width: 768px) {
      #planner {
        padding: 0.25rem;
      }
    }

    table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
      min-width: auto; /* Entfernt min-width f√ºr responsive Anzeige */
      background: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.12);
      border-radius: 4px;
      overflow: hidden;
    }

    th, td {
      border: 1px solid #ddd;
      position: relative;
      min-height: 80px;
      vertical-align: top;
      padding: 0;
    }

    th:first-child, td:first-child {
      width: 80px; /* Schmaler f√ºr mobile Ansicht */
      background: #f5f5f5;
      font-weight: bold;
      padding: 0.75rem 0.25rem;
      text-align: left;
      position: sticky;
      left: 0;
      z-index: 1;
    }

    th:not(:first-child) {
      background: #f5f5f5;
      position: sticky;
      top: 0;
      z-index: 2;
      padding: 0.75rem 0.25rem;
      text-align: center;
      font-weight: bold;
    }

    td:not(:first-child) {
      height: 120px; /* H√∂her f√ºr bessere Touch-Bedienung */
    }

    @media (max-width: 768px) {
      th, td {
        font-size: 0.8rem;
      }

      th:first-child, td:first-child {
        width: 60px;
        padding: 0.5rem 0.25rem;
      }

      th:not(:first-child) {
        padding: 0.5rem 0.25rem;
      }
    }

    /* Zeitmarkierungen */
    .time-marker {
      position: absolute;
      font-size: 0.7rem;
      color: #999;
      top: 3px;
    }

    .time-marker.start {
      left: 3px;
    }

    .time-marker.middle {
      left: 50%;
      transform: translateX(-50%);
    }

    .time-marker.end {
      right: 3px;
    }

    .hour-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #f0f0f0;
      pointer-events: none;
    }

    /* Drop-Zone-Visualisierung */
    td[data-day-index] {
      transition: background-color 0.2s;
    }

    .drop-target {
      background: rgba(33, 150, 243, 0.2) !important;
      box-shadow: inset 0 0 0 2px var(--primary-color);
    }

    /* Ghost-Element f√ºr Drag-Visualisierung */
    .touch-drag-ghost {
      position: fixed;
      pointer-events: none;
      z-index: 9999;
      opacity: 0.8;
      transform: translate(-50%, -50%);
      transition: none !important;
    }

    /* Slot-Styling */
    .slot {
      position: absolute;
      top: 5px;
      bottom: 5px;
      height: calc(100% - 10px);
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 0 5px 0 calc(var(--delete-btn-size) + 5px);
      border-radius: 4px;
      color: #fff;
      cursor: move;
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      box-sizing: border-box;
      border: 2px solid var(--success-color); /* Gr√ºner Rahmen */
      z-index: 5;
      box-shadow: 0 1px 3px rgba(0,0,0,0.12);
      font-weight: 500;
      transition: opacity 0.2s ease;
      touch-action: none; /* Verbessert Touch-Bedienung */
      min-height: 40px; /* Besser f√ºr Touch */
    }

    .slot.dragging {
      opacity: 0.7;
      transform: scale(1.02);
      z-index: 100;
      box-shadow: 0 3px 8px rgba(0,0,0,0.15);
    }

    @media (max-width: 768px) {
      .slot {
        font-size: 0.7rem;
      }
    }

    /* Konflikt-Visualisierung */
    .slot.conflict {
      border: 2px solid var(--danger-color); /* Roter Rahmen */
      opacity: 0.8;
      box-shadow: 0 0 5px rgba(244, 67, 54, 0.5);
    }

    .slot.conflict:hover {
      opacity: 0.9;
    }

    .slot.has-conflict {
      opacity: 0.8;
    }

    /* Z-Index f√ºr √ºberlappende Konflikte */
    .slot.conflict-1 { z-index: 8; }
    .slot.conflict-2 { z-index: 7; }
    .slot.conflict-3 { z-index: 6; }

    /* Text in transparenten Slots verbessern */
    .slot.conflict .slot-text {
      text-shadow: 0px 0px 2px rgba(0, 0, 0, 0.7);
      font-weight: bold;
    }

    .slot .delete-slot {
      position: absolute;
      left: 2px;
      top: 50%;
      transform: translateY(-50%);
      width: var(--delete-btn-size);
      height: var(--delete-btn-size);
      background: rgba(0,0,0,0.3);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 14px;
      line-height: var(--delete-btn-size);
      text-align: center;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .slot .delete-slot:hover {
      background: var(--danger-color);
    }

    .slot .notes-indicator {
      position: absolute;
      right: 3px;
      bottom: 3px;
      font-size: 14px;
      cursor: pointer;
    }

    .ok {
      opacity: 0.9;
      box-shadow: 0 0 5px rgba(76, 175, 80, 0.3); /* Leichter gr√ºner Schein */
    }

    .overflow {
      outline: 2px solid var(--danger-color);
      outline-offset: 1px;
    }

    /* Tooltip */
    #tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 10px 14px;
      border-radius: 4px;
      font-size: 0.9rem;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      max-width: 300px;
    }

    #tooltip.visible {
      opacity: 1;
    }

    .tooltip-section {
      margin-top: 5px;
      padding-top: 5px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }

    .tooltip-title {
      font-weight: bold;
      margin-bottom: 3px;
    }

    .tooltip-notes {
      font-style: italic;
      margin-top: 5px;
      white-space: pre-wrap;
    }

    /* Konflikt-Info im Tooltip */
    .tooltip-conflict {
      margin-top: 5px;
      color: var(--danger-color);
      font-weight: bold;
    }

    /* Einstellungsbereich Styles */
    #settings h2, #settings h3 { margin-top: 1.5rem; margin-bottom: 0.5rem; }
    #settings label { display: block; margin-top: 0.5rem; }
    #settings input[type="text"],
    #settings input[type="number"],
    #settings input[type="time"],
    #settings input[type="color"],
    #settings textarea,
    #settings select {
      width: calc(100% - 12px);
      padding: 10px; /* Gr√∂√üer f√ºr Touch */
      margin-bottom: 0.5rem;
      box-sizing: border-box;
      font-size: 16px; /* Verhindert Zoom auf iOS */
      border-radius: 4px;
      border: 1px solid #ccc;
    }

    #settings textarea {
      min-height: 80px;
      resize: vertical;
    }

    #settings button {
      padding: 0.75rem;
      background: var(--primary-color);
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 5px;
      min-height: 44px; /* Gr√∂√üerer Touch-Bereich */
    }

    #settings .list-item {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 10px;
    }

    #settings .list-item input[type="text"] { flex-grow: 1; margin-bottom: 0; }
    #settings .list-item button { margin-top: 0; min-width: 44px; }

    #settings #discipline-list div,
    #settings #facility-list div {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0; /* Gr√∂√üer f√ºr Touch */
      word-break: break-all;
    }

    #settings #discipline-list div span {
      display: inline-block;
      width: 16px;
      height: 16px;
      margin-right: 5px;
      vertical-align: middle;
      border: 1px solid #ccc;
    }

    #settings #discipline-list button,
    #settings #facility-list button {
      background: var(--danger-color);
      padding: 6px 10px;
      font-size: 14px;
      line-height: 1;
      margin-left: 10px;
      flex-shrink: 0;
      min-width: 44px;
      min-height: 44px;
    }

    #settings #generate {
      margin-top: 1rem;
      background: var(--success-color);
      width: 100%;
    }

    /* Excel Import Bereich */
    #import-section {
      margin-top: 1.5rem;
      padding: 1rem;
      background-color: #f0f8ff;
      border-radius: 8px;
      border: 1px solid #cce;
    }

    #import-section h3 {
      margin-top: 0;
    }

    #file-input-wrapper {
      display: flex;
      flex-direction: column;
      margin-bottom: 1rem;
    }

    #excel-file {
      display: none;
    }

    #file-input-label {
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #e0e0e0;
      color: #333;
      padding: 10px;
      border-radius: 4px;
      cursor: pointer;
      min-height: 44px;
      margin-bottom: 10px;
      transition: background-color 0.2s;
    }

    #file-input-label:hover {
      background-color: #d0d0d0;
    }

    #file-input-name {
      margin-top: 5px;
      font-size: 0.8rem;
      color: #666;
      text-align: center;
      min-height: 20px;
    }

    #import-options {
      margin-bottom: 1rem;
    }

    #import-results {
      margin-top: 1rem;
      padding: 10px;
      border-radius: 4px;
      background-color: #f5f5f5;
      display: none;
    }

    #import-results.success {
      background-color: #e8f5e9;
      border-left: 4px solid var(--success-color);
      display: block;
    }

    #import-results.error {
      background-color: #ffebee;
      border-left: 4px solid var(--danger-color);
      display: block;
    }

    /* Excel-Vorschau Modal */
    #preview-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1200;
    }

    #preview-modal.visible {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #preview-content {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    #preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }

    #preview-title {
      font-size: 1.2rem;
      font-weight: bold;
      margin: 0;
    }

    #preview-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 10px;
      line-height: 1;
      margin: -10px;
    }

    #preview-tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
      margin-bottom: 15px;
    }

    .preview-tab {
      padding: 10px 15px;
      cursor: pointer;
      border: 1px solid transparent;
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      margin-right: 5px;
      background-color: #f5f5f5;
    }

    .preview-tab.active {
      background-color: white;
      border-color: #ddd;
      border-bottom-color: white;
      margin-bottom: -1px;
      font-weight: bold;
    }

    #preview-data {
      overflow-x: auto;
    }

    #preview-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    #preview-table th, #preview-table td {
      padding: 8px;
      text-align: left;
      border: 1px solid #ddd;
      min-height: auto;
      position: relative;
    }

    #preview-table th {
      background-color: #f5f5f5;
      font-weight: bold;
      position: sticky;
      top: 0;
    }

    .preview-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 15px;
    }

    .preview-checkbox-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .preview-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 15px;
      gap: 10px;
    }

    .preview-actions button {
      padding: 10px 15px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      min-height: 44px;
    }

    .preview-actions .import-btn {
      background-color: var(--success-color);
      color: white;
    }

    .preview-actions .cancel-btn {
      background-color: #e0e0e0;
      color: #333;
    }

    /* Notizen Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1100;
    }

    .modal.visible {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .modal-title {
      font-size: 1.2rem;
      font-weight: bold;
      margin: 0;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 10px; /* Gr√∂√üerer Touch-Bereich */
      line-height: 1;
      margin: -10px; /* Kompensiert gr√∂√üeres Padding */
    }

    .modal-body {
      margin-bottom: 15px;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
    }

    .modal-footer button {
      padding: 10px 20px;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 4px;
      min-height: 44px;
      min-width: 80px;
    }

    /* Touch-freundliche Features */
    .touch-active {
      background-color: rgba(33, 150, 243, 0.2) !important;
    }

    /* Mobile Slot Aktionsmen√º */
    #slot-actions {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      padding: 15px;
      z-index: 1010;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      border-top-left-radius: 15px;
      border-top-right-radius: 15px;
    }

    #slot-actions.visible {
      transform: translateY(0);
    }

    .slot-action-button {
      width: 100%;
      padding: 15px;
      margin-bottom: 10px;
      background: #f0f0f0;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      text-align: center;
    }

    .slot-action-delete {
      background: var(--danger-color);
      color: white;
    }

    .slot-action-cancel {
      background: #ddd;
    }

    /* Drag-Overlay f√ºr Mobilger√§te */
    #mobile-drag-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    #mobile-drag-overlay.visible {
      display: flex;
    }

    #mobile-drag-content {
      background: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      max-width: 80%;
    }

    /* Indikator f√ºr Wischen */
    .swipe-indicator {
      text-align: center;
      padding: 10px;
      background: rgba(33, 150, 243, 0.1);
      font-size: 0.8rem;
      color: #666;
      display: none;
    }

    @media (max-width: 768px) {
      .swipe-indicator {
        display: block;
      }
    }

    /* Zoom-Controls f√ºr mobile Ansicht */
    #zoom-controls {
      position: fixed;
      bottom: 15px;
      right: 15px;
      display: none;
      flex-direction: column;
      gap: 10px;
      z-index: 990;
    }

    @media (max-width: 768px) {
      #zoom-controls {
        display: flex;
      }
    }

    .zoom-button {
      width: 44px;
      height: 44px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    /* Mobile Hinweis-Box */
    #mobile-hint {
      display: none;
      background: rgba(255, 152, 0, 0.2);
      border-left: 4px solid var(--warning-color);
      padding: 10px 15px;
      margin: 5px 0;
      font-size: 0.9rem;
    }

    @media (max-width: 768px) {
      #mobile-hint {
        display: block;
      }
    }

    /* Disziplin-Auswahldialog f√ºr Mobilger√§te */
    #discipline-selector {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      padding: 15px;
      z-index: 1010;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      border-top-left-radius: 15px;
      border-top-right-radius: 15px;
    }

    #discipline-selector.visible {
      transform: translateY(0);
    }

    #discipline-selector .selector-title {
      font-weight: bold;
      margin-bottom: 15px;
      text-align: center;
    }

    #discipline-selector .selector-items {
      max-height: 60vh;
      overflow-y: auto;
      margin-bottom: 15px;
    }

    .selector-item {
      padding: 12px;
      margin-bottom: 8px;
      border-radius: 8px;
      color: white;
      font-weight: bold;
    }

    .selector-cancel {
      width: 100%;
      padding: 15px;
      background: #ddd;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      text-align: center;
    }

    /* Loader f√ºr Ladezeiten */
    .loader-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1500;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
    }

    .loader-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .loader {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: 5px solid transparent;
      border-top-color: #fff;
      border-bottom-color: #fff;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body class="settings-closed">
  <div class="loader-overlay" id="loader-overlay">
    <div class="loader"></div>
  </div>

  <button id="toggle-settings">‚ò∞</button>
  <div id="exports">
    <button id="import-excel">Excel Import</button>
    <button id="export-csv">CSV</button>
    <button id="export-pdf">PDF</button>
  </div>

  <div id="tooltip"></div>

  <!-- Mobile Slot-Aktionsmen√º -->
  <div id="slot-actions">
    <button class="slot-action-button" id="slot-action-edit">Bearbeiten</button>
    <button class="slot-action-button slot-action-delete" id="slot-action-delete">L√∂schen</button>
    <button class="slot-action-button slot-action-cancel" id="slot-action-cancel">Abbrechen</button>
  </div>

  <!-- Mobile Drag Overlay -->
  <div id="mobile-drag-overlay">
    <div id="mobile-drag-content">
      <p>Element verschieben...</p>
      <p>Halte und ziehe zum Verschieben</p>
    </div>
  </div>

  <!-- Disziplin-Auswahldialog f√ºr Mobilger√§te -->
  <div id="discipline-selector">
    <div class="selector-title">Disziplin ausw√§hlen</div>
    <div class="selector-items" id="selector-items-container">
      <!-- Wird dynamisch bef√ºllt -->
    </div>
    <button class="selector-cancel" id="selector-cancel">Abbrechen</button>
  </div>

  <!-- Excel Vorschau Modal -->
  <div id="preview-modal">
    <div id="preview-content">
      <div id="preview-header">
        <h3 id="preview-title">Excel-Vorschau</h3>
        <button id="preview-close">&times;</button>
      </div>
      <div id="preview-tabs">
        <!-- Wird dynamisch bef√ºllt -->
      </div>
      <div id="preview-data">
        <!-- Hier wird die Excel-Vorschau angezeigt -->
      </div>
      <div class="preview-checkboxes">
        <div class="preview-checkbox-item">
          <input type="checkbox" id="clear-existing" checked>
          <label for="clear-existing">Bestehende Daten ersetzen</label>
        </div>
        <div class="preview-checkbox-item">
          <input type="checkbox" id="update-options" checked>
          <label for="update-options">Zeiteinstellungen √ºbernehmen (falls vorhanden)</label>
        </div>
        <div class="preview-checkbox-item">
          <input type="checkbox" id="import-schedule" checked>
          <label for="import-schedule">Zeitplan automatisch eintragen</label>
        </div>
      </div>
      <div class="preview-actions">
        <button class="cancel-btn" id="preview-cancel">Abbrechen</button>
        <button class="import-btn" id="preview-import">Importieren</button>
      </div>
    </div>
  </div>

  <!-- Zoom Controls f√ºr mobile Ansicht -->
  <div id="zoom-controls">
    <button class="zoom-button" id="zoom-in">+</button>
    <button class="zoom-button" id="zoom-out">-</button>
  </div>

  <!-- Notizen Modal -->
  <div id="notes-modal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title" id="modal-title">Notizen</h3>
        <button class="modal-close" id="modal-close">&times;</button>
      </div>
      <div class="modal-body" id="modal-body">
        <!-- Wird dynamisch bef√ºllt -->
      </div>
      <div class="modal-footer">
        <button id="modal-ok" class="btn btn-primary">OK</button>
      </div>
    </div>
  </div>

  <div id="settings">
    <h2>Einstellungen</h2>
    <button id="generate">Plan Neu Generieren</button>
    <label for="days">Anzahl Tage</label>
    <input type="number" id="days" min="1" max="30" value="7">
    <label for="start-time">Startzeit</label>
    <input type="time" id="start-time" value="08:00">
    <label for="end-time">Endzeit</label>
    <input type="time" id="end-time" value="22:00">

    <!-- Excel Import Bereich -->
    <div id="import-section">
      <h3>Excel Import</h3>
      <div id="file-input-wrapper">
        <input type="file" id="excel-file" accept=".xlsx, .xls, .csv">
        <label for="excel-file" id="file-input-label">Excel/CSV Datei ausw√§hlen</label>
        <div id="file-input-name"></div>
      </div>
      <div id="import-options">
        <label for="sheet-select">Datenimport:</label>
        <select id="sheet-select">
          <option value="auto">Automatisch erkennen</option>
          <option value="disciplines">Nur Disziplinen</option>
          <option value="facilities">Nur Anlagen</option>
          <option value="both">Anlagen und Disziplinen</option>
          <option value="schedule">Nur Zeitplan</option>
        </select>
      </div>
      <button id="import-preview">Vorschau anzeigen</button>
      <div id="import-results"></div>
    </div>

    <h3>Anlagen</h3>
    <div id="facility-list"></div>
    <div class="list-item">
      <input type="text" id="new-facility" placeholder="Neue Anlage">
      <button id="add-facility">+</button>
    </div>

    <h3>Disziplinen</h3>
    <div id="discipline-list"></div>
    <div class="list-item">
      <input type="text" id="new-disc" placeholder="Name">
    </div>
    <div class="list-item">
      <input type="number" id="new-duration" placeholder="Dauer (h)" min="0.1" step="0.1">
    </div>
    <div class="list-item">
      <input type="text" id="new-tags" placeholder="Tags (kommasepariert)">
    </div>
    <div class="list-item">
      <input type="color" id="new-color" value="#2196F3">
    </div>
    <div class="list-item">
      <label for="new-notes">Notizen:</label>
    </div>
    <div class="list-item">
      <textarea id="new-notes" placeholder="Zus√§tzliche Informationen zur Disziplin eingeben..."></textarea>
    </div>
    <div class="list-item">
      <button id="add-disc">+ Disziplin</button>
    </div>
  </div>

  <div id="main">
    <div id="disc-panel"></div>
    <div id="mobile-hint">Tippen Sie auf eine Disziplin und ziehen Sie sie in die Zeitraster.</div>
    <div class="swipe-indicator">‚Üê Nach links/rechts wischen f√ºr mehr Tage ‚Üí</div>
    <div id="planner">
      <table id="plan-table">
        <thead>
          <tr>
            <th>Anlage / Tag</th>
            <!-- Day headers werden per JS generiert -->
          </tr>
        </thead>
        <tbody>
          <!-- Facility rows werden per JS generiert -->
        </tbody>
      </table>
    </div>
  </div>

  <script>
    // --- Hilfsfunktionen ---

    // "HH:MM" in Stunden (float) umwandeln
    function parseTime(timeString) {
      if (!timeString) return 0;
      const [hours, minutes] = timeString.split(':').map(Number);
      return hours + (minutes || 0) / 60;
    }

    // Stunden (float) zur√ºck zu "HH:MM" formatieren
    function formatTime(totalHours) {
      // Behandle Stunden gr√∂√üer 24 oder negativ
      let normalizedHours = totalHours;
      while (normalizedHours < 0) normalizedHours += 24;
      normalizedHours = normalizedHours % 24;

      const totalMinutes = Math.round(normalizedHours * 60);
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    }

    // Gesamtstunden unter Ber√ºcksichtigung von √úbernacht-Zeitr√§umen berechnen
    function calculateTotalHours(startTime, endTime) {
      if (endTime < startTime) {
        // Wenn die Endzeit kleiner als die Startzeit ist, gehen wir √ºber Mitternacht
        return (24 - startTime) + endTime;
      } else {
        return endTime - startTime;
      }
    }

    // √úberpr√ºfe, ob ein Zeitbereich √ºber Mitternacht geht
    function isOvernightRange(startTime, endTime) {
      return endTime < startTime;
    }

    // Eindeutige ID generieren
    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
    }

    // HTML-Escaping zur Vermeidung von XSS
    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Touch-Ger√§t erkennen
    function isTouchDevice() {
      return ('ontouchstart' in window) ||
             (navigator.maxTouchPoints > 0) ||
             (navigator.msMaxTouchPoints > 0);
    }

    // Element f√ºr mobiles Ziehen erstellen
    function createDragGhostElement(element) {
      const ghost = element.cloneNode(true);
      ghost.classList.add('touch-drag-ghost');
      ghost.style.width = `${element.offsetWidth}px`;
      ghost.style.height = `${element.offsetHeight}px`;
      ghost.style.backgroundColor = window.getComputedStyle(element).backgroundColor;
      document.body.appendChild(ghost);
      return ghost;
    }

    // Ladeanimation zeigen/verstecken
    function showLoading() {
      document.getElementById('loader-overlay').classList.add('visible');
    }

    function hideLoading() {
      document.getElementById('loader-overlay').classList.remove('visible');
    }

    // --- Globaler Zustand ---
    let isMobile = window.innerWidth <= 768;
    let currentZoom = 1;
    let activeSlot = null; // F√ºr mobile Slot-Aktionen
    let isDragging = false;
    let touchTimeout = null;
    let currentTouchDragElement = null;
    let ghostElement = null;
    let lastTouchX = 0;
    let lastTouchY = 0;
    let currentDropTarget = null;
    let touchDragData = null;

    // Variablen f√ºr Disziplin-Auswahl und Tap-Ziel
    let currentTapTarget = null;
    let currentTapPositionHour = null;

    // Variablen f√ºr Excel-Import
    let excelData = null;
    let currentPreviewSheet = 'disciplines';

    // Mobile Drag&Drop Polyfill initialisieren
    if (isTouchDevice()) {
      MobileDragDrop.polyfill({
        dragImageTranslateOverride: (_, event) => {
          // Wichtig f√ºr iOS, damit das Drag-Image korrekt positioniert wird
          return { x: 0, y: 0 };
        },
        holdToDrag: 200 // Lange tippen um Drag zu starten
      });

      // Verhindere Scrollen w√§hrend des Ziehens
      window.addEventListener('touchmove', function(event) {
        if (isDragging) {
          event.preventDefault();
        }
      }, { passive: false });
    }

    // Tooltip-Verwaltung
    const tooltip = {
      element: document.getElementById('tooltip'),
      visible: false,

      show(e, content) {
        // Keine Tooltips auf Touch-Ger√§ten
        if (isTouchDevice() && isMobile) return;

        this.element.innerHTML = content;
        this.element.classList.add('visible');
        this.visible = true;
        this.updatePosition(e);

        document.addEventListener('mousemove', this.moveHandler);
      },

      moveHandler: function(e) {
        tooltip.updatePosition(e);
      },

      updatePosition(e) {
        if (!this.visible) return;

        const x = e.clientX + 10;
        const y = e.clientY + 10;

        // Tooltip im Viewport halten
        const rect = this.element.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        let finalX = x;
        let finalY = y;

        if (x + rect.width > viewportWidth) {
          finalX = Math.max(0, e.clientX - rect.width - 10);
        }

        if (y + rect.height > viewportHeight) {
          finalY = Math.max(0, e.clientY - rect.height - 10);
        }

        this.element.style.left = `${finalX}px`;
        this.element.style.top = `${finalY}px`;
      },

      hide() {
        this.element.classList.remove('visible');
        this.visible = false;

        document.removeEventListener('mousemove', this.moveHandler);
      }
    };

    // Modal f√ºr Notizen
    const notesModal = {
      modal: document.getElementById('notes-modal'),
      title: document.getElementById('modal-title'),
      body: document.getElementById('modal-body'),
      closeBtn: document.getElementById('modal-close'),
      okBtn: document.getElementById('modal-ok'),

      show(title, content) {
        this.title.textContent = title;
        this.body.innerHTML = content;
        this.modal.classList.add('visible');

        // Schlie√üen-Handler einrichten, falls noch nicht geschehen
        if (!this._initialized) {
          this.closeBtn.addEventListener('click', () => this.hide());
          this.okBtn.addEventListener('click', () => this.hide());
          this.modal.addEventListener('click', (e) => {
            if (e.target === this.modal) this.hide();
          });
          this._initialized = true;
        }
      },

      hide() {
        this.modal.classList.remove('visible');
      }
    };

    // Mobile Slot-Aktionen
    const slotActions = {
      element: document.getElementById('slot-actions'),
      editBtn: document.getElementById('slot-action-edit'),
      deleteBtn: document.getElementById('slot-action-delete'),
      cancelBtn: document.getElementById('slot-action-cancel'),

      show(slot) {
        this.element.classList.add('visible');
        activeSlot = slot;

        // Scrolling blockieren
        document.body.style.overflow = 'hidden';
      },

      hide() {
        this.element.classList.remove('visible');
        activeSlot = null;

        // Scrolling wiederherstellen
        document.body.style.overflow = '';
      },

      initialize() {
        this.deleteBtn.addEventListener('click', () => {
          if (activeSlot && confirm(`M√∂chten Sie "${activeSlot.name}" wirklich l√∂schen?`)) {
            deleteSlot(activeSlot.id);
            this.hide();
          }
        });

        this.editBtn.addEventListener('click', () => {
          if (activeSlot) {
            notesModal.show(
              `Notizen: ${activeSlot.name}`,
              `<div style="white-space: pre-wrap;">${escapeHtml(activeSlot.notes || '')}</div>`
            );
            this.hide();
          }
        });

        this.cancelBtn.addEventListener('click', () => {
          this.hide();
        });
      }
    };

    // Mobile Drag-Overlay
    const dragOverlay = {
      element: document.getElementById('mobile-drag-overlay'),

      show() {
        this.element.classList.add('visible');
      },

      hide() {
        this.element.classList.remove('visible');
      }
    };

    // Disziplin-Selektor f√ºr Mobilger√§te
    const disciplineSelector = {
      element: document.getElementById('discipline-selector'),
      container: document.getElementById('selector-items-container'),
      cancelBtn: document.getElementById('selector-cancel'),

      show(targetCell, targetHour) {
        // Aktuelles Ziel f√ºr sp√§ter speichern
        currentTapTarget = targetCell;
        currentTapPositionHour = targetHour;

        // Container mit verf√ºgbaren Disziplinen f√ºllen
        this.container.innerHTML = '';

        disciplines.forEach(disc => {
          const item = document.createElement('div');
          item.className = 'selector-item';
          item.style.backgroundColor = disc.color;
          item.textContent = `${disc.name} (${disc.duration}h)`;

          if (disc.notes && disc.notes.trim()) {
            const notesIndicator = document.createElement('span');
            notesIndicator.innerHTML = ' üìù';
            notesIndicator.title = 'Hat Notizen';
            item.appendChild(notesIndicator);
          }

          item.addEventListener('click', () => {
            const facilityIndex = parseInt(currentTapTarget.dataset.facilityIndex, 10);
            const dayIndex = parseInt(currentTapTarget.dataset.dayIndex, 10);
            allocateSlot(facilityIndex, dayIndex, disc, currentTapPositionHour);
            this.hide();
          });

          this.container.appendChild(item);
        });

        this.element.classList.add('visible');
        document.body.style.overflow = 'hidden'; // Scrollen verhindern
      },

      hide() {
        this.element.classList.remove('visible');
        currentTapTarget = null;
        currentTapPositionHour = null;
        document.body.style.overflow = ''; // Scrollen erlauben
      },

      initialize() {
        this.cancelBtn.addEventListener('click', () => {
          this.hide();
        });
      }
    };

    // Zoom-Steuerung
    const zoomControls = {
      zoomIn: document.getElementById('zoom-in'),
      zoomOut: document.getElementById('zoom-out'),

      initialize() {
        this.zoomIn.addEventListener('click', () => {
          if (currentZoom < 2) {
            currentZoom += 0.1;
            applyZoom();
          }
        });

        this.zoomOut.addEventListener('click', () => {
          if (currentZoom > 0.5) {
            currentZoom -= 0.1;
            applyZoom();
          }
        });
      }
    };

    // Excel-Vorschau Modal
    const previewModal = {
      modal: document.getElementById('preview-modal'),
      content: document.getElementById('preview-content'),
      title: document.getElementById('preview-title'),
      closeBtn: document.getElementById('preview-close'),
      tabs: document.getElementById('preview-tabs'),
      dataContainer: document.getElementById('preview-data'),
      importBtn: document.getElementById('preview-import'),
      cancelBtn: document.getElementById('preview-cancel'),
      clearExisting: document.getElementById('clear-existing'),
      updateOptions: document.getElementById('update-options'),
      importSchedule: document.getElementById('import-schedule'),

      show(data) {
        this.modal.classList.add('visible');
        excelData = data;

        // Tabs generieren
        this.generateTabs(data);

        // Ersten Tab anzeigen
        if (data.disciplines) {
          currentPreviewSheet = 'disciplines';
        } else if (data.facilities) {
          currentPreviewSheet = 'facilities';
        } else if (data.schedule) {
          currentPreviewSheet = 'schedule';
        } else if (data.settings) {
          currentPreviewSheet = 'settings';
        }

        this.renderPreview(currentPreviewSheet);
        document.body.style.overflow = 'hidden'; // Scrollen verhindern
      },

      hide() {
        this.modal.classList.remove('visible');
        document.body.style.overflow = ''; // Scrollen erlauben
      },

      generateTabs(data) {
        this.tabs.innerHTML = '';

        if (data.disciplines) {
          const tab = document.createElement('div');
          tab.className = 'preview-tab';
          tab.dataset.sheet = 'disciplines';
          tab.textContent = 'Disziplinen';
          this.tabs.appendChild(tab);
        }

        if (data.facilities) {
          const tab = document.createElement('div');
          tab.className = 'preview-tab';
          tab.dataset.sheet = 'facilities';
          tab.textContent = 'Anlagen';
          this.tabs.appendChild(tab);
        }

        if (data.schedule) {
          const tab = document.createElement('div');
          tab.className = 'preview-tab';
          tab.dataset.sheet = 'schedule';
          tab.textContent = 'Zeitplan';
          this.tabs.appendChild(tab);
        }

        if (data.settings) {
          const tab = document.createElement('div');
          tab.className = 'preview-tab';
          tab.dataset.sheet = 'settings';
          tab.textContent = 'Einstellungen';
          this.tabs.appendChild(tab);
        }

        // Ersten Tab aktivieren
        const firstTab = this.tabs.querySelector('.preview-tab');
        if (firstTab) {
          firstTab.classList.add('active');
        }
      },

      renderPreview(sheetName) {
        if (!excelData || !excelData[sheetName]) {
          this.dataContainer.innerHTML = '<p>Keine Daten vorhanden oder ung√ºltiges Format.</p>';
          return;
        }

        // Aktiven Tab aktualisieren
        const tabs = this.tabs.querySelectorAll('.preview-tab');
        tabs.forEach(tab => {
          if (tab.dataset.sheet === sheetName) {
            tab.classList.add('active');
          } else {
            tab.classList.remove('active');
          }
        });

        const data = excelData[sheetName];

        // Unterschiedliche Darstellung je nach Datentyp
        if (sheetName === 'settings') {
          // Einstellungen als Schl√ºssel-Wert-Paare anzeigen
          let html = '<table id="preview-table">';
          html += '<thead><tr><th>Einstellung</th><th>Wert</th></tr></thead><tbody>';

          for (const [key, value] of Object.entries(data)) {
            html += `<tr><td>${escapeHtml(key)}</td><td>${escapeHtml(value !== null && value !== undefined ? value.toString() : '')}</td></tr>`;
          }

          html += '</tbody></table>';
          this.dataContainer.innerHTML = html;
        } else {
          // Regul√§re Tabellendaten anzeigen
          let html = '<table id="preview-table">';

          // Tabellenkopf
          html += '<thead><tr>';
          for (const header of data.headers) {
            html += `<th>${escapeHtml(header)}</th>`;
          }
          html += '</tr></thead>';

          // Tabelleninhalt
          html += '<tbody>';
          for (const row of data.rows) {
            html += '<tr>';
            for (const cell of row) {
              html += `<td>${escapeHtml(cell !== null && cell !== undefined ? cell.toString() : '')}</td>`;
            }
            html += '</tr>';
          }
          html += '</tbody></table>';

          this.dataContainer.innerHTML = html;
        }
      },

      initialize() {
        this.closeBtn.addEventListener('click', () => this.hide());
        this.cancelBtn.addEventListener('click', () => this.hide());

        // Tab-Wechsel
        this.tabs.addEventListener('click', (e) => {
          if (e.target.classList.contains('preview-tab')) {
            currentPreviewSheet = e.target.dataset.sheet;
            this.renderPreview(currentPreviewSheet);
          }
        });

        // Import-Button
        this.importBtn.addEventListener('click', () => {
          const clearExisting = this.clearExisting.checked;
          const updateOptions = this.updateOptions.checked;
          const importSchedule = this.importSchedule.checked;

          importExcelData(excelData, {
            clearExisting,
            updateOptions,
            importSchedule
          });

          this.hide();
        });
      }
    };

    function applyZoom() {
      const table = document.getElementById('plan-table');
      table.style.transform = `scale(${currentZoom})`;
      table.style.transformOrigin = 'top left';
    }

    // Anwendungszustand
    let facilities = [];
    let disciplines = [];
    let plan = []; // Struktur: [{ facility: "Name", allocations: [ [slot1, slot2], [slot3], ... ] }, ...]
    // allocations index entspricht dem Tag (0-basiert)
    // slot: { id, name, duration, tags, color, startHour, notes }

    // --- DOM-Element-Referenzen ---
    const elements = {
      body: document.body,
      toggleSettings: document.getElementById('toggle-settings'),
      importExcel: document.getElementById('import-excel'),
      exportCsv: document.getElementById('export-csv'),
      exportPdf: document.getElementById('export-pdf'),
      settings: {
        days: document.getElementById('days'),
        start: document.getElementById('start-time'),
        end: document.getElementById('end-time'),
        generate: document.getElementById('generate'),
        facilityList: document.getElementById('facility-list'),
        newFacility: document.getElementById('new-facility'),
        addFacility: document.getElementById('add-facility'),
        disciplineList: document.getElementById('discipline-list'),
        newDisc: document.getElementById('new-disc'),
        newDuration: document.getElementById('new-duration'),
        newTags: document.getElementById('new-tags'),
        newColor: document.getElementById('new-color'),
        newNotes: document.getElementById('new-notes'),
        addDisc: document.getElementById('add-disc'),
        // Excel Import
        excelFile: document.getElementById('excel-file'),
        fileInputLabel: document.getElementById('file-input-label'),
        fileInputName: document.getElementById('file-input-name'),
        sheetSelect: document.getElementById('sheet-select'),
        importPreview: document.getElementById('import-preview'),
        importResults: document.getElementById('import-results')
      },
      discPanel: document.getElementById('disc-panel'),
      planTable: document.getElementById('plan-table'),
      tableBody: document.querySelector('#plan-table tbody'),
      planner: document.getElementById('planner')
    };

    // --- Event Listeners ---

    // Einstellungsmen√º ein-/ausklappen
    elements.toggleSettings.onclick = () => {
      if (isMobile) {
        elements.body.classList.toggle('settings-open');
      } else {
        elements.body.classList.toggle('settings-closed');
      }
    };

    // Excel-Import-Button in der Toolbar
    elements.importExcel.onclick = () => {
      // Einstellungspanel √∂ffnen
      if (isMobile) {
        elements.body.classList.add('settings-open');
      } else {
        elements.body.classList.remove('settings-closed');
      }

      // Zum Import-Bereich scrollen
      document.getElementById('import-section').scrollIntoView({ behavior: 'smooth' });

      // Verz√∂gertes Fokussieren des Datei-Input-Buttons
      setTimeout(() => {
        elements.settings.fileInputLabel.focus();
      }, 500);
    };

    // Datei-Input √Ñnderung
    elements.settings.excelFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        elements.settings.fileInputName.textContent = file.name;
      } else {
        elements.settings.fileInputName.textContent = '';
      }
    });

    // Import-Vorschau-Button
    elements.settings.importPreview.addEventListener('click', () => {
      const file = elements.settings.excelFile.files[0];
      if (!file) {
        showImportResult('Bitte w√§hlen Sie eine Excel- oder CSV-Datei aus.', 'error');
        return;
      }

      showLoading();

      parseExcelFile(file)
        .then(data => {
          hideLoading();

          if (!data) {
            showImportResult('Die Datei konnte nicht gelesen werden oder hat ein ung√ºltiges Format.', 'error');
            return;
          }

          // Excel-Vorschau anzeigen
          previewModal.show(data);
        })
        .catch(error => {
          hideLoading();
          console.error('Excel-Parsing Fehler:', error);
          showImportResult(`Fehler beim Lesen der Datei: ${error.message}`, 'error');
        });
    });

    // Fenstergr√∂√üen-Handler
    window.addEventListener('resize', () => {
      isMobile = window.innerWidth <= 768;

      // Bei Gr√∂√üen√§nderung Einstellungspanel anpassen
      if (!isMobile && elements.body.classList.contains('settings-open')) {
        elements.body.classList.remove('settings-open');
        elements.body.classList.remove('settings-closed');
      } else if (isMobile && !elements.body.classList.contains('settings-closed') &&
                !elements.body.classList.contains('settings-open')) {
        elements.body.classList.add('settings-closed');
      }
    });

    // Anlage hinzuf√ºgen
    elements.settings.addFacility.onclick = () => {
      const facilityName = elements.settings.newFacility.value.trim();
      if (facilityName && !facilities.includes(facilityName)) {
        facilities.push(facilityName);
        elements.settings.newFacility.value = '';
        renderSettingsLists();
        generatePlanStructure(); // Planstruktur neu generieren (beh√§lt vorhandene Slots)
      } else if (facilities.includes(facilityName)) {
        alert('Anlage existiert bereits.');
      }
    };

    // Disziplin hinzuf√ºgen
    elements.settings.addDisc.onclick = () => {
      const name = elements.settings.newDisc.value.trim();
      const duration = parseFloat(elements.settings.newDuration.value);
      const tags = elements.settings.newTags.value.split(',').map(t => t.trim()).filter(t => t);
      const color = elements.settings.newColor.value;
      const notes = elements.settings.newNotes.value.trim();

      if (name && duration > 0) {
        if (disciplines.some(d => d.name === name)) {
          alert('Disziplin mit diesem Namen existiert bereits.');
          return;
        }
        disciplines.push({
          id: generateId(),
          name,
          duration,
          tags,
          color,
          notes
        });

        // Eingabefelder zur√ºcksetzen
        elements.settings.newDisc.value = '';
        elements.settings.newDuration.value = '';
        elements.settings.newTags.value = '';
        elements.settings.newColor.value = '#2196F3'; // Farbe zur√ºcksetzen
        elements.settings.newNotes.value = '';

        renderSettingsLists();
        renderDiscPanel();
        saveToLocalStorage();
      } else {
        alert('Bitte g√ºltigen Namen und Dauer (> 0) f√ºr die Disziplin eingeben.');
      }
    };

    // Plan neu generieren Button
    elements.settings.generate.onclick = () => {
      if (confirm('M√∂chten Sie den Plan wirklich neu generieren? Alle platzierten Events gehen verloren.')) {
        generatePlanStructure(true); // true = Belegungen l√∂schen
      }
    };

    // Plan bei Einstellungs√§nderung aktualisieren
    elements.settings.days.addEventListener('change', () => generatePlanStructure());
    elements.settings.start.addEventListener('change', () => generatePlanStructure());
    elements.settings.end.addEventListener('change', () => generatePlanStructure());

    // CSV Export
    elements.exportCsv.onclick = exportToCsv;

    // PDF Export
    elements.exportPdf.onclick = exportToPdf;

    // --- Excel-Import-Funktionen ---

    // Excel-Datei parsen
    async function parseExcelFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (e) => {
          try {
            const data = e.target.result;
            let workbook;

            // Unterscheide zwischen CSV und Excel
            if (file.name.toLowerCase().endsWith('.csv')) {
              // CSV mit PapaParse verarbeiten
              Papa.parse(data, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                  // Fehlerbehandlung
                  if (results.errors && results.errors.length > 0) {
                    console.warn('CSV parsing errors:', results.errors);
                  }

                  const parsedData = analyzeAndConvertCSV(results.data);
                  resolve(parsedData);
                },
                error: function(error) {
                  reject(error);
                }
              });
            } else {
              // Excel mit SheetJS verarbeiten
              workbook = XLSX.read(data, {
                type: 'binary',
                cellDates: true,
                cellNF: true
              });

              const parsedData = analyzeAndConvertWorkbook(workbook);
              resolve(parsedData);
            }
          } catch (error) {
            reject(error);
          }
        };

        reader.onerror = (error) => {
          reject(error);
        };

        // Datei lesen
        if (file.name.toLowerCase().endsWith('.csv')) {
          reader.readAsText(file);
        } else {
          reader.readAsBinaryString(file);
        }
      });
    }

    // Workbook-Daten analysieren und konvertieren
    function analyzeAndConvertWorkbook(workbook) {
      const result = {
        disciplines: null,
        facilities: null,
        settings: null,
        schedule: null
      };

      // Bl√§tter durchsuchen
      const sheetNames = workbook.SheetNames;

      // Bl√§tter nach bestimmten Namen oder Inhalten durchsuchen
      for (const sheetName of sheetNames) {
        const worksheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

        // Leere Bl√§tter √ºberspringen
        if (jsonData.length === 0 || (jsonData.length === 1 && jsonData[0].length === 0)) {
          continue;
        }

        // Header-Zeile holen
        const headers = jsonData[0];

        // Blatttyp identifizieren
        if (identifyDisciplineSheet(headers)) {
          result.disciplines = convertToDisciplinesFormat(jsonData);
        }
        else if (identifyFacilitySheet(headers)) {
          result.facilities = convertToFacilitiesFormat(jsonData);
        }
        else if (identifySettingsSheet(headers)) {
          result.settings = extractSettings(jsonData);
        }
        else if (identifyScheduleSheet(headers)) {
          result.schedule = convertToScheduleFormat(jsonData);
        }
      }

      return result;
    }

    // CSV-Daten analysieren und konvertieren
    function analyzeAndConvertCSV(data) {
      if (!data || data.length === 0) {
        return null;
      }

      const result = {
        disciplines: null,
        facilities: null,
        settings: null,
        schedule: null
      };

      // Header aus dem ersten Objekt extrahieren
      const headers = Object.keys(data[0]);

      // Datentyp bestimmen
      if (identifyDisciplineSheet(headers)) {
        // Zu Disziplinen-Format konvertieren
        const rows = data.map(row => Object.values(row));
        result.disciplines = {
          headers: headers,
          rows: rows
        };
      } else if (identifyFacilitySheet(headers)) {
        // Zu Anlagen-Format konvertieren
        const rows = data.map(row => Object.values(row));
        result.facilities = {
          headers: headers,
          rows: rows
        };
      } else if (identifyScheduleSheet(headers)) {
        // Zu Zeitplan-Format konvertieren
        const rows = data.map(row => Object.values(row));
        result.schedule = {
          headers: headers,
          rows: rows
        };
      }

      return result;
    }

    // Erkennen ob es sich um Disziplinen-Daten handelt
    function identifyDisciplineSheet(headers) {
      if (!headers || headers.length === 0) return false;

      const requiredFields = ['name', 'dauer', 'duration'];
      const headerLower = headers.map(h => (h || '').toString().toLowerCase());

      // Pr√ºfen ob mindestens ein erforderliches Feld vorhanden ist
      return requiredFields.some(field => headerLower.includes(field));
    }

    // Erkennen ob es sich um Anlagen-Daten handelt
    function identifyFacilitySheet(headers) {
      if (!headers || headers.length === 0) return false;

      const requiredFields = ['anlage', 'anlagen', 'facility', 'facilities', 'name'];
      const headerLower = headers.map(h => (h || '').toString().toLowerCase());

      // Pr√ºfen ob mindestens ein erforderliches Feld vorhanden ist
      return requiredFields.some(field => headerLower.includes(field)) && !identifyDisciplineSheet(headers);
    }

    // Erkennen ob es sich um Einstellungs-Daten handelt
    function identifySettingsSheet(headers) {
      if (!headers || headers.length === 0) return false;

      const requiredFields = ['setting', 'einstellung', 'option', 'wert', 'value'];
      const headerLower = headers.map(h => (h || '').toString().toLowerCase());

      // Pr√ºfen ob mindestens ein erforderliches Feld vorhanden ist
      return requiredFields.some(field => headerLower.includes(field));
    }

    // Erkennen ob es sich um Zeitplan-Daten handelt
    function identifyScheduleSheet(headers) {
      if (!headers || headers.length === 0) return false;

      const headerLower = headers.map(h => (h || '').toString().toLowerCase());

      // Pr√ºfen ob notwendige Felder vorhanden sind
      const hasFacility = headerLower.some(h => ['anlage', 'facility', 'ort', 'location'].includes(h));
      const hasDay = headerLower.some(h => ['tag', 'day', 'datum', 'date'].includes(h));
      const hasTime = headerLower.some(h => ['zeit', 'time', 'start', 'beginn', 'startzeit'].includes(h));
      const hasDiscipline = headerLower.some(h => ['disziplin', 'discipline', 'aktivit√§t', 'activity'].includes(h));

      return hasFacility && hasDay && hasTime && hasDiscipline;
    }

    // Daten in Disziplinen-Format konvertieren
    function convertToDisciplinesFormat(jsonData) {
      if (!jsonData || jsonData.length < 2) return null;

      const headers = jsonData[0];
      const rows = jsonData.slice(1).filter(row => row.length > 0 && row[0] !== undefined);

      return {
        headers: headers,
        rows: rows
      };
    }

    // Daten in Anlagen-Format konvertieren
    function convertToFacilitiesFormat(jsonData) {
      if (!jsonData || jsonData.length < 2) return null;

      const headers = jsonData[0];
      const rows = jsonData.slice(1).filter(row => row.length > 0 && row[0] !== undefined);

      return {
        headers: headers,
        rows: rows
      };
    }

    // Daten in Zeitplan-Format konvertieren
    function convertToScheduleFormat(jsonData) {
      if (!jsonData || jsonData.length < 2) return null;

      const headers = jsonData[0];
      const rows = jsonData.slice(1).filter(row => row.length > 0);

      return {
        headers: headers,
        rows: rows
      };
    }

    // Einstellungen aus Daten extrahieren
    function extractSettings(jsonData) {
      if (!jsonData || jsonData.length < 2) return null;

      const settings = {};
      const headers = jsonData[0].map(h => h.toLowerCase());

      const nameIndex = headers.findIndex(h => ['setting', 'einstellung', 'option', 'name'].includes(h));
      const valueIndex = headers.findIndex(h => ['wert', 'value', 'val'].includes(h));

      if (nameIndex === -1 || valueIndex === -1) return null;

      for (let i = 1; i < jsonData.length; i++) {
        const row = jsonData[i];
        if (row && row.length > Math.max(nameIndex, valueIndex)) {
          const name = row[nameIndex];
          const value = row[valueIndex];

          if (name && value !== undefined) {
            settings[name.toString().toLowerCase()] = value;
          }
        }
      }

      return settings;
    }

    // Excel-Daten in die Anwendung importieren
    function importExcelData(data, options = {}) {
      if (!data) {
        showImportResult('Keine Daten zum Importieren vorhanden.', 'error');
        return;
      }

      const { clearExisting, updateOptions, importSchedule } = options;
      let importedFacilities = 0;
      let importedDisciplines = 0;
      let importedScheduleItems = 0;

      showLoading();

      try {
        // Einstellungen importieren, falls vorhanden
        if (updateOptions && data.settings) {
          importSettings(data.settings);
        }

        // Anlagen importieren, falls vorhanden
        if (data.facilities) {
          importedFacilities = importFacilities(data.facilities, clearExisting);
        }

        // Disziplinen importieren, falls vorhanden
        if (data.disciplines) {
          importedDisciplines = importDisciplines(data.disciplines, clearExisting);
        }

        // Zeitplan importieren, falls vorhanden und gew√ºnscht
        if (importSchedule && data.schedule) {
          importedScheduleItems = importScheduleItems(data.schedule);
        }

        // Anzeige aktualisieren
        renderSettingsLists();
        renderDiscPanel();
        generatePlanStructure(false); // Plan-Struktur regenerieren, bestehende Slots behalten

        // Ergebnis anzeigen
        let resultMessage = `Import erfolgreich abgeschlossen. ${importedFacilities} Anlagen und ${importedDisciplines} Disziplinen importiert.`;
        if (importedScheduleItems > 0) {
          resultMessage += ` ${importedScheduleItems} Zeitplan-Eintr√§ge platziert.`;
        }
        showImportResult(resultMessage, 'success');

        // In localStorage speichern
        saveToLocalStorage();
      } catch (error) {
        console.error('Fehler beim Importieren der Daten:', error);
        showImportResult(`Fehler beim Importieren: ${error.message}`, 'error');
      } finally {
        hideLoading();
      }
    }

    // Einstellungen importieren
    function importSettings(settings) {
      // Pr√ºfe auf relevante Einstellungen
      if (settings['anzahl_tage'] || settings['days'] || settings['tage']) {
        const days = parseInt(settings['anzahl_tage'] || settings['days'] || settings['tage']);
        if (!isNaN(days) && days > 0 && days <= 30) {
          elements.settings.days.value = days;
        }
      }

      if (settings['startzeit'] || settings['start_time'] || settings['start']) {
        const startTime = settings['startzeit'] || settings['start_time'] || settings['start'];
        // Pr√ºfe ob g√ºltiges Zeitformat
        if (/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(startTime)) {
          elements.settings.start.value = startTime;
        }
      }

      if (settings['endzeit'] || settings['end_time'] || settings['end']) {
        const endTime = settings['endzeit'] || settings['end_time'] || settings['end'];
        // Pr√ºfe ob g√ºltiges Zeitformat
        if (/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(endTime)) {
          elements.settings.end.value = endTime;
        }
      }
    }

    // Anlagen importieren
    function importFacilities(data, clearExisting) {
      if (!data || !data.headers || !data.rows || data.rows.length === 0) {
        return 0;
      }

      // Index der Namen-Spalte bestimmen
      const headers = data.headers.map(h => (h || '').toString().toLowerCase());
      let nameIndex = headers.findIndex(h => ['anlage', 'anlagen', 'facility', 'facilities', 'name'].includes(h));

      // Falls kein Name-Header gefunden, erste Spalte nehmen
      if (nameIndex === -1) nameIndex = 0;

      // Bestehende Anlagen l√∂schen, wenn gew√ºnscht
      if (clearExisting) {
        facilities = [];
      }

      // G√ºltige Anlagen sammeln
      let importCount = 0;

      for (const row of data.rows) {
        if (row && row.length > nameIndex) {
          const name = row[nameIndex];

          if (name && typeof name === 'string' && name.trim() !== '') {
            const facilityName = name.trim();

            // Pr√ºfen ob Anlage bereits existiert
            if (!facilities.includes(facilityName)) {
              facilities.push(facilityName);
              importCount++;
            }
          }
        }
      }

      return importCount;
    }

    // Disziplinen importieren
    function importDisciplines(data, clearExisting) {
      if (!data || !data.headers || !data.rows || data.rows.length === 0) {
        return 0;
      }

      // Indizes der relevanten Spalten bestimmen
      const headers = data.headers.map(h => (h || '').toString().toLowerCase());

      const nameIndex = headers.findIndex(h => ['name', 'disziplin', 'discipline'].includes(h));
      const durationIndex = headers.findIndex(h => ['dauer', 'duration', 'zeit', 'time'].includes(h));
      const tagsIndex = headers.findIndex(h => ['tags', 'kategorien', 'categories'].includes(h));
      const colorIndex = headers.findIndex(h => ['farbe', 'color', 'colour'].includes(h));
      const notesIndex = headers.findIndex(h => ['notizen', 'notes', 'bemerkungen', 'comments'].includes(h));

      // Namen- und Dauer-Spalte sind erforderlich
      if (nameIndex === -1 || durationIndex === -1) {
        return 0;
      }

      // Bestehende Disziplinen l√∂schen, wenn gew√ºnscht
      if (clearExisting) {
        disciplines = [];
      }

      // G√ºltige Disziplinen sammeln
      let importCount = 0;
      const existingNames = new Set(disciplines.map(d => d.name));

      for (const row of data.rows) {
        if (row && row.length > Math.max(nameIndex, durationIndex)) {
          const name = row[nameIndex];
          const durationValue = row[durationIndex];

          // Pr√ºfen ob Name und Dauer g√ºltig sind
          if (name && typeof name === 'string' && name.trim() !== '' &&
              durationValue !== undefined && durationValue !== null) {

            const disciplineName = name.trim();

            // Bereits existierende Disziplinen √ºberspringen
            if (existingNames.has(disciplineName)) {
              continue;
            }

            // Dauer in Zahl konvertieren
            let duration = parseFloat(durationValue);

            // Falls Dauer als String mit ":" formatiert (z.B. "1:30"), zu Stunden konvertieren
            if (isNaN(duration) && typeof durationValue === 'string' && durationValue.includes(':')) {
              const [hours, minutes] = durationValue.split(':').map(Number);
              if (!isNaN(hours) && !isNaN(minutes)) {
                duration = hours + (minutes / 60);
              }
            }

            // Pr√ºfen ob Dauer g√ºltig
            if (isNaN(duration) || duration <= 0) {
              continue;
            }

            // Tags extrahieren, falls vorhanden
            let tags = [];
            if (tagsIndex !== -1 && row.length > tagsIndex && row[tagsIndex]) {
              tags = row[tagsIndex].toString().split(/[,;]/).map(tag => tag.trim()).filter(Boolean);
            }

            // Farbe extrahieren, falls vorhanden
            let color = getRandomColor();
            if (colorIndex !== -1 && row.length > colorIndex && row[colorIndex]) {
              const colorValue = row[colorIndex].toString().trim();

              // Pr√ºfen ob g√ºltiger Hex-Farbcode
              if (/^#[0-9A-F]{6}$/i.test(colorValue)) {
                color = colorValue;
              }
            }

            // Notizen extrahieren, falls vorhanden
            let notes = '';
            if (notesIndex !== -1 && row.length > notesIndex && row[notesIndex]) {
              notes = row[notesIndex].toString().trim();
            }

            // Neue Disziplin erstellen
            disciplines.push({
              id: generateId(),
              name: disciplineName,
              duration: duration,
              tags: tags,
              color: color,
              notes: notes
            });

            existingNames.add(disciplineName);
            importCount++;
          }
        }
      }

      return importCount;
    }

    // Zeitplan-Eintr√§ge importieren
    function importScheduleItems(data) {
      if (!data || !data.headers || !data.rows || data.rows.length === 0) {
        return 0;
      }

      // Indizes der relevanten Spalten bestimmen
      const headers = data.headers.map(h => (h || '').toString().toLowerCase());

      const facilityIndex = headers.findIndex(h => ['anlage', 'facility', 'ort', 'location'].includes(h));
      const dayIndex = headers.findIndex(h => ['tag', 'day', 'datum', 'date'].includes(h));
      const timeIndex = headers.findIndex(h => ['zeit', 'time', 'start', 'beginn', 'startzeit'].includes(h));
      const disciplineIndex = headers.findIndex(h => ['disziplin', 'discipline', 'aktivit√§t', 'activity'].includes(h));

      // Alle wichtigen Spalten m√ºssen vorhanden sein
      if (facilityIndex === -1 || dayIndex === -1 || timeIndex === -1 || disciplineIndex === -1) {
        return 0;
      }

      let importCount = 0;

      // G√ºltige Zeitplan-Eintr√§ge sammeln
      for (const row of data.rows) {
        if (row && row.length > Math.max(facilityIndex, dayIndex, timeIndex, disciplineIndex)) {
          const facilityName = row[facilityIndex];
          const dayValue = row[dayIndex];
          const timeValue = row[timeIndex];
          const disciplineName = row[disciplineIndex];

          // Pr√ºfen ob alle Werte g√ºltig
          if (!facilityName || !dayValue || !timeValue || !disciplineName) {
            continue;
          }

          // Anlage finden
          const facilityIndex = facilities.findIndex(f =>
            f.toLowerCase() === facilityName.toString().toLowerCase()
          );

          if (facilityIndex === -1) {
            continue; // Anlage nicht gefunden
          }

          // Tag bestimmen
          let day = 0;
          if (typeof dayValue === 'number') {
            day = Math.max(1, Math.round(dayValue)) - 1; // In 0-basierten Index umwandeln
          } else {
            // Versuche eine Zahl aus dem String zu extrahieren
            const matches = dayValue.toString().match(/\d+/);
            if (matches) {
              day = parseInt(matches[0], 10) - 1;
            }
          }

          // Pr√ºfen ob Tag g√ºltig
          if (day < 0 || day >= plan[facilityIndex].allocations.length) {
            continue;
          }

          // Startzeit bestimmen
          let startHour = 0;
          if (typeof timeValue === 'number') {
            startHour = timeValue;
          } else if (typeof timeValue === 'string') {
            // String im Format "HH:MM" parsen
            const timeParts = timeValue.toString().trim().split(':');
            if (timeParts.length >= 2) {
              startHour = parseInt(timeParts[0], 10) + parseInt(timeParts[1], 10) / 60;
            }
          } else if (timeValue instanceof Date) {
            startHour = timeValue.getHours() + timeValue.getMinutes() / 60;
          }

          // Disziplin finden
          const disciplineObj = disciplines.find(d =>
            d.name.toLowerCase() === disciplineName.toString().toLowerCase()
          );

          if (!disciplineObj) {
            continue; // Disziplin nicht gefunden
          }

          // Slot platzieren
          allocateSlot(facilityIndex, day, disciplineObj, startHour);
          importCount++;
        }
      }

      return importCount;
    }

    // Zuf√§llige Farbe f√ºr Disziplinen generieren
    function getRandomColor() {
      const colors = [
        '#f44336', '#e91e63', '#9c27b0', '#673ab7',
        '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4',
        '#009688', '#4caf50', '#8bc34a', '#cddc39',
        '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'
      ];

      return colors[Math.floor(Math.random() * colors.length)];
    }

    // Import-Ergebnis anzeigen
    function showImportResult(message, type) {
      elements.settings.importResults.innerHTML = message;
      elements.settings.importResults.className = type;

      // Nachricht nach einiger Zeit ausblenden
      setTimeout(() => {
        elements.settings.importResults.classList.remove(type);
      }, 6000);
    }

    // --- Rendering-Funktionen ---

    // Anlagen- und Disziplinlisten in den Einstellungen rendern
    function renderSettingsLists() {
      // Anlagen
      elements.settings.facilityList.innerHTML = '';
      facilities.forEach((facilityName, index) => {
        const div = document.createElement('div');
        div.textContent = facilityName;
        const btn = document.createElement('button');
        btn.textContent = '‚úñ';
        btn.title = `Anlage "${facilityName}" l√∂schen`;
        btn.onclick = () => {
          if (confirm(`M√∂chten Sie die Anlage "${facilityName}" wirklich l√∂schen? Alle zugeh√∂rigen Events werden entfernt.`)) {
            facilities.splice(index, 1);
            // Entsprechende Eintr√§ge aus den Plandaten entfernen
            plan = plan.filter((_, i) => i !== index);
            renderSettingsLists();
            generatePlanStructure(); // Tabellenstruktur neu generieren
            saveToLocalStorage();
          }
        };
        div.appendChild(btn);
        elements.settings.facilityList.appendChild(div);
      });

      // Disziplinen
      elements.settings.disciplineList.innerHTML = '';
      disciplines.forEach((disc, index) => {
        const div = document.createElement('div');
        const hasNotes = disc.notes && disc.notes.trim().length > 0;

        div.innerHTML = `
          <span style="background-color:${disc.color};"></span>
          ${disc.name} (${disc.duration}h)
          ${hasNotes ? '<span title="Hat Notizen">üìù</span>' : ''}
          [${disc.tags.join(', ') || '-'}]
        `;

        // Falls die Disziplin Notizen hat, anklickbar machen
        if (hasNotes) {
          div.style.cursor = 'pointer';
          div.title = "Klicken Sie, um die Notizen anzuzeigen";
          div.addEventListener('click', () => {
            notesModal.show(
              `Notizen: ${disc.name}`,
              `<div style="white-space: pre-wrap;">${escapeHtml(disc.notes)}</div>`
            );
          });
        }

        const btn = document.createElement('button');
        btn.textContent = '‚úñ';
        btn.title = `Disziplin "${disc.name}" l√∂schen`;
        btn.onclick = (e) => {
          e.stopPropagation(); // Verhindern, dass Notizen-Modal erscheint
          if (confirm(`M√∂chten Sie die Disziplin "${disc.name}" wirklich l√∂schen? Alle zugeh√∂rigen Events im Plan werden ebenfalls entfernt.`)) {
            const removedName = disciplines[index].name;
            disciplines.splice(index, 1);
            // Slots f√ºr diese Disziplin aus Plandaten entfernen
            plan.forEach(facilityPlan => {
              facilityPlan.allocations.forEach(dailySlots => {
                for (let i = dailySlots.length - 1; i >= 0; i--) {
                  if (dailySlots[i].name === removedName) {
                    dailySlots.splice(i, 1);
                  }
                }
              });
            });
            renderSettingsLists();
            renderDiscPanel();
            drawSlots(); // Plan ohne die entfernte Disziplin neuzeichnen
            saveToLocalStorage();
          }
        };
        div.appendChild(btn);
        elements.settings.disciplineList.appendChild(div);
      });
    }

    // Verbesserte Touch-Drag-Unterst√ºtzung f√ºr mobile Ger√§te
    function setupTouchDragEvents(element, dragData) {
      let touchStartX = 0;
      let touchStartY = 0;
      let dragThreshold = 10; // Pixel, die bewegt werden m√ºssen, bevor ein Drag beginnt
      let dragStarted = false;

      element.addEventListener('touchstart', function(e) {
        if (isMobile) {
          // Verhindere Standard-Drag-and-Drop, wir nutzen unseren eigenen
          e.preventDefault();

          const touch = e.touches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
          dragStarted = false;

          // Element und Daten f√ºr sp√§ter speichern
          currentTouchDragElement = element;
          touchDragData = dragData;

          // Visuelles Feedback
          element.classList.add('touch-active');

          // Timer starten - bei langem Dr√ºcken Drag starten
          touchTimeout = setTimeout(() => {
            if (!dragStarted) {
              startTouchDrag(e);
            }
          }, 300);
        }
      }, { passive: false });

      element.addEventListener('touchmove', function(e) {
        if (isMobile && currentTouchDragElement === element) {
          const touch = e.touches[0];
          const deltaX = Math.abs(touch.clientX - touchStartX);
          const deltaY = Math.abs(touch.clientY - touchStartY);

          // Bei ausreichender Bewegung Drag starten
          if (!dragStarted && (deltaX > dragThreshold || deltaY > dragThreshold)) {
            clearTimeout(touchTimeout); // Timer-basierten Drag-Start verhindern
            startTouchDrag(e);
          }

          // Falls Drag l√§uft, Ghost-Element bewegen
          if (dragStarted && ghostElement) {
            moveGhostElement(touch.clientX, touch.clientY);

            // Ziel unter dem Cursor finden und markieren
            const elementsUnderTouch = document.elementsFromPoint(touch.clientX, touch.clientY);
            findAndHighlightDropTarget(elementsUnderTouch);
          }
        }
      }, { passive: false });

      element.addEventListener('touchend', function(e) {
        if (isMobile) {
          clearTimeout(touchTimeout);
          element.classList.remove('touch-active');

          if (dragStarted) {
            endTouchDrag(e);
          } else if (currentTouchDragElement === element) {
            // Dies war ein Tap, keine Drag-Aktion
            // F√ºr Disc-Items: Zeige Selektor
            if (element.classList.contains('disc-item') && disciplines.length > 0) {
              // Keine Aktion hier, Taps f√ºr Slots verwenden wir separat
            }
          }

          currentTouchDragElement = null;
        }
      });

      element.addEventListener('touchcancel', function() {
        if (isMobile) {
          clearTimeout(touchTimeout);
          element.classList.remove('touch-active');
          if (dragStarted) {
            cancelTouchDrag();
          }
          currentTouchDragElement = null;
        }
      });
    }

    function startTouchDrag(e) {
      if (!currentTouchDragElement) return;

      const touch = e.touches[0];
      dragStarted = true;
      isDragging = true;

      // Visuelle Effekte
      currentTouchDragElement.classList.add('dragging');
      dragOverlay.show();

      // Ghost-Element f√ºr visuelles Feedback erstellen
      ghostElement = createDragGhostElement(currentTouchDragElement);
      moveGhostElement(touch.clientX, touch.clientY);

      document.body.style.overflow = 'hidden'; // Scrollen w√§hrend des Ziehens verhindern
    }

    function moveGhostElement(x, y) {
      if (!ghostElement) return;

      ghostElement.style.left = `${x}px`;
      ghostElement.style.top = `${y}px`;

      lastTouchX = x;
      lastTouchY = y;
    }

    function findAndHighlightDropTarget(elementsUnderTouch) {
      // Aktuelles Drop-Target zur√ºcksetzen
      if (currentDropTarget) {
        currentDropTarget.classList.remove('drop-target');
        currentDropTarget = null;
      }

      // G√ºltiges Drop-Target in den Elementen unter dem Touch suchen
      for (const element of elementsUnderTouch) {
        if (element.tagName === 'TD' && element.dataset.dayIndex !== undefined) {
          element.classList.add('drop-target');
          currentDropTarget = element;
          break;
        }
      }
    }

    function endTouchDrag(e) {
      dragStarted = false;
      isDragging = false;

      // Visuelle Effekte aufr√§umen
      if (currentTouchDragElement) {
        currentTouchDragElement.classList.remove('dragging');
      }
      dragOverlay.hide();

      // Drop verarbeiten, falls Ziel vorhanden
      if (currentDropTarget && touchDragData) {
        processTouchDrop(currentDropTarget);
      }

      // Aufr√§umen
      if (ghostElement) {
        document.body.removeChild(ghostElement);
        ghostElement = null;
      }

      if (currentDropTarget) {
        currentDropTarget.classList.remove('drop-target');
        currentDropTarget = null;
      }

      document.body.style.overflow = ''; // Scrollen wieder erlauben
    }

    function cancelTouchDrag() {
      dragStarted = false;
      isDragging = false;

      // Visuelle Effekte aufr√§umen
      if (currentTouchDragElement) {
        currentTouchDragElement.classList.remove('dragging');
      }
      dragOverlay.hide();

      // Aufr√§umen
      if (ghostElement) {
        document.body.removeChild(ghostElement);
        ghostElement = null;
      }

      if (currentDropTarget) {
        currentDropTarget.classList.remove('drop-target');
        currentDropTarget = null;
      }

      document.body.style.overflow = ''; // Scrollen wieder erlauben
    }

    function processTouchDrop(targetCell) {
      try {
        const data = touchDragData;
        const facilityIndex = parseInt(targetCell.dataset.facilityIndex, 10);
        const dayIndex = parseInt(targetCell.dataset.dayIndex, 10);

        // Drop-Position in Zeit berechnen
        const rect = targetCell.getBoundingClientRect();
        const dropX = lastTouchX - rect.left;
        const cellWidth = rect.width;

        const startTime = parseTime(elements.settings.start.value);
        const endTime = parseTime(elements.settings.end.value);
        const totalHours = calculateTotalHours(startTime, endTime);
        const isOvernight = isOvernightRange(startTime, endTime);

        // Zielstunde basierend auf Drop-Position berechnen
        let targetHour = startTime + (dropX / cellWidth) * totalHours;

        // Auf 15-Minuten-Intervalle (0,25 Stunde) runden
        targetHour = Math.round(targetHour * 4) / 4;

        // Bei √úbernacht-Zeitr√§umen: Wenn berechnete Zielzeit nach Mitternacht liegt
        if (isOvernight && targetHour >= 24) {
          targetHour = targetHour - 24;
        }

        if (data.type === 'discipline') {
          // Neuen Slot aus einer Disziplin erstellen
          const discipline = disciplines.find(d => d.id === data.id);
          if (discipline) {
            allocateSlot(facilityIndex, dayIndex, discipline, targetHour);
          }
        } else if (data.type === 'slot') {
          // Bestehenden Slot verschieben
          moveSlot(data.id, facilityIndex, dayIndex, targetHour);
        }

        touchDragData = null;
      } catch (err) {
        console.error('Fehler bei der Touch-Drop-Verarbeitung:', err);
      }
    }

    // Ziehbare Disziplin-Elemente im oberen Panel rendern
    function renderDiscPanel() {
      elements.discPanel.innerHTML = '';

      if (disciplines.length === 0) {
        const emptyMessage = document.createElement('div');
        emptyMessage.textContent = 'Keine Disziplinen vorhanden. F√ºgen Sie √ºber die Einstellungen neue Disziplinen hinzu.';
        emptyMessage.style.padding = '0.5rem';
        emptyMessage.style.color = '#666';
        elements.discPanel.appendChild(emptyMessage);
        return;
      }

      disciplines.forEach(disc => {
        const div = document.createElement('div');
        div.className = 'disc-item';
        div.draggable = true;
        div.style.backgroundColor = disc.color;
        div.textContent = `${disc.name} (${disc.duration}h)`;
        div.dataset.id = disc.id;

        if (disc.notes && disc.notes.trim()) {
          const notesIndicator = document.createElement('span');
          notesIndicator.innerHTML = ' üìù';
          notesIndicator.title = 'Hat Notizen';
          div.appendChild(notesIndicator);
        }

        // Tooltip-Informationen f√ºr Desktop
        div.addEventListener('mouseenter', e => {
          let tooltipContent = `
            <strong>${escapeHtml(disc.name)}</strong><br>
            Dauer: ${disc.duration} Stunden<br>
            ${disc.tags.length > 0 ? `Tags: ${escapeHtml(disc.tags.join(', '))}` : 'Keine Tags'}
          `;

          // Notizen im Tooltip anzeigen, falls vorhanden
          if (disc.notes && disc.notes.trim().length > 0) {
            tooltipContent += `
              <div class="tooltip-section">
                <div class="tooltip-title">Notizen:</div>
                <div class="tooltip-notes">${escapeHtml(disc.notes)}</div>
              </div>
            `;
          }

          tooltip.show(e, tooltipContent);
        });

        div.addEventListener('mouseleave', () => {
          tooltip.hide();
        });

        // HTML5 Drag & Drop f√ºr Desktop einrichten
        div.addEventListener('dragstart', e => {
          // Disziplin-Daten f√ºr den Drop-Handler speichern
          e.dataTransfer.setData('application/json', JSON.stringify({
            type: 'discipline',
            id: disc.id
          }));

          // F√ºr besseres visuelles Feedback
          setTimeout(() => {
            div.classList.add('dragging');
          }, 0);
        });

        div.addEventListener('dragend', () => {
          div.classList.remove('dragging');
        });

        // Touch-Drag-Events f√ºr Mobilger√§te einrichten
        if (isTouchDevice() && isMobile) {
          setupTouchDragEvents(div, {
            type: 'discipline',
            id: disc.id
          });

          // Notizen bei langem Dr√ºcken anzeigen
          div.addEventListener('click', function(e) {
            if (disc.notes && disc.notes.trim()) {
              notesModal.show(
                `Notizen: ${disc.name}`,
                `<div style="white-space: pre-wrap;">${escapeHtml(disc.notes)}</div>`
              );
            }
          });
        }

        elements.discPanel.appendChild(div);
      });
    }

    // --- Core Planungs-Logik ---

    // Planstruktur basierend auf Einstellungen generieren oder aktualisieren
    function generatePlanStructure(clearAllocations = false) {
      const numDays = parseInt(elements.settings.days.value, 10) || 1;
      const currentPlanLength = plan.length;

      // Planarray-Gr√∂√üe an Anlagen anpassen
      if (facilities.length > currentPlanLength) {
        // Neue Eintr√§ge f√ºr neue Anlagen hinzuf√ºgen
        for (let i = currentPlanLength; i < facilities.length; i++) {
          plan.push({ facility: facilities[i], allocations: Array.from({ length: numDays }, () => []) });
        }
      } else if (facilities.length < currentPlanLength) {
        // Dieser Fall wird durch die Facility-L√∂schlogik behandelt, die `plan` filtert
      }

      // Anlagennamen und Tag-Array-L√§nge f√ºr vorhandene Eintr√§ge aktualisieren
      plan.forEach((facilityPlan, index) => {
        facilityPlan.facility = facilities[index]; // Name aktualisieren
        const currentDays = facilityPlan.allocations.length;
        if (numDays > currentDays) {
          // Bei Bedarf leere Tag-Arrays hinzuf√ºgen
          for (let i = currentDays; i < numDays; i++) {
            facilityPlan.allocations.push([]);
          }
        } else if (numDays < currentDays) {
          // √úbersch√ºssige Tag-Arrays entfernen (und deren Slots!)
          facilityPlan.allocations.splice(numDays);
        }
        // Belegungen l√∂schen, falls angefordert (vollst√§ndige Neugenerierung)
        if (clearAllocations) {
          facilityPlan.allocations = Array.from({ length: numDays }, () => []);
        }
      });

      renderTableStructure(numDays);
      drawSlots(); // Vorhandene Slots neuzeichnen
      saveToLocalStorage();

      // Zoom auf Standardwert zur√ºcksetzen
      currentZoom = 1;
      applyZoom();
    }

    // Grundlegende HTML-Tabellenstruktur rendern (Kopfzeilen, Zeilen, Zellen)
    function renderTableStructure(numDays) {
      const headerRow = elements.planTable.querySelector('thead tr');
      // Vorhandene Header au√üer dem ersten l√∂schen
      headerRow.innerHTML = '<th>Anlage / Tag</th>';

      // Tag-Header hinzuf√ºgen
      for (let i = 0; i < numDays; i++) {
        const th = document.createElement('th');
        th.textContent = `Tag ${i + 1}`;
        headerRow.appendChild(th);
      }

      // Vorhandene Tabellenzeilen l√∂schen
      elements.tableBody.innerHTML = '';

      // Anlagenzeilen und Tag-Zellen hinzuf√ºgen
      plan.forEach((facilityPlan, facilityIndex) => {
        const tr = document.createElement('tr');
        tr.dataset.facilityIndex = facilityIndex;

        // Anlagenname-Zelle
        const tdFacility = document.createElement('td');
        tdFacility.textContent = facilityPlan.facility;
        tr.appendChild(tdFacility);

        // Tag-Zellen (Drop-Targets)
        for (let dayIndex = 0; dayIndex < numDays; dayIndex++) {
          const tdDay = document.createElement('td');
          tdDay.dataset.facilityIndex = facilityIndex;
          tdDay.dataset.dayIndex = dayIndex;

          // Zeitmarkierungen und Stundenlinien hinzuf√ºgen
          addTimeIndicators(tdDay);

          // Drop-Zone-Funktionalit√§t hinzuf√ºgen
          addDropZone(tdDay);

          tr.appendChild(tdDay);
        }

        elements.tableBody.appendChild(tr);
      });
    }

    // Zeitindikatoren zu einer Zelle hinzuf√ºgen
    function addTimeIndicators(cell) {
      const startTime = parseTime(elements.settings.start.value);
      const endTime = parseTime(elements.settings.end.value);
      const totalHours = calculateTotalHours(startTime, endTime);
      const isOvernight = isOvernightRange(startTime, endTime);

      if (totalHours <= 0) return;

      // Start-Zeitmarkierung hinzuf√ºgen
      const startMarker = document.createElement('div');
      startMarker.className = 'time-marker start';
      startMarker.textContent = formatTime(startTime);
      cell.appendChild(startMarker);

      // Mittlere Zeitmarkierung hinzuf√ºgen
      let middleTime;
      if (isOvernight) {
        // Bei √úbernacht-Zeitr√§umen Mittelpunkt korrekt berechnen
        middleTime = startTime + totalHours / 2;
        if (middleTime >= 24) {
          middleTime = middleTime - 24;
        }
      } else {
        middleTime = startTime + totalHours / 2;
      }

      const middleMarker = document.createElement('div');
      middleMarker.className = 'time-marker middle';
      middleMarker.textContent = formatTime(middleTime);
      cell.appendChild(middleMarker);

      // End-Zeitmarkierung hinzuf√ºgen
      const endMarker = document.createElement('div');
      endMarker.className = 'time-marker end';
      endMarker.textContent = formatTime(endTime);
      cell.appendChild(endMarker);

      // Stundenlinien f√ºr bessere visuelle Referenz hinzuf√ºgen
      if (isOvernight) {
        // F√ºr √úbernacht-Zeitr√§ume: Stundenlinien von Startzeit bis Mitternacht
        for (let hour = Math.ceil(startTime); hour < 24; hour++) {
          const position = ((hour - startTime) / totalHours) * 100;
          const hourLine = document.createElement('div');
          hourLine.className = 'hour-line';
          hourLine.style.left = `${position}%`;
          cell.appendChild(hourLine);
        }

        // Stundenlinien von Mitternacht bis Endzeit
        for (let hour = 0; hour < endTime; hour++) {
          const position = ((hour + 24 - startTime) / totalHours) * 100;
          const hourLine = document.createElement('div');
          hourLine.className = 'hour-line';
          hourLine.style.left = `${position}%`;
          cell.appendChild(hourLine);
        }
      } else {
        // Normaler Fall (nicht √ºber Mitternacht)
        for (let hour = Math.ceil(startTime); hour < endTime; hour++) {
          const position = ((hour - startTime) / totalHours) * 100;
          const hourLine = document.createElement('div');
          hourLine.className = 'hour-line';
          hourLine.style.left = `${position}%`;
          cell.appendChild(hourLine);
        }
      }
    }

    // Drop-Zone-Funktionalit√§t f√ºr eine Zelle einrichten
    function addDropZone(cell) {
      // HTML5 Drops f√ºr Desktop erlauben
      cell.addEventListener('dragover', e => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        cell.classList.add('drop-target');
      });

      cell.addEventListener('dragleave', () => {
        cell.classList.remove('drop-target');
      });

      cell.addEventListener('drop', e => {
        e.preventDefault();
        cell.classList.remove('drop-target');

        try {
          // Gezogene Daten abrufen
          const dataString = e.dataTransfer.getData('application/json');
          if (!dataString) return;

          const data = JSON.parse(dataString);
          const facilityIndex = parseInt(cell.dataset.facilityIndex, 10);
          const dayIndex = parseInt(cell.dataset.dayIndex, 10);

          // Drop-Position in Zeit berechnen
          const rect = cell.getBoundingClientRect();
          const dropX = e.clientX - rect.left;
          const cellWidth = rect.width;

          const startTime = parseTime(elements.settings.start.value);
          const endTime = parseTime(elements.settings.end.value);
          const totalHours = calculateTotalHours(startTime, endTime);
          const isOvernight = isOvernightRange(startTime, endTime);

          // Zielstunde basierend auf Drop-Position berechnen
          let targetHour = startTime + (dropX / cellWidth) * totalHours;

          // Auf 15-Minuten-Intervalle runden (0,25 Stunde)
          targetHour = Math.round(targetHour * 4) / 4;

          // Bei √úbernacht-Zeitr√§umen: Wenn berechnete Zielzeit nach Mitternacht liegt
          if (isOvernight && targetHour >= 24) {
            targetHour = targetHour - 24;
          }

          if (data.type === 'discipline') {
            // Neuen Slot aus einer Disziplin erstellen
            const discipline = disciplines.find(d => d.id === data.id);
            if (discipline) {
              allocateSlot(facilityIndex, dayIndex, discipline, targetHour);
            }
          } else if (data.type === 'slot') {
            // Bestehenden Slot verschieben
            moveSlot(data.id, facilityIndex, dayIndex, targetHour);
          }
        } catch (err) {
          console.error('Fehler bei der Drop-Verarbeitung:', err);
        }
      });

      // Touch-Tap zum Hinzuf√ºgen f√ºr Mobilger√§te
      if (isTouchDevice() && isMobile) {
        cell.addEventListener('click', function(e) {
          // Wenn wir auf eine leere Stelle in der Zelle klicken und nicht auf einen Slot
          if (e.target === cell && disciplines.length > 0) {
            const rect = cell.getBoundingClientRect();
            const tapX = e.clientX - rect.left;
            const cellWidth = rect.width;

            const startTime = parseTime(elements.settings.start.value);
            const endTime = parseTime(elements.settings.end.value);
            const totalHours = calculateTotalHours(startTime, endTime);

            // Zielzeit basierend auf Tap-Position berechnen
            let targetHour = startTime + (tapX / cellWidth) * totalHours;

            // Auf 15-Minuten-Intervalle runden (0,25 Stunde)
            targetHour = Math.round(targetHour * 4) / 4;

            // Bei √úbernacht-Zeitr√§umen korrigieren
            const isOvernight = isOvernightRange(startTime, endTime);
            if (isOvernight && targetHour >= 24) {
              targetHour = targetHour - 24;
            }

            // Disziplin-Auswahldialog anzeigen
            disciplineSelector.show(cell, targetHour);
          }
        });
      }
    }

    // Slot anhand ID finden
    function findSlotById(slotId) {
      for (let fi = 0; fi < plan.length; fi++) {
        for (let di = 0; di < plan[fi].allocations.length; di++) {
          const slotIndex = plan[fi].allocations[di].findIndex(s => s.id === slotId);
          if (slotIndex !== -1) {
            return {
              slot: plan[fi].allocations[di][slotIndex],
              facilityIndex: fi,
              dayIndex: di,
              slotIndex
            };
          }
        }
      }
      return null;
    }

    // Zeitkonflikte zwischen Slots pr√ºfen
    function checkSlotConflicts(daySlots) {
      // Konflikt-Map erstellen, um zu verfolgen, welche Slots mit welchen anderen in Konflikt stehen
      const conflictMap = new Map();

      // Zuerst alle Konflikte finden
      for (let i = 0; i < daySlots.length; i++) {
        const slotA = daySlots[i];
        const startA = slotA.startHour;
        const endA = startA + slotA.duration;

        for (let j = i + 1; j < daySlots.length; j++) {
          const slotB = daySlots[j];
          const startB = slotB.startHour;
          const endB = startB + slotB.duration;

          // Auf √úberlappung pr√ºfen
          if (startA < endB && startB < endA) {
            // Zu Konflikt-Map f√ºr beide Slots hinzuf√ºgen
            if (!conflictMap.has(slotA.id)) {
              conflictMap.set(slotA.id, new Set());
            }
            if (!conflictMap.has(slotB.id)) {
              conflictMap.set(slotB.id, new Set());
            }

            conflictMap.get(slotA.id).add(slotB.id);
            conflictMap.get(slotB.id).add(slotA.id);
          }
        }
      }

      return conflictMap;
    }

    // Neuen Slot in den Plandaten zuweisen
    function allocateSlot(facilityIndex, dayIndex, discipline, startHour) {
      // Neues Slot-Objekt erstellen
      const newSlot = {
        id: generateId(),
        name: discipline.name,
        duration: discipline.duration,
        tags: discipline.tags || [],
        color: discipline.color,
        startHour: startHour,
        notes: discipline.notes || ''
      };

      // Zum Plan hinzuf√ºgen
      plan[facilityIndex].allocations[dayIndex].push(newSlot);

      // Slots nach Startzeit sortieren
      plan[facilityIndex].allocations[dayIndex].sort((a, b) => a.startHour - b.startHour);

      // Alle Slots neuzeichnen
      drawSlots();

      // In localStorage speichern
      saveToLocalStorage();
    }

    // Bestehenden Slot an eine neue Position verschieben
    function moveSlot(slotId, targetFacilityIndex, targetDayIndex, targetStartHour) {
      const slotInfo = findSlotById(slotId);
      if (!slotInfo) return;

      const { slot, facilityIndex, dayIndex, slotIndex } = slotInfo;

      // Von Quelle entfernen
      plan[facilityIndex].allocations[dayIndex].splice(slotIndex, 1);

      // Slot klonen und Startzeit aktualisieren
      const movedSlot = { ...slot, startHour: targetStartHour };

      // Zum Ziel hinzuf√ºgen
      plan[targetFacilityIndex].allocations[targetDayIndex].push(movedSlot);

      // Ziel-Tag-Slots nach Startzeit sortieren
      plan[targetFacilityIndex].allocations[targetDayIndex].sort((a, b) => a.startHour - b.startHour);

      // Alle Slots neuzeichnen
      drawSlots();

      // In localStorage speichern
      saveToLocalStorage();
    }

    // Slot anhand seiner ID l√∂schen
    function deleteSlot(slotId) {
      const slotInfo = findSlotById(slotId);
      if (!slotInfo) return;

      const { facilityIndex, dayIndex, slotIndex } = slotInfo;

      // Slot entfernen
      plan[facilityIndex].allocations[dayIndex].splice(slotIndex, 1);

      // Alle Slots neuzeichnen
      drawSlots();

      // In localStorage speichern
      saveToLocalStorage();
    }

    // Alle Slots auf die Tabelle zeichnen
    function drawSlots() {
      // Zuerst alle vorhandenen Slots entfernen
      document.querySelectorAll('.slot').forEach(s => s.remove());

      const startTime = parseTime(elements.settings.start.value);
      const endTime = parseTime(elements.settings.end.value);
      const totalHours = calculateTotalHours(startTime, endTime);
      const isOvernight = isOvernightRange(startTime, endTime);

      if (totalHours <= 0) return;

      // Slots f√ºr jede Anlage und jeden Tag zeichnen
      plan.forEach((facilityPlan, facilityIndex) => {
        const facilityRow = elements.tableBody.querySelector(`tr[data-facility-index="${facilityIndex}"]`);
        if (!facilityRow) return;

        facilityPlan.allocations.forEach((daySlots, dayIndex) => {
          const dayCell = facilityRow.querySelector(`td[data-day-index="${dayIndex}"]`);
          if (!dayCell) return;

          // Slots nach Startzeit sortieren
          daySlots.sort((a, b) => a.startHour - b.startHour);

          // Alle Konflikte finden
          const conflictMap = checkSlotConflicts(daySlots);

          // Jeden Slot zeichnen
          daySlots.forEach((slot, slotIndex) => {
            const slotElement = document.createElement('div');
            slotElement.className = 'slot';

            // Hat Konflikt?
            const hasConflicts = conflictMap.has(slot.id) && conflictMap.get(slot.id).size > 0;

            if (hasConflicts) {
              slotElement.classList.add('conflict');

              // Verschiedene z-Indizes f√ºr konfliktierende Slots f√ºr korrektes Layering
              const conflictIndex = Array.from(conflictMap.get(slot.id)).indexOf(slot.id) % 3 + 1;
              slotElement.classList.add(`conflict-${conflictIndex}`);
            } else {
              slotElement.classList.add('ok');
            }

            slotElement.draggable = true;
            slotElement.style.backgroundColor = slot.color;
            slotElement.dataset.id = slot.id;

            // Slot-Daten f√ºr mobile Aktionen speichern
            slotElement.dataset.name = slot.name;
            slotElement.dataset.notes = slot.notes || '';

            // Position und Breite berechnen
            let adjustedStartHour = slot.startHour;

            // F√ºr √úbernacht-Zeitr√§ume: Wenn der Slot nach Mitternacht und vor der Startzeit liegt
            if (isOvernight && slot.startHour < startTime && slot.startHour <= endTime) {
              adjustedStartHour = slot.startHour + 24;
            }

            const leftPercent = ((adjustedStartHour - startTime) / totalHours) * 100;
            const widthPercent = (slot.duration / totalHours) * 100;

            slotElement.style.left = `${Math.max(0, leftPercent)}%`;
            slotElement.style.width = `${widthPercent}%`;

            // Inhalt mit einem Span f√ºr besseres Styling hinzuf√ºgen
            const textSpan = document.createElement('span');
            textSpan.className = 'slot-text';
            textSpan.textContent = slot.name;
            slotElement.appendChild(textSpan);

            // L√∂sch-Button hinzuf√ºgen (auf Desktop sichtbar, auf Mobilger√§ten optional)
            if (!isMobile || !isTouchDevice()) {
              const deleteBtn = document.createElement('button');
              deleteBtn.className = 'delete-slot';
              deleteBtn.innerHTML = '‚úñ';
              deleteBtn.title = 'L√∂schen';
              deleteBtn.onclick = e => {
                e.stopPropagation();
                if (confirm(`M√∂chten Sie "${slot.name}" wirklich l√∂schen?`)) {
                  deleteSlot(slot.id);
                }
              };
              slotElement.appendChild(deleteBtn);
            }

            // Notizen-Indikator hinzuf√ºgen, falls vorhanden
            if (slot.notes && slot.notes.trim()) {
              const notesIndicator = document.createElement('span');
              notesIndicator.className = 'notes-indicator';
              notesIndicator.innerHTML = 'üìù';
              notesIndicator.title = 'Tippen zum Anzeigen der Notizen';
              slotElement.appendChild(notesIndicator);
            }

            // Tooltip hinzuf√ºgen (f√ºr Desktop)
            if (!isMobile || !isTouchDevice()) {
              slotElement.addEventListener('mouseenter', e => {
                let tooltipContent = `
                  <strong>${escapeHtml(slot.name)}</strong><br>
                  Zeit: ${formatTime(slot.startHour)} - ${formatTime(slot.startHour + slot.duration)}<br>
                  Dauer: ${slot.duration} Stunden<br>
                  ${slot.tags.length > 0 ? `Tags: ${escapeHtml(slot.tags.join(', '))}` : ''}
                `;

                // Notizen zum Tooltip hinzuf√ºgen, falls vorhanden
                if (slot.notes && slot.notes.trim().length > 0) {
                  tooltipContent += `
                    <div class="tooltip-section">
                      <div class="tooltip-title">Notizen:</div>
                      <div class="tooltip-notes">${escapeHtml(slot.notes)}</div>
                    </div>
                  `;
                }

                // Konfliktinformationen hinzuf√ºgen, falls vorhanden
                if (hasConflicts) {
                  const conflictingSlots = [];

                  // Namen konfliktierender Slots abrufen
                  daySlots.forEach(otherSlot => {
                    if (conflictMap.get(slot.id).has(otherSlot.id)) {
                      conflictingSlots.push(otherSlot.name);
                    }
                  });

                  tooltipContent += `
                    <div class="tooltip-conflict">
                      Konflikt mit: ${escapeHtml(conflictingSlots.join(', '))}
                    </div>
                  `;
                }

                tooltip.show(e, tooltipContent);
              });

              slotElement.addEventListener('mouseleave', () => {
                tooltip.hide();
              });
            }

            // HTML5 Drag-and-Drop f√ºr Desktop
            slotElement.addEventListener('dragstart', e => {
              e.dataTransfer.setData('application/json', JSON.stringify({
                type: 'slot',
                id: slot.id
              }));

              // F√ºr besseres visuelles Feedback
              setTimeout(() => {
                slotElement.classList.add('dragging');
              }, 0);
            });

            slotElement.addEventListener('dragend', () => {
              slotElement.classList.remove('dragging');
            });

            // Custom Touch-Drag-Events f√ºr mobile Ger√§te
            if (isTouchDevice() && isMobile) {
              setupTouchDragEvents(slotElement, {
                type: 'slot',
                id: slot.id
              });

              // Tap zum Anzeigen des Aktionsmen√ºs
              slotElement.addEventListener('click', function(e) {
                e.stopPropagation();
                slotActions.show(slot);
              });
            } else {
              // Doppelklick zum Anzeigen von Notizen im Modal (f√ºr Desktop)
              if (slot.notes && slot.notes.trim().length > 0) {
                slotElement.addEventListener('dblclick', () => {
                  notesModal.show(
                    `Notizen: ${slot.name}`,
                    `<div style="white-space: pre-wrap;">${escapeHtml(slot.notes)}</div>`
                  );
                });
              }
            }

            // Auf Zeit√ºberschreitung pr√ºfen (au√üerhalb Start-/Endzeit)
            if (isOvernight) {
              // F√ºr √úbernacht-Zeitr√§ume: Pr√ºfen, ob Slot au√üerhalb des Zeitbereichs liegt
              const adjustedEndHour = slot.startHour + slot.duration;

              // Bei √úbernacht-Zeitbereich pr√ºfen, ob Slot zwischen endTime und startTime liegt
              // oder au√üerhalb des g√ºltigen Bereichs (startTime bis endTime+24) liegt
              const isOutsideTimeRange = (slot.startHour > endTime && slot.startHour < startTime) ||
                                         (adjustedEndHour > endTime && slot.startHour >= startTime) ||
                                         (adjustedStartHour + slot.duration > startTime + totalHours);

              if (isOutsideTimeRange) {
                slotElement.classList.add('overflow');
              }
            } else {
              // Normale Pr√ºfung f√ºr Zeitbereiche innerhalb eines Tages
              if (slot.startHour < startTime || slot.startHour + slot.duration > endTime) {
                slotElement.classList.add('overflow');
              }
            }

            dayCell.appendChild(slotElement);
          });
        });
      });
    }

    // --- Export-Funktionen ---

    // Plan als CSV exportieren
    function exportToCsv() {
      let csvContent = 'Anlage;Tag;Startzeit;Endzeit;Dauer (h);Disziplin;Tags;Notizen;Konflikte\n';

      plan.forEach(facilityPlan => {
        facilityPlan.allocations.forEach((daySlots, dayIndex) => {
          // Konfliktinformationen abrufen
          const conflictMap = checkSlotConflicts(daySlots);

          daySlots.forEach(slot => {
            const startTimeStr = formatTime(slot.startHour);
            const endTimeStr = formatTime(slot.startHour + slot.duration);
            const tagsStr = `"${slot.tags.join(', ')}"`;
            // Anf√ºhrungszeichen in Notizen f√ºr CSV escapen
            const notesStr = `"${(slot.notes || '').replace(/"/g, '""')}"`;

            // Konfliktinformationen abrufen
            let conflictStr = '""';
            if (conflictMap.has(slot.id) && conflictMap.get(slot.id).size > 0) {
              const conflictingSlots = [];
              daySlots.forEach(otherSlot => {
                if (conflictMap.get(slot.id).has(otherSlot.id)) {
                  conflictingSlots.push(otherSlot.name);
                }
              });
              conflictStr = `"${conflictingSlots.join(', ').replace(/"/g, '""')}"`;
            }

            csvContent += `${facilityPlan.facility};${dayIndex + 1};${startTimeStr};${endTimeStr};${slot.duration.toFixed(2)};${slot.name};${tagsStr};${notesStr};${conflictStr}\n`;
          });
        });
      });

      // Download-Link erstellen
      const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' }); // BOM f√ºr Excel
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'belegungsplan.csv';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    // Plan als PDF exportieren
    async function exportToPdf() {
      if (typeof html2canvas === 'undefined' || typeof jspdf === 'undefined') {
        alert("PDF Export-Bibliotheken nicht geladen.");
        return;
      }

      const { jsPDF } = window.jspdf;
      const tableElement = elements.planTable;

      // Ladeindikator anzeigen
      const originalButtonText = elements.exportPdf.textContent;
      elements.exportPdf.textContent = 'PDF...';
      elements.exportPdf.disabled = true;

      try {
        // Zoom f√ºr den Export zur√ºcksetzen
        const originalTransform = tableElement.style.transform;
        tableElement.style.transform = 'scale(1)';

        const canvas = await html2canvas(tableElement, {
          scale: 1.5,
          useCORS: true,
          logging: false,
          windowWidth: tableElement.scrollWidth,
          windowHeight: tableElement.scrollHeight
        });

        // Urspr√ºnglichen Zoom wiederherstellen
        tableElement.style.transform = originalTransform;

        const imgData = canvas.toDataURL('image/png');

        // PDF mit passender Gr√∂√üe erstellen
        const pdf = new jsPDF({
          orientation: 'landscape',
          unit: 'mm'
        });

        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();

        const imgWidth = canvas.width;
        const imgHeight = canvas.height;

        // Skalierung zur passenden Anzeige auf der Seite mit Beibehaltung des Seitenverh√§ltnisses
        const ratio = Math.min(pageWidth / imgWidth, pageHeight / imgHeight);

        // Auf Seite zentrieren
        const xPos = (pageWidth - imgWidth * ratio) / 2;
        const yPos = 10; // Oberer Rand

        pdf.addImage(imgData, 'PNG', xPos, yPos, imgWidth * ratio, imgHeight * ratio);

        // Konfliktinformationen und Notizen hinzuf√ºgen
        let hasConflicts = false;
        let hasNotes = false;

        plan.forEach(facilityPlan => {
          facilityPlan.allocations.forEach(daySlots => {
            const conflictMap = checkSlotConflicts(daySlots);

            // Auf Konflikte pr√ºfen
            if (!hasConflicts) {
              for (let slot of daySlots) {
                if (conflictMap.has(slot.id) && conflictMap.get(slot.id).size > 0) {
                  hasConflicts = true;
                  break;
                }
              }
            }

            // Auf Notizen pr√ºfen
            if (!hasNotes) {
              for (let slot of daySlots) {
                if (slot.notes && slot.notes.trim()) {
                  hasNotes = true;
                  break;
                }
              }
            }
          });
        });

        // Zus√§tzliche Seite bei Konflikten oder Notizen hinzuf√ºgen
        if (hasConflicts || hasNotes) {
          pdf.addPage();
          pdf.setFont('helvetica', 'bold');
          pdf.setFontSize(16);
          pdf.text('Zus√§tzliche Informationen', 14, 20);
          pdf.setFont('helvetica', 'normal');
          pdf.setFontSize(11);

          let yPosition = 30;

          // Konfliktbereich hinzuf√ºgen
          if (hasConflicts) {
            pdf.setFont('helvetica', 'bold');
            pdf.text('Zeitkonflikte:', 14, yPosition);
            pdf.setFont('helvetica', 'normal');
            yPosition += 10;

            // Konflikte auflisten
            let conflictListed = false;

            plan.forEach(facilityPlan => {
              facilityPlan.allocations.forEach((daySlots, dayIndex) => {
                const conflictMap = checkSlotConflicts(daySlots);

                // Jeden Slot auf Konflikte pr√ºfen
                daySlots.forEach(slot => {
                  if (conflictMap.has(slot.id) && conflictMap.get(slot.id).size > 0) {
                    const conflictingSlots = [];
                    daySlots.forEach(otherSlot => {
                      if (conflictMap.get(slot.id).has(otherSlot.id)) {
                        conflictingSlots.push(otherSlot.name);
                      }
                    });

                    if (conflictingSlots.length > 0) {
                      const conflictText = `${facilityPlan.facility}, Tag ${dayIndex + 1}: ${slot.name} ‚Üî ${conflictingSlots.join(', ')}`;

                      // Auf Seitenumbruch pr√ºfen
                      if (yPosition > pageHeight - 20) {
                        pdf.addPage();
                        yPosition = 20;
                      }

                      pdf.text(conflictText, 14, yPosition);
                      yPosition += 6;
                      conflictListed = true;
                    }
                  }
                });
              });
            });

            if (!conflictListed) {
              pdf.text('Keine Konflikte gefunden.', 14, yPosition);
              yPosition += 6;
            }

            yPosition += 10; // Platz vor Notizenbereich hinzuf√ºgen
          }

          // Notizenbereich hinzuf√ºgen
          if (hasNotes) {
            pdf.setFont('helvetica', 'bold');
            pdf.text('Notizen zu Disziplinen:', 14, yPosition);
            pdf.setFont('helvetica', 'normal');
            yPosition += 10;

            // Disziplin-Notizen auflisten
            disciplines.forEach(disc => {
              if (disc.notes && disc.notes.trim()) {
                // Auf Seitenumbruch pr√ºfen
                if (yPosition > pageHeight - 20) {
                  pdf.addPage();
                  yPosition = 20;
                }

                pdf.setFont('helvetica', 'bold');
                pdf.text(`${disc.name} (${disc.duration}h)`, 14, yPosition);
                pdf.setFont('helvetica', 'normal');

                // Notizen in Zeilen aufteilen, um Seitenbreite einzuhalten
                const textLines = pdf.splitTextToSize(disc.notes, pageWidth - 28);
                pdf.text(textLines, 14, yPosition + 6);

                yPosition += 6 + (textLines.length * 6) + 10; // Platz f√ºr Titel + Text + Rand hinzuf√ºgen
              }
            });
          }
        }

        pdf.save('belegungsplan.pdf');
      } catch (error) {
        console.error('Fehler beim PDF-Export:', error);
        alert('Fehler beim Erstellen des PDFs.');
      } finally {
        // Button wiederherstellen
        elements.exportPdf.textContent = originalButtonText;
        elements.exportPdf.disabled = false;
      }
    }

    // --- LocalStorage-Funktionen ---

    // Zustand in localStorage speichern
    function saveToLocalStorage() {
      try {
        localStorage.setItem('eventPlannerFacilities', JSON.stringify(facilities));
        localStorage.setItem('eventPlannerDisciplines', JSON.stringify(disciplines));
        localStorage.setItem('eventPlannerPlan', JSON.stringify(plan));
      } catch (e) {
        console.warn('Fehler beim Speichern im localStorage:', e);
      }
    }

    // Zustand aus localStorage laden
    function loadFromLocalStorage() {
      try {
        const savedFacilities = localStorage.getItem('eventPlannerFacilities');
        const savedDisciplines = localStorage.getItem('eventPlannerDisciplines');
        const savedPlan = localStorage.getItem('eventPlannerPlan');

        if (savedFacilities) facilities = JSON.parse(savedFacilities);
        if (savedDisciplines) disciplines = JSON.parse(savedDisciplines);
        if (savedPlan) plan = JSON.parse(savedPlan);

        // Falls nichts gespeichert wurde, Standardwerte verwenden
        if (!facilities.length) {
          facilities = ['Halle A', 'Halle B', 'Sportplatz', 'Kraftraum'];
        }

        if (!disciplines.length) {
          disciplines = [
            {
              id: generateId(),
              name: '50m_einbein',
              duration: 1.5,
              tags: ['RACE', 'Indoor'],
              color: '#f44336',
              notes: 'Ben√∂tigt Startbl√∂cke und Stoppuhren. Bei Regen auf Halle ausweichen.'
            },
            {
              id: generateId(),
              name: '10K_Marathon',
              duration: 1.5,
              tags: ['RACE', 'Outdoor', 'Street'],
              color: '#6850a4',
              notes: 'Ben√∂tigt Startbl√∂cke und Stoppuhren/Zeitnahme. Bei Regen auf Halle ausweichen?'
            },
            {
              id: generateId(),
              name: 'Freestyle_J1',
              duration: 6,
              tags: ['Freestyle', 'Indoor'],
              color: '#1f525d',
              notes: 'Ben√∂tigt Startbl√∂cke und Stoppuhren. Bei Regen auf Halle ausweichen.'
            },
            {
              id: generateId(),
              name: '100m_SPRINT',
              duration: 2,
              tags: ['RACE', 'Outdoor'],
              color: '#9C27B0',
              notes: 'Gewichte m√ºssen vorher aufgebaut werden. Max. 10 Teilnehmer.'
            },
            {
              id: generateId(),
              name: 'UNI_HOCKEY',
              duration: 1,
              tags: ['Mannschaft', 'Indoor'],
              color: '#4CAF50',
              notes: 'Matten bereitstellen. Umkleiden 30 min vorher √∂ffnen.'
            },
            {
              id: generateId(),
              name: 'UNI_BASKETBALL',
              duration: 2.5,
              tags: ['Mannschaft', 'Outdoor'],
              color: '#2196F3',
              notes: 'Tore und B√§lle vorbereiten. Schiedsrichter einplanen.'
            }
          ];
        }

        // Sicherstellen, dass die Planstruktur mit den aktuellen Einstellungen √ºbereinstimmt
        const numDays = parseInt(elements.settings.days.value, 10) || 1;
        if (!plan.length || plan.length !== facilities.length ||
            plan.some((f, i) => f.facility !== facilities[i] || f.allocations.length !== numDays)) {
          generatePlanStructure(false);
        }
      } catch (e) {
        console.warn('Fehler beim Laden aus localStorage:', e);
        facilities = ['Halle A', 'Halle B', 'Sportplatz', 'Kraftraum'];
        disciplines = [
          {
            id: generateId(),
            name: '50m_einbein',
            duration: 1.5,
            tags: ['RACE', 'Indoor'],
            color: '#f44336',
            notes: 'Ben√∂tigt Startbl√∂cke und Stoppuhren. Bei Regen auf Halle ausweichen.'
          },
          {
            id: generateId(),
            name: '10K_Marathon',
            duration: 1.5,
            tags: ['RACE', 'Outdoor', 'Street'],
            color: '#6850a4',
            notes: 'Ben√∂tigt Startbl√∂cke und Stoppuhren/Zeitnahme. Bei Regen auf Halle ausweichen?'
          },
          {
            id: generateId(),
            name: 'Freestyle_J1',
            duration: 6,
            tags: ['Freestyle', 'Indoor'],
            color: '#1f525d',
            notes: 'Ben√∂tigt Startbl√∂cke und Stoppuhren. Bei Regen auf Halle ausweichen.'
          },
          {
            id: generateId(),
            name: '100m_SPRINT',
            duration: 2,
            tags: ['RACE', 'Outdoor'],
            color: '#9C27B0',
            notes: 'Gewichte m√ºssen vorher aufgebaut werden. Max. 10 Teilnehmer.'
          },
          {
            id: generateId(),
            name: 'UNI_HOCKEY',
            duration: 1,
            tags: ['Mannschaft', 'Indoor'],
            color: '#4CAF50',
            notes: 'Matten bereitstellen. Umkleiden 30 min vorher √∂ffnen.'
          },
          {
            id: generateId(),
            name: 'UNI_BASKETBALL',
            duration: 2.5,
            tags: ['Mannschaft', 'Outdoor'],
            color: '#2196F3',
            notes: 'Tore und B√§lle vorbereiten. Schiedsrichter einplanen.'
          }
        ];
        generatePlanStructure(true);
      }
    }

    // --- Anwendung initialisieren ---
    function initialize() {
      // Mobile Hilfsfunktionen initialisieren
      slotActions.initialize();
      zoomControls.initialize();
      disciplineSelector.initialize();

      // Excel Preview Modal initialisieren
      previewModal.initialize();

      // Mobile Drag & Drop aktivieren
      if (isTouchDevice()) {
        window.addEventListener('touchmove', function(event) {
          if (isDragging) {
            event.preventDefault();
          }
        }, { passive: false });
      }

      // Gespeicherte Daten laden
      loadFromLocalStorage();

      // UI-Komponenten rendern
      renderSettingsLists();
      renderDiscPanel();
      renderTableStructure(parseInt(elements.settings.days.value, 10) || 1);
      drawSlots();

      // Speichern beim Verlassen einrichten
      window.addEventListener('beforeunload', saveToLocalStorage);

      // Auf Orientierungs√§nderungen h√∂ren
      window.addEventListener('orientationchange', function() {
        // Kurze Verz√∂gerung f√ºr vollst√§ndige Neuausrichtung
        setTimeout(function() {
          // Zoom zur√ºcksetzen, wenn sich die Orientierung √§ndert
          currentZoom = 1;
          applyZoom();
        }, 300);
      });
    }

    // Anwendung starten
    initialize();
  </script>
</body>
</html>
